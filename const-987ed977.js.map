{"version":3,"file":"const-987ed977.js","sources":["../../../../node_modules/@libp2p/webrtc-direct/node_modules/multiformats/vendor/base-x.js","../../../../node_modules/@libp2p/webrtc-direct/node_modules/multiformats/src/bytes.js","../../../../node_modules/@libp2p/webrtc-direct/node_modules/multiformats/src/bases/base.js","../../../../node_modules/@libp2p/webrtc-direct/node_modules/multiformats/src/bases/base58.js","../../../../node_modules/@libp2p/webrtc-direct/dist/src/constants.js","../../../../node_modules/@libp2p/webrtc-direct/dist/src/socket-to-conn.js","../../../../node_modules/@libp2p/webrtc-direct/dist/src/listener.browser.js","../../../../node_modules/@libp2p/webrtc-direct/dist/src/index.js","../../../../node_modules/@constl/ipa/dist/src/sfip/const.js"],"sourcesContent":["// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","// p2p multi-address code\nexport const CODE_P2P = 421;\nexport const CODE_CIRCUIT = 290;\n// Time to wait for a connection to close gracefully before destroying it\n// manually\nexport const CLOSE_TIMEOUT = 2000;\n//# sourceMappingURL=constants.js.map","import { abortableSource } from 'abortable-iterator';\nimport { CLOSE_TIMEOUT } from './constants.js';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:webrtc-direct:socket');\nexport function toMultiaddrConnection(socket, options) {\n    const { sink, source } = socket;\n    const maConn = {\n        remoteAddr: options.remoteAddr,\n        async sink(source) {\n            if (options.signal != null) {\n                source = abortableSource(source, options.signal);\n            }\n            try {\n                await sink(source);\n            }\n            catch (err) {\n                // If aborted we can safely ignore\n                if (err.type !== 'aborted') {\n                    // If the source errored the socket will already have been destroyed by\n                    // toIterable.duplex(). If the socket errored it will already be\n                    // destroyed. There's nothing to do here except log the error & return.\n                    log.error(err);\n                }\n            }\n        },\n        source: (options.signal != null) ? abortableSource(source, options.signal) : source,\n        timeline: { open: Date.now() },\n        async close() {\n            if (socket.closed) {\n                return;\n            }\n            const start = Date.now();\n            // Attempt to end the socket. If it takes longer to close than the\n            // timeout, destroy it manually.\n            const timeout = setTimeout(() => {\n                if (maConn.remoteAddr != null) {\n                    const { host, port } = maConn.remoteAddr.toOptions();\n                    log('timeout closing socket to %s:%s after %dms, destroying it manually', host, port, Date.now() - start);\n                }\n                if (!socket.closed) {\n                    socket.close().catch(err => {\n                        log.error('could not close socket', err);\n                    });\n                }\n            }, CLOSE_TIMEOUT);\n            try {\n                await socket.close();\n            }\n            finally {\n                clearTimeout(timeout);\n            }\n        }\n    };\n    socket.addEventListener('close', () => {\n        // In instances where `close` was not explicitly called,\n        // such as an iterable stream ending, ensure we have set the close\n        // timeline\n        if (maConn.timeline.close == null) {\n            maConn.timeline.close = Date.now();\n        }\n    }, {\n        once: true\n    });\n    return maConn;\n}\n//# sourceMappingURL=socket-to-conn.js.map","export function createListener() {\n    throw new Error('WebRTCDirect Servers can not be created in the browser!');\n}\n//# sourceMappingURL=listener.browser.js.map","import { logger } from '@libp2p/logger';\nimport * as mafmt from '@multiformats/mafmt';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { fetch } from 'native-fetch';\nimport { AbortError } from 'abortable-iterator';\nimport { toString } from 'uint8arrays/to-string';\nimport { fromString } from 'uint8arrays/from-string';\nimport { CODE_CIRCUIT, CODE_P2P } from './constants.js';\nimport { toMultiaddrConnection } from './socket-to-conn.js';\nimport { createListener } from './listener.js';\nimport { WebRTCInitiator } from '@libp2p/webrtc-peer';\nimport { symbol } from '@libp2p/interface-transport';\nconst log = logger('libp2p:webrtc-direct');\nclass WebRTCDirect {\n    constructor(init) {\n        this.initiatorOptions = init?.initiatorOptions;\n        this.recieverOptions = init?.recieverOptions;\n        this.wrtc = init?.wrtc;\n    }\n    get [symbol]() {\n        return true;\n    }\n    get [Symbol.toStringTag]() {\n        return '@libp2p/webrtc-direct';\n    }\n    async dial(ma, options) {\n        const socket = await this._connect(ma, options);\n        const maConn = toMultiaddrConnection(socket, { remoteAddr: ma, signal: options.signal });\n        log('new outbound connection %s', maConn.remoteAddr);\n        const conn = await options.upgrader.upgradeOutbound(maConn);\n        log('outbound connection %s upgraded', maConn.remoteAddr);\n        return conn;\n    }\n    async _connect(ma, options) {\n        if (options.signal?.aborted === true) {\n            throw new AbortError();\n        }\n        const channelOptions = {\n            initiator: true,\n            trickle: false,\n            ...this.initiatorOptions\n        };\n        // Use custom WebRTC implementation\n        if (this.wrtc != null) {\n            channelOptions.wrtc = this.wrtc;\n        }\n        return await new Promise((resolve, reject) => {\n            let connected;\n            const cOpts = ma.toOptions();\n            log('Dialing %s:%s', cOpts.host, cOpts.port);\n            const channel = new WebRTCInitiator(channelOptions);\n            const onError = (evt) => {\n                const err = evt.detail;\n                if (!connected) {\n                    const msg = `connection error ${cOpts.host}:${cOpts.port}: ${err.message}`;\n                    log.error(msg);\n                    err.message = msg;\n                    done(err);\n                }\n            };\n            const onReady = () => {\n                connected = true;\n                log('connection opened %s:%s', cOpts.host, cOpts.port);\n                done();\n            };\n            const onAbort = () => {\n                log.error('connection aborted %s:%s', cOpts.host, cOpts.port);\n                void channel.close().finally(() => {\n                    done(new AbortError());\n                });\n            };\n            const done = (err) => {\n                channel.removeEventListener('error', onError);\n                channel.removeEventListener('ready', onReady);\n                options.signal?.removeEventListener('abort', onAbort);\n                if (err != null) {\n                    reject(err);\n                }\n                else {\n                    resolve(channel);\n                }\n            };\n            channel.addEventListener('error', onError, {\n                once: true\n            });\n            channel.addEventListener('ready', onReady, {\n                once: true\n            });\n            channel.addEventListener('close', () => {\n                channel.removeEventListener('error', onError);\n            });\n            options.signal?.addEventListener('abort', onAbort);\n            const onSignal = async (signal) => {\n                if (signal.type !== 'offer') {\n                    // skip candidates, just send the offer as it includes the candidates\n                    return;\n                }\n                const signalStr = JSON.stringify(signal);\n                let host = cOpts.host;\n                if (cOpts.family === 6 && !host.startsWith('[')) {\n                    host = `[${host}]`;\n                }\n                const url = `http://${host}:${cOpts.port}`;\n                const path = `/?signal=${base58btc.encode(fromString(signalStr))}`;\n                const uri = url + path;\n                try {\n                    const res = await fetch(uri);\n                    const body = await res.text();\n                    if (body.trim() === '') {\n                        // no response to this signal\n                        return;\n                    }\n                    const incSignalBuf = base58btc.decode(body);\n                    const incSignalStr = toString(incSignalBuf);\n                    const incSignal = JSON.parse(incSignalStr);\n                    channel.handleSignal(incSignal);\n                }\n                catch (err) {\n                    await channel.close(err);\n                    reject(err);\n                }\n            };\n            channel.addEventListener('signal', (evt) => {\n                const signal = evt.detail;\n                void onSignal(signal).catch(async (err) => {\n                    await channel.close(err);\n                });\n            });\n        });\n    }\n    /**\n     * Creates a WebrtcDirect listener. The provided `handler` function will be called\n     * anytime a new incoming Connection has been successfully upgraded via\n     * `upgrader.upgradeInbound`.\n     */\n    createListener(options) {\n        return createListener({\n            ...options,\n            receiverOptions: this.recieverOptions,\n            wrtc: this.wrtc\n        });\n    }\n    /**\n     * Takes a list of `Multiaddr`s and returns only valid addresses\n     */\n    filter(multiaddrs) {\n        multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n        return multiaddrs.filter((ma) => {\n            if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n                return false;\n            }\n            return mafmt.WebRTCDirect.matches(ma.decapsulateCode(CODE_P2P));\n        });\n    }\n}\nexport function webRTCDirect(init = {}) {\n    return () => new WebRTCDirect(init);\n}\n//# sourceMappingURL=index.js.map","export const ADRESSES_WEBRTC_STAR = [\"/dns4/arcane-springs-02799.herokuapp.com/tcp/443/wss/p2p-webrtc-star/\"];\n//# sourceMappingURL=const.js.map"],"names":["base","ALPHABET","name","BASE_MAP","j","i","x","xc","BASE","LEADER","FACTOR","iFACTOR","encode","source","zeroes","length","pbegin","pend","size","b58","carry","it1","it2","str","decodeUnsafe","psz","b256","it3","it4","vch","decode","string","buffer","src","_brrp__multiformats_scope_baseX","coerce","o","Encoder","prefix","baseEncode","bytes","Decoder","baseDecode","text","decoder","or","ComposedDecoder","decoders","input","left","right","Codec","from","baseX","alphabet","basex","base58btc","CODE_P2P","CODE_CIRCUIT","CLOSE_TIMEOUT","log","logger","toMultiaddrConnection","socket","options","sink","maConn","abortableSource","err","start","timeout","host","port","createListener","WebRTCDirect","init","symbol","ma","conn","AbortError","channelOptions","resolve","reject","connected","cOpts","channel","WebRTCInitiator","onError","evt","msg","done","onReady","onAbort","onSignal","signal","signalStr","url","path","fromString","uri","body","fetch","incSignalBuf","incSignalStr","toString","incSignal","multiaddrs","mafmt.WebRTCDirect","webRTCDirect","ADRESSES_WEBRTC_STAR"],"mappings":"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"}