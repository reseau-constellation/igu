{"version":3,"file":"index-RLK5aQjv.js","sources":["../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/node_modules/@libp2p/interface/dist/src/pubsub/index.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/node_modules/@libp2p/interface/dist/src/transport/index.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bytes.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/vendor/base-x.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base58.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base32.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base10.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base16.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base2.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base256emoji.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base36.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base64.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base8.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/identity.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/codecs/json.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/basics.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/dist/src/convert.js","../../../../node_modules/@libp2p/webtransport/node_modules/@multiformats/multiaddr/dist/src/multiaddr.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/vendor/base-x.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/src/bytes.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/identity.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base2.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base8.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base10.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base16.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base32.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base36.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base58.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base64.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/src/bases/base256emoji.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/vendor/varint.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/src/varint.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/src/hashes/digest.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/src/codecs/json.js","../../../../node_modules/@libp2p/webtransport/node_modules/multiformats/src/basics.js","../../../../node_modules/@libp2p/webtransport/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/util/as-uint8array.js","../../../../node_modules/@libp2p/webtransport/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/alloc.js","../../../../node_modules/@libp2p/webtransport/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/concat.js","../../../../node_modules/@libp2p/webtransport/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/equals.js","../../../../node_modules/@libp2p/webtransport/node_modules/uint8arraylist/dist/src/index.js","../../../../node_modules/@libp2p/webtransport/dist/src/index.js"],"sourcesContent":["/**\n * On the producing side:\n * * Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n *\n * On the consuming side:\n * * Enforce the fields to be present, reject otherwise.\n * * Propagate only if the fields are valid and signature can be verified, reject otherwise.\n */\nexport const StrictSign = 'StrictSign';\n/**\n * On the producing side:\n * * Build messages without the signature, key, from and seqno fields.\n * * The corresponding protobuf key-value pairs are absent from the marshalled message, not just empty.\n *\n * On the consuming side:\n * * Enforce the fields to be absent, reject otherwise.\n * * Propagate only if the fields are absent, reject otherwise.\n * * A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n */\nexport const StrictNoSign = 'StrictNoSign';\nexport var TopicValidatorResult;\n(function (TopicValidatorResult) {\n    /**\n     * The message is considered valid, and it should be delivered and forwarded to the network\n     */\n    TopicValidatorResult[\"Accept\"] = \"accept\";\n    /**\n     * The message is neither delivered nor forwarded to the network\n     */\n    TopicValidatorResult[\"Ignore\"] = \"ignore\";\n    /**\n     * The message is considered invalid, and it should be rejected\n     */\n    TopicValidatorResult[\"Reject\"] = \"reject\";\n})(TopicValidatorResult || (TopicValidatorResult = {}));\n//# sourceMappingURL=index.js.map","export const transportSymbol = Symbol.for('@libp2p/transport');\nexport function isTransport(other) {\n    return other != null && Boolean(other[transportSymbol]);\n}\n/**\n * Enum Transport Manager Fault Tolerance values\n */\nexport var FaultTolerance;\n(function (FaultTolerance) {\n    /**\n     * should be used for failing in any listen circumstance\n     */\n    FaultTolerance[FaultTolerance[\"FATAL_ALL\"] = 0] = \"FATAL_ALL\";\n    /**\n     * should be used for not failing when not listening\n     */\n    FaultTolerance[FaultTolerance[\"NO_FATAL\"] = 1] = \"NO_FATAL\";\n})(FaultTolerance || (FaultTolerance = {}));\n//# sourceMappingURL=index.js.map","export const empty = new Uint8Array(0);\nexport function toHex(d) {\n    return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\n}\nexport function fromHex(hex) {\n    const hexes = hex.match(/../g);\n    return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n}\nexport function equals(aa, bb) {\n    if (aa === bb)\n        return true;\n    if (aa.byteLength !== bb.byteLength) {\n        return false;\n    }\n    for (let ii = 0; ii < aa.byteLength; ii++) {\n        if (aa[ii] !== bb[ii]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function coerce(o) {\n    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n        return o;\n    if (o instanceof ArrayBuffer)\n        return new Uint8Array(o);\n    if (ArrayBuffer.isView(o)) {\n        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n    }\n    throw new Error('Unknown type, must be binary type');\n}\nexport function isBinary(o) {\n    return o instanceof ArrayBuffer || ArrayBuffer.isView(o);\n}\nexport function fromString(str) {\n    return new TextEncoder().encode(str);\n}\nexport function toString(b) {\n    return new TextDecoder().decode(b);\n}\n//# sourceMappingURL=bytes.js.map","/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base(ALPHABET, name) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError('Alphabet too long');\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for (var j = 0; j < BASE_MAP.length; j++) {\n        BASE_MAP[j] = 255;\n    }\n    for (var i = 0; i < ALPHABET.length; i++) {\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + ' is ambiguous');\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n    /**\n     * @param {any[] | Iterable<number>} source\n     */\n    function encode(source) {\n        // @ts-ignore\n        if (source instanceof Uint8Array)\n            ;\n        else if (ArrayBuffer.isView(source)) {\n            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n        }\n        else if (Array.isArray(source)) {\n            source = Uint8Array.from(source);\n        }\n        if (!(source instanceof Uint8Array)) {\n            throw new TypeError('Expected Uint8Array');\n        }\n        if (source.length === 0) {\n            return '';\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while (pbegin !== pend && source[pbegin] === 0) {\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while (pbegin !== pend) {\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n                carry += (256 * b58[it1]) >>> 0;\n                b58[it1] = (carry % BASE) >>> 0;\n                carry = (carry / BASE) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while (it2 !== size && b58[it2] === 0) {\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for (; it2 < size; ++it2) {\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    /**\n     * @param {string | string[]} source\n     */\n    function decodeUnsafe(source) {\n        if (typeof source !== 'string') {\n            throw new TypeError('Expected String');\n        }\n        if (source.length === 0) {\n            return new Uint8Array();\n        }\n        var psz = 0;\n        // Skip leading spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while (source[psz] === LEADER) {\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while (source[psz]) {\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n                carry += (BASE * b256[it3]) >>> 0;\n                b256[it3] = (carry % 256) >>> 0;\n                carry = (carry / 256) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            psz++;\n        }\n        // Skip trailing spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while (it4 !== size && b256[it4] === 0) {\n            it4++;\n        }\n        var vch = new Uint8Array(zeroes + (size - it4));\n        var j = zeroes;\n        while (it4 !== size) {\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    /**\n     * @param {string | string[]} string\n     */\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(`Non-${name} character`);\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nexport default _brrp__multiformats_scope_baseX;\n//# sourceMappingURL=base-x.js.map","import { coerce } from '../bytes.js';\nimport basex from '../vendor/base-x.js';\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder {\n    name;\n    prefix;\n    baseEncode;\n    constructor(name, prefix, baseEncode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n    }\n    encode(bytes) {\n        if (bytes instanceof Uint8Array) {\n            return `${this.prefix}${this.baseEncode(bytes)}`;\n        }\n        else {\n            throw Error('Unknown type, must be binary type');\n        }\n    }\n}\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder {\n    name;\n    prefix;\n    baseDecode;\n    prefixCodePoint;\n    constructor(name, prefix, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        /* c8 ignore next 3 */\n        if (prefix.codePointAt(0) === undefined) {\n            throw new Error('Invalid prefix character');\n        }\n        this.prefixCodePoint = prefix.codePointAt(0);\n        this.baseDecode = baseDecode;\n    }\n    decode(text) {\n        if (typeof text === 'string') {\n            if (text.codePointAt(0) !== this.prefixCodePoint) {\n                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n            }\n            return this.baseDecode(text.slice(this.prefix.length));\n        }\n        else {\n            throw Error('Can only multibase decode strings');\n        }\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n}\nclass ComposedDecoder {\n    decoders;\n    constructor(decoders) {\n        this.decoders = decoders;\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n    decode(input) {\n        const prefix = input[0];\n        const decoder = this.decoders[prefix];\n        if (decoder != null) {\n            return decoder.decode(input);\n        }\n        else {\n            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n        }\n    }\n}\nexport function or(left, right) {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    return new ComposedDecoder({\n        ...(left.decoders ?? { [left.prefix]: left }),\n        ...(right.decoders ?? { [right.prefix]: right })\n    });\n}\nexport class Codec {\n    name;\n    prefix;\n    baseEncode;\n    baseDecode;\n    encoder;\n    decoder;\n    constructor(name, prefix, baseEncode, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n        this.baseDecode = baseDecode;\n        this.encoder = new Encoder(name, prefix, baseEncode);\n        this.decoder = new Decoder(name, prefix, baseDecode);\n    }\n    encode(input) {\n        return this.encoder.encode(input);\n    }\n    decode(input) {\n        return this.decoder.decode(input);\n    }\n}\nexport function from({ name, prefix, encode, decode }) {\n    return new Codec(name, prefix, encode, decode);\n}\nexport function baseX({ name, prefix, alphabet }) {\n    const { encode, decode } = basex(alphabet, name);\n    return from({\n        prefix,\n        name,\n        encode,\n        decode: (text) => coerce(decode(text))\n    });\n}\nfunction decode(string, alphabet, bitsPerChar, name) {\n    // Build the character lookup table:\n    const codes = {};\n    for (let i = 0; i < alphabet.length; ++i) {\n        codes[alphabet[i]] = i;\n    }\n    // Count the padding bytes:\n    let end = string.length;\n    while (string[end - 1] === '=') {\n        --end;\n    }\n    // Allocate the output:\n    const out = new Uint8Array((end * bitsPerChar / 8) | 0);\n    // Parse the data:\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    let written = 0; // Next byte to write\n    for (let i = 0; i < end; ++i) {\n        // Read one character from the string:\n        const value = codes[string[i]];\n        if (value === undefined) {\n            throw new SyntaxError(`Non-${name} character`);\n        }\n        // Append the bits to the buffer:\n        buffer = (buffer << bitsPerChar) | value;\n        bits += bitsPerChar;\n        // Write out some bits if the buffer has a byte's worth:\n        if (bits >= 8) {\n            bits -= 8;\n            out[written++] = 0xff & (buffer >> bits);\n        }\n    }\n    // Verify that we have received just enough bits:\n    if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n        throw new SyntaxError('Unexpected end of data');\n    }\n    return out;\n}\nfunction encode(data, alphabet, bitsPerChar) {\n    const pad = alphabet[alphabet.length - 1] === '=';\n    const mask = (1 << bitsPerChar) - 1;\n    let out = '';\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    for (let i = 0; i < data.length; ++i) {\n        // Slurp data into the buffer:\n        buffer = (buffer << 8) | data[i];\n        bits += 8;\n        // Write out as much as we can:\n        while (bits > bitsPerChar) {\n            bits -= bitsPerChar;\n            out += alphabet[mask & (buffer >> bits)];\n        }\n    }\n    // Partial character:\n    if (bits !== 0) {\n        out += alphabet[mask & (buffer << (bitsPerChar - bits))];\n    }\n    // Add padding characters until we hit a byte boundary:\n    if (pad) {\n        while (((out.length * bitsPerChar) & 7) !== 0) {\n            out += '=';\n        }\n    }\n    return out;\n}\n/**\n * RFC4648 Factory\n */\nexport function rfc4648({ name, prefix, bitsPerChar, alphabet }) {\n    return from({\n        prefix,\n        name,\n        encode(input) {\n            return encode(input, alphabet, bitsPerChar);\n        },\n        decode(input) {\n            return decode(input, alphabet, bitsPerChar, name);\n        }\n    });\n}\n//# sourceMappingURL=base.js.map","import { baseX } from './base.js';\nexport const base58btc = baseX({\n    name: 'base58btc',\n    prefix: 'z',\n    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nexport const base58flickr = baseX({\n    name: 'base58flickr',\n    prefix: 'Z',\n    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});\n//# sourceMappingURL=base58.js.map","import { rfc4648 } from './base.js';\nexport const base32 = rfc4648({\n    prefix: 'b',\n    name: 'base32',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n    bitsPerChar: 5\n});\nexport const base32upper = rfc4648({\n    prefix: 'B',\n    name: 'base32upper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n    bitsPerChar: 5\n});\nexport const base32pad = rfc4648({\n    prefix: 'c',\n    name: 'base32pad',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n    bitsPerChar: 5\n});\nexport const base32padupper = rfc4648({\n    prefix: 'C',\n    name: 'base32padupper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n    bitsPerChar: 5\n});\nexport const base32hex = rfc4648({\n    prefix: 'v',\n    name: 'base32hex',\n    alphabet: '0123456789abcdefghijklmnopqrstuv',\n    bitsPerChar: 5\n});\nexport const base32hexupper = rfc4648({\n    prefix: 'V',\n    name: 'base32hexupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n    bitsPerChar: 5\n});\nexport const base32hexpad = rfc4648({\n    prefix: 't',\n    name: 'base32hexpad',\n    alphabet: '0123456789abcdefghijklmnopqrstuv=',\n    bitsPerChar: 5\n});\nexport const base32hexpadupper = rfc4648({\n    prefix: 'T',\n    name: 'base32hexpadupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n    bitsPerChar: 5\n});\nexport const base32z = rfc4648({\n    prefix: 'h',\n    name: 'base32z',\n    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n    bitsPerChar: 5\n});\n//# sourceMappingURL=base32.js.map","import { baseX } from './base.js';\nexport const base10 = baseX({\n    prefix: '9',\n    name: 'base10',\n    alphabet: '0123456789'\n});\n//# sourceMappingURL=base10.js.map","import { rfc4648 } from './base.js';\nexport const base16 = rfc4648({\n    prefix: 'f',\n    name: 'base16',\n    alphabet: '0123456789abcdef',\n    bitsPerChar: 4\n});\nexport const base16upper = rfc4648({\n    prefix: 'F',\n    name: 'base16upper',\n    alphabet: '0123456789ABCDEF',\n    bitsPerChar: 4\n});\n//# sourceMappingURL=base16.js.map","import { rfc4648 } from './base.js';\nexport const base2 = rfc4648({\n    prefix: '0',\n    name: 'base2',\n    alphabet: '01',\n    bitsPerChar: 1\n});\n//# sourceMappingURL=base2.js.map","import { from } from './base.js';\nconst alphabet = Array.from('🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂');\nconst alphabetBytesToChars = (alphabet.reduce((p, c, i) => { p[i] = c; return p; }, ([])));\nconst alphabetCharsToBytes = (alphabet.reduce((p, c, i) => { p[c.codePointAt(0)] = i; return p; }, ([])));\nfunction encode(data) {\n    return data.reduce((p, c) => {\n        p += alphabetBytesToChars[c];\n        return p;\n    }, '');\n}\nfunction decode(str) {\n    const byts = [];\n    for (const char of str) {\n        const byt = alphabetCharsToBytes[char.codePointAt(0)];\n        if (byt === undefined) {\n            throw new Error(`Non-base256emoji character: ${char}`);\n        }\n        byts.push(byt);\n    }\n    return new Uint8Array(byts);\n}\nexport const base256emoji = from({\n    prefix: '🚀',\n    name: 'base256emoji',\n    encode,\n    decode\n});\n//# sourceMappingURL=base256emoji.js.map","import { baseX } from './base.js';\nexport const base36 = baseX({\n    prefix: 'k',\n    name: 'base36',\n    alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n});\nexport const base36upper = baseX({\n    prefix: 'K',\n    name: 'base36upper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n});\n//# sourceMappingURL=base36.js.map","import { rfc4648 } from './base.js';\nexport const base64 = rfc4648({\n    prefix: 'm',\n    name: 'base64',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n    bitsPerChar: 6\n});\nexport const base64pad = rfc4648({\n    prefix: 'M',\n    name: 'base64pad',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n    bitsPerChar: 6\n});\nexport const base64url = rfc4648({\n    prefix: 'u',\n    name: 'base64url',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n    bitsPerChar: 6\n});\nexport const base64urlpad = rfc4648({\n    prefix: 'U',\n    name: 'base64urlpad',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n    bitsPerChar: 6\n});\n//# sourceMappingURL=base64.js.map","import { rfc4648 } from './base.js';\nexport const base8 = rfc4648({\n    prefix: '7',\n    name: 'base8',\n    alphabet: '01234567',\n    bitsPerChar: 3\n});\n//# sourceMappingURL=base8.js.map","import { fromString, toString } from '../bytes.js';\nimport { from } from './base.js';\nexport const identity = from({\n    prefix: '\\x00',\n    name: 'identity',\n    encode: (buf) => toString(buf),\n    decode: (str) => fromString(str)\n});\n//# sourceMappingURL=identity.js.map","const textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nexport const name = 'json';\nexport const code = 0x0200;\nexport function encode(node) {\n    return textEncoder.encode(JSON.stringify(node));\n}\nexport function decode(data) {\n    return JSON.parse(textDecoder.decode(data));\n}\n//# sourceMappingURL=json.js.map","import * as base10 from './bases/base10.js';\nimport * as base16 from './bases/base16.js';\nimport * as base2 from './bases/base2.js';\nimport * as base256emoji from './bases/base256emoji.js';\nimport * as base32 from './bases/base32.js';\nimport * as base36 from './bases/base36.js';\nimport * as base58 from './bases/base58.js';\nimport * as base64 from './bases/base64.js';\nimport * as base8 from './bases/base8.js';\nimport * as identityBase from './bases/identity.js';\nimport * as json from './codecs/json.js';\nimport * as raw from './codecs/raw.js';\nimport * as identity from './hashes/identity.js';\nimport * as sha2 from './hashes/sha2.js';\nimport { CID, hasher, digest, varint, bytes } from './index.js';\nexport const bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji };\nexport const hashes = { ...sha2, ...identity };\nexport const codecs = { raw, json };\nexport { CID, hasher, digest, varint, bytes };\n//# sourceMappingURL=basics.js.map","const V = -1;\nexport const names = {};\nexport const codes = {};\nexport const table = [\n    [4, 32, 'ip4'],\n    [6, 16, 'tcp'],\n    [33, 16, 'dccp'],\n    [41, 128, 'ip6'],\n    [42, V, 'ip6zone'],\n    [43, 8, 'ipcidr'],\n    [53, V, 'dns', true],\n    [54, V, 'dns4', true],\n    [55, V, 'dns6', true],\n    [56, V, 'dnsaddr', true],\n    [132, 16, 'sctp'],\n    [273, 16, 'udp'],\n    [275, 0, 'p2p-webrtc-star'],\n    [276, 0, 'p2p-webrtc-direct'],\n    [277, 0, 'p2p-stardust'],\n    [280, 0, 'webrtc-direct'],\n    [281, 0, 'webrtc'],\n    [290, 0, 'p2p-circuit'],\n    [301, 0, 'udt'],\n    [302, 0, 'utp'],\n    [400, V, 'unix', false, true],\n    // `ipfs` is added before `p2p` for legacy support.\n    // All text representations will default to `p2p`, but `ipfs` will\n    // still be supported\n    [421, V, 'ipfs'],\n    // `p2p` is the preferred name for 421, and is now the default\n    [421, V, 'p2p'],\n    [443, 0, 'https'],\n    [444, 96, 'onion'],\n    [445, 296, 'onion3'],\n    [446, V, 'garlic64'],\n    [448, 0, 'tls'],\n    [449, V, 'sni'],\n    [460, 0, 'quic'],\n    [461, 0, 'quic-v1'],\n    [465, 0, 'webtransport'],\n    [466, V, 'certhash'],\n    [477, 0, 'ws'],\n    [478, 0, 'wss'],\n    [479, 0, 'p2p-websocket-star'],\n    [480, 0, 'http'],\n    [777, V, 'memory']\n];\n// populate tables\ntable.forEach(row => {\n    const proto = createProtocol(...row);\n    codes[proto.code] = proto;\n    names[proto.name] = proto;\n});\nexport function createProtocol(code, size, name, resolvable, path) {\n    return {\n        code,\n        size,\n        name,\n        resolvable: Boolean(resolvable),\n        path: Boolean(path)\n    };\n}\n/**\n * For the passed proto string or number, return a {@link Protocol}\n *\n * @example\n *\n * ```js\n * import { protocol } from '@multiformats/multiaddr'\n *\n * console.info(protocol(4))\n * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }\n * ```\n */\nexport function getProtocol(proto) {\n    if (typeof proto === 'number') {\n        if (codes[proto] != null) {\n            return codes[proto];\n        }\n        throw new Error(`no protocol with code: ${proto}`);\n    }\n    else if (typeof proto === 'string') {\n        if (names[proto] != null) {\n            return names[proto];\n        }\n        throw new Error(`no protocol with name: ${proto}`);\n    }\n    throw new Error(`invalid protocol id type: ${typeof proto}`);\n}\n//# sourceMappingURL=protocols-table.js.map","/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\nimport { IpNet } from '@chainsafe/netmask';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport * as varint from 'uint8-varint';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport * as ip from './ip.js';\nimport { getProtocol } from './protocols-table.js';\nconst ip4Protocol = getProtocol('ip4');\nconst ip6Protocol = getProtocol('ip6');\nconst ipcidrProtocol = getProtocol('ipcidr');\nexport function convert(proto, a) {\n    if (a instanceof Uint8Array) {\n        return convertToString(proto, a);\n    }\n    else {\n        return convertToBytes(proto, a);\n    }\n}\n/**\n * Convert [code,Uint8Array] to string\n */\nexport function convertToString(proto, buf) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n        case 41: // ipv6\n            return bytes2ip(buf);\n        case 42: // ipv6zone\n            return bytes2str(buf);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return bytes2port(buf).toString();\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return bytes2str(buf);\n        case 421: // ipfs\n            return bytes2mh(buf);\n        case 444: // onion\n            return bytes2onion(buf);\n        case 445: // onion3\n            return bytes2onion(buf);\n        case 466: // certhash\n            return bytes2mb(buf);\n        default:\n            return uint8ArrayToString(buf, 'base16'); // no clue. convert to hex\n    }\n}\nexport function convertToBytes(proto, str) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n            return ip2bytes(str);\n        case 41: // ipv6\n            return ip2bytes(str);\n        case 42: // ipv6zone\n            return str2bytes(str);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return port2bytes(parseInt(str, 10));\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return str2bytes(str);\n        case 421: // ipfs\n            return mh2bytes(str);\n        case 444: // onion\n            return onion2bytes(str);\n        case 445: // onion3\n            return onion32bytes(str);\n        case 466: // certhash\n            return mb2bytes(str);\n        default:\n            return uint8ArrayFromString(str, 'base16'); // no clue. convert from hex\n    }\n}\nexport function convertToIpNet(multiaddr) {\n    let mask;\n    let addr;\n    multiaddr.stringTuples().forEach(([code, value]) => {\n        if (code === ip4Protocol.code || code === ip6Protocol.code) {\n            addr = value;\n        }\n        if (code === ipcidrProtocol.code) {\n            mask = value;\n        }\n    });\n    if (mask == null || addr == null) {\n        throw new Error('Invalid multiaddr');\n    }\n    return new IpNet(addr, mask);\n}\nconst decoders = Object.values(bases).map((c) => c.decoder);\nconst anybaseDecoder = (function () {\n    let acc = decoders[0].or(decoders[1]);\n    decoders.slice(2).forEach((d) => (acc = acc.or(d)));\n    return acc;\n})();\nfunction ip2bytes(ipString) {\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ip.toBytes(ipString);\n}\nfunction bytes2ip(ipBuff) {\n    const ipString = ip.toString(ipBuff, 0, ipBuff.length);\n    if (ipString == null) {\n        throw new Error('ipBuff is required');\n    }\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ipString;\n}\nfunction port2bytes(port) {\n    const buf = new ArrayBuffer(2);\n    const view = new DataView(buf);\n    view.setUint16(0, port);\n    return new Uint8Array(buf);\n}\nfunction bytes2port(buf) {\n    const view = new DataView(buf.buffer);\n    return view.getUint16(buf.byteOffset);\n}\nfunction str2bytes(str) {\n    const buf = uint8ArrayFromString(str);\n    const size = Uint8Array.from(varint.encode(buf.length));\n    return uint8ArrayConcat([size, buf], size.length + buf.length);\n}\nfunction bytes2str(buf) {\n    const size = varint.decode(buf);\n    buf = buf.slice(varint.encodingLength(size));\n    if (buf.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(buf);\n}\nfunction mh2bytes(hash) {\n    let mh;\n    if (hash[0] === 'Q' || hash[0] === '1') {\n        mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes;\n    }\n    else {\n        mh = CID.parse(hash).multihash.bytes;\n    }\n    // the address is a varint prefixed multihash string representation\n    const size = Uint8Array.from(varint.encode(mh.length));\n    return uint8ArrayConcat([size, mh], size.length + mh.length);\n}\nfunction mb2bytes(mbstr) {\n    const mb = anybaseDecoder.decode(mbstr);\n    const size = Uint8Array.from(varint.encode(mb.length));\n    return uint8ArrayConcat([size, mb], size.length + mb.length);\n}\nfunction bytes2mb(buf) {\n    const size = varint.decode(buf);\n    const hash = buf.slice(varint.encodingLength(size));\n    if (hash.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return 'u' + uint8ArrayToString(hash, 'base64url');\n}\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh(buf) {\n    const size = varint.decode(buf);\n    const address = buf.slice(varint.encodingLength(size));\n    if (address.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(address, 'base58btc');\n}\nfunction onion2bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 16) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode('b' + addr[0]);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction onion32bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 56) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode(`b${addr[0]}`);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction bytes2onion(buf) {\n    const addrBytes = buf.slice(0, buf.length - 2);\n    const portBytes = buf.slice(buf.length - 2);\n    const addr = uint8ArrayToString(addrBytes, 'base32');\n    const port = bytes2port(portBytes);\n    return `${addr}:${port}`;\n}\n//# sourceMappingURL=convert.js.map","/**\n * @packageDocumentation\n *\n * An implementation of a Multiaddr in JavaScript\n *\n * @example\n *\n * ```js\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')\n * ```\n */\nimport { CodeError } from '@libp2p/interface';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { CID } from 'multiformats/cid';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { bytesToMultiaddrParts, stringToMultiaddrParts, tuplesToBytes } from './codec.js';\nimport { getProtocol, names } from './protocols-table.js';\nimport { isMultiaddr, resolvers } from './index.js';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nexport const symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr');\nconst DNS_CODES = [\n    getProtocol('dns').code,\n    getProtocol('dns4').code,\n    getProtocol('dns6').code,\n    getProtocol('dnsaddr').code\n];\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nexport class Multiaddr {\n    bytes;\n    #string;\n    #tuples;\n    #stringTuples;\n    #path;\n    [symbol] = true;\n    constructor(addr) {\n        // default\n        if (addr == null) {\n            addr = '';\n        }\n        let parts;\n        if (addr instanceof Uint8Array) {\n            parts = bytesToMultiaddrParts(addr);\n        }\n        else if (typeof addr === 'string') {\n            if (addr.length > 0 && addr.charAt(0) !== '/') {\n                throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`);\n            }\n            parts = stringToMultiaddrParts(addr);\n        }\n        else if (isMultiaddr(addr)) { // Multiaddr\n            parts = bytesToMultiaddrParts(addr.bytes);\n        }\n        else {\n            throw new Error('addr must be a string, Buffer, or another Multiaddr');\n        }\n        this.bytes = parts.bytes;\n        this.#string = parts.string;\n        this.#tuples = parts.tuples;\n        this.#stringTuples = parts.stringTuples;\n        this.#path = parts.path;\n    }\n    toString() {\n        return this.#string;\n    }\n    toJSON() {\n        return this.toString();\n    }\n    toOptions() {\n        let family;\n        let transport;\n        let host;\n        let port;\n        let zone = '';\n        const tcp = getProtocol('tcp');\n        const udp = getProtocol('udp');\n        const ip4 = getProtocol('ip4');\n        const ip6 = getProtocol('ip6');\n        const dns6 = getProtocol('dns6');\n        const ip6zone = getProtocol('ip6zone');\n        for (const [code, value] of this.stringTuples()) {\n            if (code === ip6zone.code) {\n                zone = `%${value ?? ''}`;\n            }\n            // default to https when protocol & port are omitted from DNS addrs\n            if (DNS_CODES.includes(code)) {\n                transport = tcp.name;\n                port = 443;\n                host = `${value ?? ''}${zone}`;\n                family = code === dns6.code ? 6 : 4;\n            }\n            if (code === tcp.code || code === udp.code) {\n                transport = getProtocol(code).name;\n                port = parseInt(value ?? '');\n            }\n            if (code === ip4.code || code === ip6.code) {\n                transport = getProtocol(code).name;\n                host = `${value ?? ''}${zone}`;\n                family = code === ip6.code ? 6 : 4;\n            }\n        }\n        if (family == null || transport == null || host == null || port == null) {\n            throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".');\n        }\n        const opts = {\n            family,\n            host,\n            transport,\n            port\n        };\n        return opts;\n    }\n    protos() {\n        return this.#tuples.map(([code]) => Object.assign({}, getProtocol(code)));\n    }\n    protoCodes() {\n        return this.#tuples.map(([code]) => code);\n    }\n    protoNames() {\n        return this.#tuples.map(([code]) => getProtocol(code).name);\n    }\n    tuples() {\n        return this.#tuples;\n    }\n    stringTuples() {\n        return this.#stringTuples;\n    }\n    encapsulate(addr) {\n        addr = new Multiaddr(addr);\n        return new Multiaddr(this.toString() + addr.toString());\n    }\n    decapsulate(addr) {\n        const addrString = addr.toString();\n        const s = this.toString();\n        const i = s.lastIndexOf(addrString);\n        if (i < 0) {\n            throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);\n        }\n        return new Multiaddr(s.slice(0, i));\n    }\n    decapsulateCode(code) {\n        const tuples = this.tuples();\n        for (let i = tuples.length - 1; i >= 0; i--) {\n            if (tuples[i][0] === code) {\n                return new Multiaddr(tuplesToBytes(tuples.slice(0, i)));\n            }\n        }\n        return this;\n    }\n    getPeerId() {\n        try {\n            let tuples = [];\n            this.stringTuples().forEach(([code, name]) => {\n                if (code === names.p2p.code) {\n                    tuples.push([code, name]);\n                }\n                // if this is a p2p-circuit address, return the target peer id if present\n                // not the peer id of the relay\n                if (code === names['p2p-circuit'].code) {\n                    tuples = [];\n                }\n            });\n            // Get the last ipfs tuple ['p2p', 'peerid string']\n            const tuple = tuples.pop();\n            if (tuple?.[1] != null) {\n                const peerIdStr = tuple[1];\n                // peer id is base58btc encoded string but not multibase encoded so add the `z`\n                // prefix so we can validate that it is correctly encoded\n                if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n                    return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc');\n                }\n                // try to parse peer id as CID\n                return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc');\n            }\n            return null;\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    getPath() {\n        return this.#path;\n    }\n    equals(addr) {\n        return uint8ArrayEquals(this.bytes, addr.bytes);\n    }\n    async resolve(options) {\n        const resolvableProto = this.protos().find((p) => p.resolvable);\n        // Multiaddr is not resolvable?\n        if (resolvableProto == null) {\n            return [this];\n        }\n        const resolver = resolvers.get(resolvableProto.name);\n        if (resolver == null) {\n            throw new CodeError(`no available resolver for ${resolvableProto.name}`, 'ERR_NO_AVAILABLE_RESOLVER');\n        }\n        const addresses = await resolver(this, options);\n        return addresses.map((a) => new Multiaddr(a));\n    }\n    nodeAddress() {\n        const options = this.toOptions();\n        if (options.transport !== 'tcp' && options.transport !== 'udp') {\n            throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`);\n        }\n        return {\n            family: options.family,\n            address: options.host,\n            port: options.port\n        };\n    }\n    isThinWaistAddress(addr) {\n        const protos = (addr ?? this).protos();\n        if (protos.length !== 2) {\n            return false;\n        }\n        if (protos[0].code !== 4 && protos[0].code !== 41) {\n            return false;\n        }\n        if (protos[1].code !== 6 && protos[1].code !== 273) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns Multiaddr as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { multiaddr } from '@multiformats/multiaddr'\n     *\n     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n     * ```\n     */\n    [inspect]() {\n        return `Multiaddr(${this.#string})`;\n    }\n}\n//# sourceMappingURL=multiaddr.js.map","// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n","// @ts-check\n\nimport { from } from './base.js'\nimport { fromString, toString } from '../bytes.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n","// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n","// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n","import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n","// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n","import { from } from './base.js'\n\nconst alphabet = Array.from('🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂')\nconst alphabetBytesToChars = /** @type {string[]} */ (alphabet.reduce((p, c, i) => { p[i] = c; return p }, /** @type {string[]} */([])))\nconst alphabetCharsToBytes = /** @type {number[]} */ (alphabet.reduce((p, c, i) => { p[/** @type {number} */ (c.codePointAt(0))] = i; return p }, /** @type {number[]} */([])))\n\n/**\n * @param {Uint8Array} data\n * @returns {string}\n */\nfunction encode (data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nfunction decode (str) {\n  const byts = []\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[/** @type {number} */ (char.codePointAt(0))]\n    if (byt === undefined) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: '🚀',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n","var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n","// @ts-check\n\n/**\n * @template T\n * @typedef {import('./interface.js').ByteView<T>} ByteView\n */\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => textEncoder.encode(JSON.stringify(node))\n\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => JSON.parse(textDecoder.decode(data))\n","// @ts-check\n\nimport * as identityBase from './bases/identity.js'\nimport * as base2 from './bases/base2.js'\nimport * as base8 from './bases/base8.js'\nimport * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as sha2 from './hashes/sha2.js'\nimport * as identity from './hashes/identity.js'\n\nimport * as raw from './codecs/raw.js'\nimport * as json from './codecs/json.js'\n\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nconst bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nconst hashes = { ...sha2, ...identity }\nconst codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes, hashes, bases, codecs }\n","/**\n * To guarantee Uint8Array semantics, convert nodejs Buffers\n * into vanilla Uint8Arrays\n */\nexport function asUint8Array(buf) {\n    if (globalThis.Buffer != null) {\n        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n    return buf;\n}\n//# sourceMappingURL=as-uint8array.js.map","import { asUint8Array } from './util/as-uint8array.js';\n/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc(size = 0) {\n    if (globalThis.Buffer?.alloc != null) {\n        return asUint8Array(globalThis.Buffer.alloc(size));\n    }\n    return new Uint8Array(size);\n}\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe(size = 0) {\n    if (globalThis.Buffer?.allocUnsafe != null) {\n        return asUint8Array(globalThis.Buffer.allocUnsafe(size));\n    }\n    return new Uint8Array(size);\n}\n//# sourceMappingURL=alloc.js.map","import { allocUnsafe } from './alloc.js';\nimport { asUint8Array } from './util/as-uint8array.js';\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat(arrays, length) {\n    if (globalThis.Buffer != null) {\n        return asUint8Array(globalThis.Buffer.concat(arrays, length));\n    }\n    if (length == null) {\n        length = arrays.reduce((acc, curr) => acc + curr.length, 0);\n    }\n    const output = allocUnsafe(length);\n    let offset = 0;\n    for (const arr of arrays) {\n        output.set(arr, offset);\n        offset += arr.length;\n    }\n    return asUint8Array(output);\n}\n//# sourceMappingURL=concat.js.map","/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a.byteLength !== b.byteLength) {\n        return false;\n    }\n    for (let i = 0; i < a.byteLength; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=equals.js.map","/**\n * @packageDocumentation\n *\n * A class that lets you do operations over a list of Uint8Arrays without\n * copying them.\n *\n * ```js\n * import { Uint8ArrayList } from 'uint8arraylist'\n *\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray()\n * // -> Uint8Array([0, 1, 2, 3, 4, 5])\n *\n * list.consume(3)\n * list.subarray()\n * // -> Uint8Array([3, 4, 5])\n *\n * // you can also iterate over the list\n * for (const buf of list) {\n *   // ..do something with `buf`\n * }\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ## Converting Uint8ArrayLists to Uint8Arrays\n *\n * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.\n *\n * ### slice\n *\n * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.slice(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ### subarray\n *\n * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0]) - no-copy\n *\n * list.subarray(2, 5)\n * // -> Uint8Array([2, 3, 4]) - copy\n * ```\n *\n * ### sublist\n *\n * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.sublist(0, 1)\n * // -> Uint8ArrayList([0]) - no-copy\n *\n * list.sublist(2, 5)\n * // -> Uint8ArrayList([2], [3, 4]) - no-copy\n * ```\n *\n * ## Inspiration\n *\n * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.\n */\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc';\nimport { concat } from 'uint8arrays/concat';\nimport { equals } from 'uint8arrays/equals';\nconst symbol = Symbol.for('@achingbrain/uint8arraylist');\nfunction findBufAndOffset(bufs, index) {\n    if (index == null || index < 0) {\n        throw new RangeError('index is out of bounds');\n    }\n    let offset = 0;\n    for (const buf of bufs) {\n        const bufEnd = offset + buf.byteLength;\n        if (index < bufEnd) {\n            return {\n                buf,\n                index: index - offset\n            };\n        }\n        offset = bufEnd;\n    }\n    throw new RangeError('index is out of bounds');\n}\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList(value) {\n    return Boolean(value?.[symbol]);\n}\nexport class Uint8ArrayList {\n    bufs;\n    length;\n    [symbol] = true;\n    constructor(...data) {\n        this.bufs = [];\n        this.length = 0;\n        if (data.length > 0) {\n            this.appendAll(data);\n        }\n    }\n    *[Symbol.iterator]() {\n        yield* this.bufs;\n    }\n    get byteLength() {\n        return this.length;\n    }\n    /**\n     * Add one or more `bufs` to the end of this Uint8ArrayList\n     */\n    append(...bufs) {\n        this.appendAll(bufs);\n    }\n    /**\n     * Add all `bufs` to the end of this Uint8ArrayList\n     */\n    appendAll(bufs) {\n        let length = 0;\n        for (const buf of bufs) {\n            if (buf instanceof Uint8Array) {\n                length += buf.byteLength;\n                this.bufs.push(buf);\n            }\n            else if (isUint8ArrayList(buf)) {\n                length += buf.byteLength;\n                this.bufs.push(...buf.bufs);\n            }\n            else {\n                throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList');\n            }\n        }\n        this.length += length;\n    }\n    /**\n     * Add one or more `bufs` to the start of this Uint8ArrayList\n     */\n    prepend(...bufs) {\n        this.prependAll(bufs);\n    }\n    /**\n     * Add all `bufs` to the start of this Uint8ArrayList\n     */\n    prependAll(bufs) {\n        let length = 0;\n        for (const buf of bufs.reverse()) {\n            if (buf instanceof Uint8Array) {\n                length += buf.byteLength;\n                this.bufs.unshift(buf);\n            }\n            else if (isUint8ArrayList(buf)) {\n                length += buf.byteLength;\n                this.bufs.unshift(...buf.bufs);\n            }\n            else {\n                throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList');\n            }\n        }\n        this.length += length;\n    }\n    /**\n     * Read the value at `index`\n     */\n    get(index) {\n        const res = findBufAndOffset(this.bufs, index);\n        return res.buf[res.index];\n    }\n    /**\n     * Set the value at `index` to `value`\n     */\n    set(index, value) {\n        const res = findBufAndOffset(this.bufs, index);\n        res.buf[res.index] = value;\n    }\n    /**\n     * Copy bytes from `buf` to the index specified by `offset`\n     */\n    write(buf, offset = 0) {\n        if (buf instanceof Uint8Array) {\n            for (let i = 0; i < buf.length; i++) {\n                this.set(offset + i, buf[i]);\n            }\n        }\n        else if (isUint8ArrayList(buf)) {\n            for (let i = 0; i < buf.length; i++) {\n                this.set(offset + i, buf.get(i));\n            }\n        }\n        else {\n            throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList');\n        }\n    }\n    /**\n     * Remove bytes from the front of the pool\n     */\n    consume(bytes) {\n        // first, normalize the argument, in accordance with how Buffer does it\n        bytes = Math.trunc(bytes);\n        // do nothing if not a positive number\n        if (Number.isNaN(bytes) || bytes <= 0) {\n            return;\n        }\n        // if consuming all bytes, skip iterating\n        if (bytes === this.byteLength) {\n            this.bufs = [];\n            this.length = 0;\n            return;\n        }\n        while (this.bufs.length > 0) {\n            if (bytes >= this.bufs[0].byteLength) {\n                bytes -= this.bufs[0].byteLength;\n                this.length -= this.bufs[0].byteLength;\n                this.bufs.shift();\n            }\n            else {\n                this.bufs[0] = this.bufs[0].subarray(bytes);\n                this.length -= bytes;\n                break;\n            }\n        }\n    }\n    /**\n     * Extracts a section of an array and returns a new array.\n     *\n     * This is a copy operation as it is with Uint8Arrays and Arrays\n     * - note this is different to the behaviour of Node Buffers.\n     */\n    slice(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        return concat(bufs, length);\n    }\n    /**\n     * Returns a alloc from the given start and end element index.\n     *\n     * In the best case where the data extracted comes from a single Uint8Array\n     * internally this is a no-copy operation otherwise it is a copy operation.\n     */\n    subarray(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        if (bufs.length === 1) {\n            return bufs[0];\n        }\n        return concat(bufs, length);\n    }\n    /**\n     * Returns a allocList from the given start and end element index.\n     *\n     * This is a no-copy operation.\n     */\n    sublist(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        const list = new Uint8ArrayList();\n        list.length = length;\n        // don't loop, just set the bufs\n        list.bufs = [...bufs];\n        return list;\n    }\n    _subList(beginInclusive, endExclusive) {\n        beginInclusive = beginInclusive ?? 0;\n        endExclusive = endExclusive ?? this.length;\n        if (beginInclusive < 0) {\n            beginInclusive = this.length + beginInclusive;\n        }\n        if (endExclusive < 0) {\n            endExclusive = this.length + endExclusive;\n        }\n        if (beginInclusive < 0 || endExclusive > this.length) {\n            throw new RangeError('index is out of bounds');\n        }\n        if (beginInclusive === endExclusive) {\n            return { bufs: [], length: 0 };\n        }\n        if (beginInclusive === 0 && endExclusive === this.length) {\n            return { bufs: this.bufs, length: this.length };\n        }\n        const bufs = [];\n        let offset = 0;\n        for (let i = 0; i < this.bufs.length; i++) {\n            const buf = this.bufs[i];\n            const bufStart = offset;\n            const bufEnd = bufStart + buf.byteLength;\n            // for next loop\n            offset = bufEnd;\n            if (beginInclusive >= bufEnd) {\n                // start after this buf\n                continue;\n            }\n            const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;\n            const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;\n            if (sliceStartInBuf && sliceEndsInBuf) {\n                // slice is wholly contained within this buffer\n                if (beginInclusive === bufStart && endExclusive === bufEnd) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    break;\n                }\n                // requested part of buffer\n                const start = beginInclusive - bufStart;\n                bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)));\n                break;\n            }\n            if (sliceStartInBuf) {\n                // slice starts in this buffer\n                if (beginInclusive === 0) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    continue;\n                }\n                // requested part of buffer\n                bufs.push(buf.subarray(beginInclusive - bufStart));\n                continue;\n            }\n            if (sliceEndsInBuf) {\n                if (endExclusive === bufEnd) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    break;\n                }\n                // requested part of buffer\n                bufs.push(buf.subarray(0, endExclusive - bufStart));\n                break;\n            }\n            // slice started before this buffer and ends after it\n            bufs.push(buf);\n        }\n        return { bufs, length: endExclusive - beginInclusive };\n    }\n    indexOf(search, offset = 0) {\n        if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n            throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array');\n        }\n        const needle = search instanceof Uint8Array ? search : search.subarray();\n        offset = Number(offset ?? 0);\n        if (isNaN(offset)) {\n            offset = 0;\n        }\n        if (offset < 0) {\n            offset = this.length + offset;\n        }\n        if (offset < 0) {\n            offset = 0;\n        }\n        if (search.length === 0) {\n            return offset > this.length ? this.length : offset;\n        }\n        // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n        const M = needle.byteLength;\n        if (M === 0) {\n            throw new TypeError('search must be at least 1 byte long');\n        }\n        // radix\n        const radix = 256;\n        const rightmostPositions = new Int32Array(radix);\n        // position of the rightmost occurrence of the byte c in the pattern\n        for (let c = 0; c < radix; c++) {\n            // -1 for bytes not in pattern\n            rightmostPositions[c] = -1;\n        }\n        for (let j = 0; j < M; j++) {\n            // rightmost position for bytes in pattern\n            rightmostPositions[needle[j]] = j;\n        }\n        // Return offset of first match, -1 if no match\n        const right = rightmostPositions;\n        const lastIndex = this.byteLength - needle.byteLength;\n        const lastPatIndex = needle.byteLength - 1;\n        let skip;\n        for (let i = offset; i <= lastIndex; i += skip) {\n            skip = 0;\n            for (let j = lastPatIndex; j >= 0; j--) {\n                const char = this.get(i + j);\n                if (needle[j] !== char) {\n                    skip = Math.max(1, j - right[char]);\n                    break;\n                }\n            }\n            if (skip === 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    getInt8(byteOffset) {\n        const buf = this.subarray(byteOffset, byteOffset + 1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt8(0);\n    }\n    setInt8(byteOffset, value) {\n        const buf = allocUnsafe(1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt8(0, value);\n        this.write(buf, byteOffset);\n    }\n    getInt16(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt16(0, littleEndian);\n    }\n    setInt16(byteOffset, value, littleEndian) {\n        const buf = alloc(2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt16(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getInt32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt32(0, littleEndian);\n    }\n    setInt32(byteOffset, value, littleEndian) {\n        const buf = alloc(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getBigInt64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getBigInt64(0, littleEndian);\n    }\n    setBigInt64(byteOffset, value, littleEndian) {\n        const buf = alloc(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setBigInt64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getUint8(byteOffset) {\n        const buf = this.subarray(byteOffset, byteOffset + 1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint8(0);\n    }\n    setUint8(byteOffset, value) {\n        const buf = allocUnsafe(1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint8(0, value);\n        this.write(buf, byteOffset);\n    }\n    getUint16(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint16(0, littleEndian);\n    }\n    setUint16(byteOffset, value, littleEndian) {\n        const buf = alloc(2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint16(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getUint32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint32(0, littleEndian);\n    }\n    setUint32(byteOffset, value, littleEndian) {\n        const buf = alloc(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getBigUint64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getBigUint64(0, littleEndian);\n    }\n    setBigUint64(byteOffset, value, littleEndian) {\n        const buf = alloc(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setBigUint64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getFloat32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getFloat32(0, littleEndian);\n    }\n    setFloat32(byteOffset, value, littleEndian) {\n        const buf = alloc(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setFloat32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getFloat64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getFloat64(0, littleEndian);\n    }\n    setFloat64(byteOffset, value, littleEndian) {\n        const buf = alloc(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setFloat64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    equals(other) {\n        if (other == null) {\n            return false;\n        }\n        if (!(other instanceof Uint8ArrayList)) {\n            return false;\n        }\n        if (other.bufs.length !== this.bufs.length) {\n            return false;\n        }\n        for (let i = 0; i < this.bufs.length; i++) {\n            if (!equals(this.bufs[i], other.bufs[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n     * method if you know the total size of all the Uint8Arrays ahead of time.\n     */\n    static fromUint8Arrays(bufs, length) {\n        const list = new Uint8ArrayList();\n        list.bufs = bufs;\n        if (length == null) {\n            length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);\n        }\n        list.length = length;\n        return list;\n    }\n}\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n//# sourceMappingURL=index.js.map","import { logger } from '@libp2p/logger';\nimport { noise } from '@chainsafe/libp2p-noise';\nimport { symbol } from '@libp2p/interface-transport';\nimport { protocols } from '@multiformats/multiaddr';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { bases, digest } from 'multiformats/basics';\nimport { Uint8ArrayList } from 'uint8arraylist';\nconst log = logger('libp2p:webtransport');\n// @ts-expect-error - Not easy to combine these types.\nconst multibaseDecoder = Object.values(bases).map(b => b.decoder).reduce((d, b) => d.or(b));\nfunction decodeCerthashStr(s) {\n    return digest.decode(multibaseDecoder.decode(s));\n}\n// Duplex that does nothing. Needed to fulfill the interface\nfunction inertDuplex() {\n    return {\n        source: {\n            [Symbol.asyncIterator]() {\n                return {\n                    async next() {\n                        // This will never resolve\n                        return await new Promise(() => { });\n                    }\n                };\n            }\n        },\n        sink: async (source) => {\n            // This will never resolve\n            return await new Promise(() => { });\n        }\n    };\n}\nasync function webtransportBiDiStreamToStream(bidiStream, streamId, direction, activeStreams, onStreamEnd) {\n    const writer = bidiStream.writable.getWriter();\n    const reader = bidiStream.readable.getReader();\n    await writer.ready;\n    function cleanupStreamFromActiveStreams() {\n        const index = activeStreams.findIndex(s => s === stream);\n        if (index !== -1) {\n            activeStreams.splice(index, 1);\n            stream.stat.timeline.close = Date.now();\n            onStreamEnd?.(stream);\n        }\n    }\n    let writerClosed = false;\n    let readerClosed = false;\n    (async function () {\n        const err = await writer.closed.catch((err) => err);\n        if (err != null) {\n            const msg = err.message;\n            if (!(msg.includes('aborted by the remote server') || msg.includes('STOP_SENDING'))) {\n                log.error(`WebTransport writer closed unexpectedly: streamId=${streamId} err=${err.message}`);\n            }\n        }\n        writerClosed = true;\n        if (writerClosed && readerClosed) {\n            cleanupStreamFromActiveStreams();\n        }\n    })().catch(() => {\n        log.error('WebTransport failed to cleanup closed stream');\n    });\n    (async function () {\n        const err = await reader.closed.catch((err) => err);\n        if (err != null) {\n            log.error(`WebTransport reader closed unexpectedly: streamId=${streamId} err=${err.message}`);\n        }\n        readerClosed = true;\n        if (writerClosed && readerClosed) {\n            cleanupStreamFromActiveStreams();\n        }\n    })().catch(() => {\n        log.error('WebTransport failed to cleanup closed stream');\n    });\n    let sinkSunk = false;\n    const stream = {\n        id: streamId,\n        abort(_err) {\n            if (!writerClosed) {\n                writer.abort();\n                writerClosed = true;\n            }\n            stream.closeRead();\n            readerClosed = true;\n            cleanupStreamFromActiveStreams();\n        },\n        close() {\n            stream.closeRead();\n            stream.closeWrite();\n            cleanupStreamFromActiveStreams();\n        },\n        closeRead() {\n            if (!readerClosed) {\n                reader.cancel().catch((err) => {\n                    if (err.toString().includes('RESET_STREAM') === true) {\n                        writerClosed = true;\n                    }\n                });\n                readerClosed = true;\n            }\n            if (writerClosed) {\n                cleanupStreamFromActiveStreams();\n            }\n        },\n        closeWrite() {\n            if (!writerClosed) {\n                writerClosed = true;\n                writer.close().catch((err) => {\n                    if (err.toString().includes('RESET_STREAM') === true) {\n                        readerClosed = true;\n                    }\n                });\n            }\n            if (readerClosed) {\n                cleanupStreamFromActiveStreams();\n            }\n        },\n        reset() {\n            stream.close();\n        },\n        stat: {\n            direction,\n            timeline: { open: Date.now() }\n        },\n        metadata: {},\n        source: (async function* () {\n            while (true) {\n                const val = await reader.read();\n                if (val.done === true) {\n                    readerClosed = true;\n                    if (writerClosed) {\n                        cleanupStreamFromActiveStreams();\n                    }\n                    return;\n                }\n                yield new Uint8ArrayList(val.value);\n            }\n        })(),\n        sink: async function (source) {\n            if (sinkSunk) {\n                throw new Error('sink already called on stream');\n            }\n            sinkSunk = true;\n            try {\n                for await (const chunks of source) {\n                    if (chunks instanceof Uint8Array) {\n                        await writer.write(chunks);\n                    }\n                    else {\n                        for (const buf of chunks) {\n                            await writer.write(buf);\n                        }\n                    }\n                }\n            }\n            finally {\n                stream.closeWrite();\n            }\n        }\n    };\n    return stream;\n}\nfunction parseMultiaddr(ma) {\n    const parts = ma.stringTuples();\n    // This is simpler to have inline than extract into a separate function\n    // eslint-disable-next-line complexity\n    const { url, certhashes, remotePeer } = parts.reduce((state, [proto, value]) => {\n        switch (proto) {\n            case protocols('ip6').code:\n            // @ts-expect-error - ts error on switch fallthrough\n            case protocols('dns6').code:\n                if (value?.includes(':') === true) {\n                    /**\n                     * This resolves cases where `new globalThis.WebTransport` fails to construct because of an invalid URL being passed.\n                     *\n                     * `new URL('https://::1:4001/blah')` will throw a `TypeError: Failed to construct 'URL': Invalid URL`\n                     * `new URL('https://[::1]:4001/blah')` is valid and will not.\n                     *\n                     * @see https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2\n                     */\n                    value = `[${value}]`;\n                }\n            // eslint-disable-next-line no-fallthrough\n            case protocols('ip4').code:\n            case protocols('dns4').code:\n                if (state.seenHost || state.seenPort) {\n                    throw new Error('Invalid multiaddr, saw host and already saw the host or port');\n                }\n                return {\n                    ...state,\n                    url: `${state.url}${value ?? ''}`,\n                    seenHost: true\n                };\n            case protocols('quic').code:\n            case protocols('quic-v1').code:\n            case protocols('webtransport').code:\n                if (!state.seenHost || !state.seenPort) {\n                    throw new Error(\"Invalid multiaddr, Didn't see host and port, but saw quic/webtransport\");\n                }\n                return state;\n            case protocols('udp').code:\n                if (state.seenPort) {\n                    throw new Error('Invalid multiaddr, saw port but already saw the port');\n                }\n                return {\n                    ...state,\n                    url: `${state.url}:${value ?? ''}`,\n                    seenPort: true\n                };\n            case protocols('certhash').code:\n                if (!state.seenHost || !state.seenPort) {\n                    throw new Error('Invalid multiaddr, saw the certhash before seeing the host and port');\n                }\n                return {\n                    ...state,\n                    certhashes: state.certhashes.concat([decodeCerthashStr(value ?? '')])\n                };\n            case protocols('p2p').code:\n                return {\n                    ...state,\n                    remotePeer: peerIdFromString(value ?? '')\n                };\n            default:\n                throw new Error(`unexpected component in multiaddr: ${proto} ${protocols(proto).name} ${value ?? ''} `);\n        }\n    }, \n    // All webtransport urls are https\n    { url: 'https://', seenHost: false, seenPort: false, certhashes: [] });\n    return { url, certhashes, remotePeer };\n}\n// Determines if `maybeSubset` is a subset of `set`. This means that all byte arrays in `maybeSubset` are present in `set`.\nexport function isSubset(set, maybeSubset) {\n    const intersection = maybeSubset.filter(byteArray => {\n        return Boolean(set.find((otherByteArray) => {\n            if (byteArray.length !== otherByteArray.length) {\n                return false;\n            }\n            for (let index = 0; index < byteArray.length; index++) {\n                if (otherByteArray[index] !== byteArray[index]) {\n                    return false;\n                }\n            }\n            return true;\n        }));\n    });\n    return (intersection.length === maybeSubset.length);\n}\nclass WebTransportTransport {\n    constructor(components, init = {}) {\n        this.components = components;\n        this.config = {\n            maxInboundStreams: init.maxInboundStreams ?? 1000\n        };\n    }\n    get [Symbol.toStringTag]() {\n        return '@libp2p/webtransport';\n    }\n    get [symbol]() {\n        return true;\n    }\n    async dial(ma, options) {\n        log('dialing %s', ma);\n        const localPeer = this.components.peerId;\n        if (localPeer === undefined) {\n            throw new Error('Need a local peerid');\n        }\n        options = options ?? {};\n        const { url, certhashes, remotePeer } = parseMultiaddr(ma);\n        if (certhashes.length === 0) {\n            throw new Error('Expected multiaddr to contain certhashes');\n        }\n        const wt = new WebTransport(`${url}/.well-known/libp2p-webtransport?type=noise`, {\n            serverCertificateHashes: certhashes.map(certhash => ({\n                algorithm: 'sha-256',\n                value: certhash.digest\n            }))\n        });\n        wt.closed.catch((error) => {\n            log.error('WebTransport transport closed due to:', error);\n        });\n        await wt.ready;\n        if (remotePeer == null) {\n            throw new Error('Need a target peerid');\n        }\n        if (!await this.authenticateWebTransport(wt, localPeer, remotePeer, certhashes)) {\n            throw new Error('Failed to authenticate webtransport');\n        }\n        const maConn = {\n            close: async (err) => {\n                if (err != null) {\n                    log('Closing webtransport with err:', err);\n                }\n                wt.close();\n            },\n            remoteAddr: ma,\n            timeline: {\n                open: Date.now()\n            },\n            // This connection is never used directly since webtransport supports native streams.\n            ...inertDuplex()\n        };\n        wt.closed.catch((err) => {\n            log.error('WebTransport connection closed:', err);\n            // This is how we specify the connection is closed and shouldn't be used.\n            maConn.timeline.close = Date.now();\n        });\n        try {\n            options?.signal?.throwIfAborted();\n        }\n        catch (e) {\n            wt.close();\n            throw e;\n        }\n        return await options.upgrader.upgradeOutbound(maConn, { skipEncryption: true, muxerFactory: this.webtransportMuxer(wt), skipProtection: true });\n    }\n    async authenticateWebTransport(wt, localPeer, remotePeer, certhashes) {\n        const stream = await wt.createBidirectionalStream();\n        const writer = stream.writable.getWriter();\n        const reader = stream.readable.getReader();\n        await writer.ready;\n        const duplex = {\n            source: (async function* () {\n                while (true) {\n                    const val = await reader.read();\n                    if (val.value != null) {\n                        yield val.value;\n                    }\n                    if (val.done === true) {\n                        break;\n                    }\n                }\n            })(),\n            sink: async function (source) {\n                for await (const chunk of source) {\n                    await writer.write(chunk);\n                }\n            }\n        };\n        const n = noise()();\n        const { remoteExtensions } = await n.secureOutbound(localPeer, duplex, remotePeer);\n        // We're done with this authentication stream\n        writer.close().catch((err) => {\n            log.error(`Failed to close authentication stream writer: ${err.message}`);\n        });\n        reader.cancel().catch((err) => {\n            log.error(`Failed to close authentication stream reader: ${err.message}`);\n        });\n        // Verify the certhashes we used when dialing are a subset of the certhashes relayed by the remote peer\n        if (!isSubset(remoteExtensions?.webtransportCerthashes ?? [], certhashes.map(ch => ch.bytes))) {\n            throw new Error(\"Our certhashes are not a subset of the remote's reported certhashes\");\n        }\n        return true;\n    }\n    webtransportMuxer(wt) {\n        let streamIDCounter = 0;\n        const config = this.config;\n        return {\n            protocol: 'webtransport',\n            createStreamMuxer: (init) => {\n                // !TODO handle abort signal when WebTransport supports this.\n                if (typeof init === 'function') {\n                    // The api docs say that init may be a function\n                    init = { onIncomingStream: init };\n                }\n                const activeStreams = [];\n                (async function () {\n                    //! TODO unclear how to add backpressure here?\n                    const reader = wt.incomingBidirectionalStreams.getReader();\n                    while (true) {\n                        const { done, value: wtStream } = await reader.read();\n                        if (done === true) {\n                            break;\n                        }\n                        if (activeStreams.length >= config.maxInboundStreams) {\n                            // We've reached our limit, close this stream.\n                            wtStream.writable.close().catch((err) => {\n                                log.error(`Failed to close inbound stream that crossed our maxInboundStream limit: ${err.message}`);\n                            });\n                            wtStream.readable.cancel().catch((err) => {\n                                log.error(`Failed to close inbound stream that crossed our maxInboundStream limit: ${err.message}`);\n                            });\n                        }\n                        else {\n                            const stream = await webtransportBiDiStreamToStream(wtStream, String(streamIDCounter++), 'inbound', activeStreams, init?.onStreamEnd);\n                            activeStreams.push(stream);\n                            init?.onIncomingStream?.(stream);\n                        }\n                    }\n                })().catch(() => {\n                    log.error('WebTransport failed to receive incoming stream');\n                });\n                const muxer = {\n                    protocol: 'webtransport',\n                    streams: activeStreams,\n                    newStream: async (name) => {\n                        const wtStream = await wt.createBidirectionalStream();\n                        const stream = await webtransportBiDiStreamToStream(wtStream, String(streamIDCounter++), init?.direction ?? 'outbound', activeStreams, init?.onStreamEnd);\n                        activeStreams.push(stream);\n                        return stream;\n                    },\n                    /**\n                     * Close or abort all tracked streams and stop the muxer\n                     */\n                    close: (err) => {\n                        if (err != null) {\n                            log('Closing webtransport muxer with err:', err);\n                        }\n                        wt.close();\n                    },\n                    // This stream muxer is webtransport native. Therefore it doesn't plug in with any other duplex.\n                    ...inertDuplex()\n                };\n                try {\n                    init?.signal?.throwIfAborted();\n                }\n                catch (e) {\n                    wt.close();\n                    throw e;\n                }\n                return muxer;\n            }\n        };\n    }\n    createListener(options) {\n        throw new Error('Webtransport servers are not supported in Node or the browser');\n    }\n    /**\n     * Takes a list of `Multiaddr`s and returns only valid webtransport addresses.\n     */\n    filter(multiaddrs) {\n        return multiaddrs.filter(ma => ma.protoNames().includes('webtransport'));\n    }\n}\nexport function webTransport(init = {}) {\n    return (components) => new WebTransportTransport(components, init);\n}\n//# sourceMappingURL=index.js.map"],"names":["TopicValidatorResult","FaultTolerance","coerce","o","fromString","str","toString","b","base","ALPHABET","name","BASE_MAP","j","i","x","xc","BASE","LEADER","FACTOR","iFACTOR","encode","source","zeroes","length","pbegin","pend","size","b58","carry","it1","it2","decodeUnsafe","psz","b256","it3","it4","vch","decode","string","buffer","src","_brrp__multiformats_scope_baseX","Encoder$1","prefix","baseEncode","bytes","Decoder$1","baseDecode","text","decoder","or","ComposedDecoder$1","decoders","input","left","right","ComposedDecoder","Codec$1","Encoder","Decoder","from","Codec","baseX","alphabet","basex","bitsPerChar","codes","end","out","bits","written","value","data","pad","mask","rfc4648","base58btc","base58flickr","base32","base32upper","base32pad","base32padupper","base32hex","base32hexupper","base32hexpad","base32hexpadupper","base32z","base10","base16","base16upper","base2","alphabetBytesToChars","p","c","alphabetCharsToBytes","byts","char","byt","base256emoji","base36","base36upper","base64","base64pad","base64url","base64urlpad","base8","identity","buf","bases","identityBase","base58","V","names","table","row","proto","createProtocol","code","resolvable","path","getProtocol","acc","d","encode_1","MSB","REST","MSBALL","INT","num","offset","oldOffset","read","MSB$1","REST$1","res","shift","counter","l","N1","N2","N3","N4","N5","N6","N7","N8","N9","varint","_brrp_varint","multihash","sizeOffset","varint.decode","digestOffset","digest","Digest","asUint8Array","alloc","allocUnsafe","concat","arrays","curr","output","arr","equals","a","symbol","findBufAndOffset","bufs","index","bufEnd","isUint8ArrayList","Uint8ArrayList","beginInclusive","endExclusive","list","bufStart","sliceStartInBuf","sliceEndsInBuf","start","search","needle","M","radix","rightmostPositions","lastIndex","lastPatIndex","skip","byteOffset","littleEndian","other","log","logger","multibaseDecoder","decodeCerthashStr","s","digest.decode","inertDuplex","webtransportBiDiStreamToStream","bidiStream","streamId","direction","activeStreams","onStreamEnd","writer","reader","cleanupStreamFromActiveStreams","stream","writerClosed","readerClosed","err","msg","sinkSunk","_err","val","chunks","parseMultiaddr","ma","parts","url","certhashes","remotePeer","state","protocols","peerIdFromString","isSubset","set","maybeSubset","byteArray","otherByteArray","WebTransportTransport","components","init","options","localPeer","wt","certhash","error","maConn","e","duplex","chunk","n","noise","remoteExtensions","ch","streamIDCounter","config","done","wtStream","muxer","multiaddrs","webTransport"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43]}