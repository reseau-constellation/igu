{"version":3,"mappings":"qVAqBO,MAAMA,EAASC,ECjBf,SAASC,EAAUC,EAAS,CAC/B,MAAMC,EAAa,IAAI,WAAW,gBAClC,SAASC,GAAU,CACfD,EAAW,MAAK,EAChB,UAAWE,KAAUH,EACbG,GAAQ,qBAAuB,MAC/BA,EAAO,oBAAoB,QAASD,CAAO,CAGtD,CACD,UAAWC,KAAUH,EAAS,CAC1B,GAAIG,GAAQ,UAAY,GAAM,CAC1BD,IACA,MAEAC,GAAQ,kBAAoB,MAC5BA,EAAO,iBAAiB,QAASD,CAAO,EAGhD,SAASE,GAAQ,CACb,UAAWD,KAAUH,EACbG,GAAQ,qBAAuB,MAC/BA,EAAO,oBAAoB,QAASD,CAAO,CAGtD,CACD,MAAMC,EAASF,EAAW,OAC1B,OAAAE,EAAO,MAAQC,EACRD,CACX,CCjCO,IAAIE,GACV,SAAUA,EAAc,CACrBA,EAAaA,EAAa,WAAgB,CAAC,EAAI,aAC/CA,EAAaA,EAAa,iBAAsB,CAAC,EAAI,mBACrDA,EAAaA,EAAa,kBAAuB,CAAC,EAAI,oBACtDA,EAAaA,EAAa,eAAoB,CAAC,EAAI,iBACnDA,EAAaA,EAAa,gBAAqB,CAAC,EAAI,kBACpDA,EAAaA,EAAa,eAAoB,CAAC,EAAI,iBACnDA,EAAaA,EAAa,gBAAqB,CAAC,EAAI,iBACxD,GAAGA,IAAiBA,EAAe,CAAE,EAAC,EAC/B,MAAMC,EAAmB,OAAO,OAAO,CAC1C,EAAG,aACH,EAAG,mBACH,EAAG,oBACH,EAAG,iBACH,EAAG,kBACH,EAAG,iBACH,EAAG,iBACP,CAAC,EACYC,EAAwB,OAAO,OAAO,CAC/C,WAAYF,EAAa,WACzB,QAASA,EAAa,kBACtB,MAAOA,EAAa,gBACpB,MAAOA,EAAa,eACxB,CAAC,EACYG,EAAuB,OAAO,OAAO,CAC9C,QAASH,EAAa,iBACtB,MAAOA,EAAa,eACpB,MAAOA,EAAa,cACxB,CAAC,EC3BYI,EAAe,GAAK,GACpBC,EAAqB,GAAK,GAChC,MAAMC,EAAQ,CAKjB,YAAYC,EAAiBH,EAAcI,EAAiCH,EAAoB,CAJhGI,EAAA,gBACAA,EAAA,oBACAA,EAAA,wBACAA,EAAA,wCAEI,KAAK,QAAU,IAAIC,EACnB,KAAK,YAAc,KACnB,KAAK,gBAAkBH,EACvB,KAAK,gCAAkCC,CAC1C,CACD,MAAMG,EAAO,CACT,GAAIA,GAAS,MAAQA,EAAM,SAAW,EAClC,MAAO,GAGX,GADA,KAAK,QAAQ,OAAOA,CAAK,EACrB,KAAK,QAAQ,WAAa,KAAK,gCAC/B,MAAM,OAAO,OAAO,IAAI,MAAM,2CAA2C,EAAG,CAAE,KAAM,uBAAuB,CAAE,EAEjH,MAAMC,EAAO,GACb,KAAO,KAAK,QAAQ,SAAW,GAAG,CAC9B,GAAI,KAAK,aAAe,KACpB,GAAI,CACA,KAAK,YAAc,KAAK,cAAc,KAAK,OAAO,CACrD,OACMC,EAAP,CACI,GAAIA,EAAI,OAAS,kBACb,MAAMA,EAEV,KACH,CAEL,KAAM,CAAE,GAAAC,EAAI,KAAAC,EAAM,OAAAC,EAAQ,OAAAC,CAAQ,EAAG,KAAK,YAE1C,GAD2B,KAAK,QAAQ,OAASA,EACxBD,EACrB,MAEJ,MAAME,EAAM,CACR,GAAAJ,EACA,KAAAC,CAChB,GACgBA,IAASf,EAAa,YAAce,IAASf,EAAa,mBAAqBe,IAASf,EAAa,oBACrGkB,EAAI,KAAO,KAAK,QAAQ,QAAQD,EAAQA,EAASD,CAAM,GAE3DJ,EAAK,KAAKM,CAAG,EACb,KAAK,QAAQ,QAAQD,EAASD,CAAM,EACpC,KAAK,YAAc,KAEvB,OAAOJ,CACV,CAID,cAAcO,EAAM,CAChB,KAAM,CAAE,MAAOC,EAAG,OAAAH,CAAM,EAAKI,EAAWF,CAAI,EACtC,CAAE,MAAOH,EAAQ,OAAQM,CAAG,EAAKD,EAAWF,EAAMF,CAAM,EACxDF,EAAOK,EAAI,EAEjB,GAAInB,EAAiBc,CAAI,GAAK,KAC1B,MAAM,IAAI,MAAM,0BAA0BA,GAAM,EAGpD,GAAIC,EAAS,KAAK,gBACd,MAAM,OAAO,OAAO,IAAI,MAAM,yBAAyB,EAAG,CAAE,KAAM,iBAAiB,CAAE,EAGzF,MAAO,CAAE,GAAII,GAAK,EAAG,KAAAL,EAAM,OAAQE,EAASK,EAAK,OAAAN,EACpD,CACL,CACA,MAAMO,GAAM,IACNC,EAAO,IACb,SAASH,EAAWI,EAAKR,EAAS,EAAG,CACjC,IAAIS,EAAM,EACNC,EAAQ,EACRC,EAAUX,EACVY,EACJ,MAAMC,EAAIL,EAAI,OACd,EAAG,CACC,GAAIG,GAAWE,GAAKH,EAAQ,GACxB,MAAAV,EAAS,EACH,IAAI,WAAW,yBAAyB,EAElDY,EAAIJ,EAAI,IAAIG,GAAS,EACrBF,GAAOC,EAAQ,IACRE,EAAIL,IAASG,GACbE,EAAIL,GAAQ,KAAK,IAAI,EAAGG,CAAK,EACpCA,GAAS,QACJE,GAAKN,IACd,OAAAN,EAASW,EAAUX,EACZ,CACH,MAAOS,EACP,OAAAT,CACR,CACA,CC/FA,SAASc,GAAgBC,EAAO,CAC5B,OAAOA,EAAM,OAAO,aAAa,GAAK,IAC1C,CACA,MAAMC,EAAqB,KAAO,KAC5BC,EAAoB,CAACT,EAAKU,IAAS,CAAEA,EAAK,OAAOV,CAAG,GAC1D,SAASW,GAAaC,EAAQC,EAAS,CACnC,OAAIP,GAAgBM,CAAM,EACd,iBAAmB,CACvB,IAAIE,EAAS,IAAI7B,EACb8B,EAAQ,GACRC,EAAWC,IACXC,EAAO,OAAOL,GAAS,MAAQL,CAAkB,EAIrD,IAHI,MAAMU,CAAI,GAAKA,IAAS,GAAKA,EAAO,KACpCA,EAAOV,GAEPU,IAAS,KAAK,MAAMA,CAAI,EACxB,MAAM,IAAI,MAAM,+BAA+B,EAEnD,MAAMC,EAAaN,GAAS,YAAc,EACpCO,EAAYP,GAAS,WAAaJ,EA0BxC,IAzBK,QAAQ,UAAU,KAAK,SAAY,CACpC,GAAI,CACA,IAAIY,EACJ,gBAAiBrB,KAAOY,EAAQ,CAG5B,GADAQ,EAAUpB,EAAKc,CAAM,EACjBA,EAAO,YAAcI,EAAM,CAC3B,aAAaG,CAAO,EACpBL,EAAS,QAAO,EAChB,SAEJK,EAAU,WAAW,IAAM,CACvBL,EAAS,QAAO,CACnB,EAAEG,CAAU,EAEjB,aAAaE,CAAO,EACpBL,EAAS,QAAO,CACnB,OACM5B,EAAP,CACI4B,EAAS,OAAO5B,CAAG,CACtB,QACO,CACJ2B,EAAQ,EACX,CACjB,CAAa,EACM,CAACA,GAGJ,GAFA,MAAMC,EAAS,QACfA,EAAWC,EAAK,EACZH,EAAO,WAAa,EAAG,CACvB,MAAMV,EAAIU,EACVA,EAAS,IAAI7B,EACb,MAAMmB,EAAE,WAG5B,IAEY,WAAa,CACjB,MAAMU,EAAS,IAAI7B,EACnB,IAAIiC,EAAO,OAAOL,GAAS,MAAQL,CAAkB,EAIrD,IAHI,MAAMU,CAAI,GAAKA,IAAS,GAAKA,EAAO,KACpCA,EAAOV,GAEPU,IAAS,KAAK,MAAMA,CAAI,EACxB,MAAM,IAAI,MAAM,+BAA+B,EAEnD,MAAME,EAAYP,GAAS,WAAaJ,EACxC,UAAWT,KAAOY,EAEdQ,EAAUpB,EAAKc,CAAM,EACjBA,EAAO,YAAcI,IACrB,MAAMJ,EAAO,SAAS,EAAGI,CAAI,EAC7BJ,EAAO,QAAQI,CAAI,GAGvBJ,EAAO,WAAa,IACpB,MAAMA,EAAO,WAEzB,GACA,CChFO,SAASQ,EAAYJ,EAAM,CAC9B,OAAO,IAAI,WAAWA,CAAI,CAC9B,CCGA,MAAMK,EAAY,GAAK,KACvB,MAAMC,EAAQ,CAGV,aAAc,CAFdxC,EAAA,cACAA,EAAA,oBAEI,KAAK,MAAQsC,EAAYC,CAAS,EAClC,KAAK,YAAc,CACtB,CAID,MAAM9B,EAAKiB,EAAM,CACb,MAAMe,EAAO,KAAK,MAClB,IAAIjC,EAAS,KAAK,YAClBkC,EAAO,OAAOjC,EAAI,IAAM,EAAIA,EAAI,KAAMgC,EAAMjC,CAAM,EAClDA,GAAUkC,EAAO,OAAO,OAAS,GAC5BjC,EAAI,OAASlB,EAAa,YAAckB,EAAI,OAASlB,EAAa,mBAAqBkB,EAAI,OAASlB,EAAa,mBAAqBkB,EAAI,MAAQ,KACnJiC,EAAO,OAAOjC,EAAI,KAAK,OAAQgC,EAAMjC,CAAM,EAG3CkC,EAAO,OAAO,EAAGD,EAAMjC,CAAM,EAEjCA,GAAUkC,EAAO,OAAO,OAAS,EACjC,MAAMC,EAASF,EAAK,SAAS,KAAK,YAAajC,CAAM,EACjD+B,EAAY/B,EAAS,KACrB,KAAK,MAAQ8B,EAAYC,CAAS,EAClC,KAAK,YAAc,GAGnB,KAAK,YAAc/B,EAEvBkB,EAAK,OAAOiB,CAAM,GACblC,EAAI,OAASlB,EAAa,YAAckB,EAAI,OAASlB,EAAa,mBAAqBkB,EAAI,OAASlB,EAAa,mBAAqBkB,EAAI,MAAQ,MACnJiB,EAAK,OAAOjB,EAAI,IAAI,CAE3B,CACL,CACA,MAAMmC,EAAU,IAAIJ,GAIb,eAAgBK,GAAOjB,EAAQkB,EAAe,EAAG,CACpD,GAAIA,GAAgB,MAAQA,IAAiB,EAAG,CAE5C,gBAAiBC,KAAYnB,EAAQ,CACjC,MAAMF,EAAO,IAAIzB,EACjB,UAAWQ,KAAOsC,EACdH,EAAQ,MAAMnC,EAAKiB,CAAI,EAE3B,MAAMA,EAAK,WAEf,OAGJ,MAAOC,GAAaC,EAAQ,CACxB,KAAMkB,EACN,UAAW,CAACE,EAAKtB,IAAS,CACtB,UAAWuB,KAAKD,EACZJ,EAAQ,MAAMK,EAAGvB,CAAI,CAE5B,CACT,CAAK,CACL,CC7DA,MAAMwB,EAAMC,EAAO,eAAe,EAC5BC,EAAmB,mBACnBC,GAAmB,mBACnBC,GAAiB,iBACjBC,GAAkB,kBACxB,SAASC,EAAUvC,EAAK,CACpB,OAAOA,GAAO,MAAQ,OAAOA,EAAI,MAAS,UAC9C,CACO,MAAMwC,EAAe,CAexB,YAAYC,EAAM,CAdlB1D,EAAA,WACAA,EAAA,aACAA,EAAA,iBACAA,EAAA,eACAA,EAAA,wBACAA,EAAA,wBACAA,EAAA,wBACAA,EAAA,oBACAA,EAAA,kBACAA,EAAA,iBACAA,EAAA,eACAA,EAAA,qBACAA,EAAA,cACAA,EAAA,oBAEI,KAAK,gBAAkB,IAAI,gBAC3B,KAAK,gBAAkB,IAAI,gBAC3B,KAAK,gBAAkB,IAAI,gBAC3B,KAAK,YAAc,GACnB,KAAK,UAAY,GACjB,KAAK,SAAW,GAChB,KAAK,GAAK0D,EAAK,GACf,KAAK,SAAWA,EAAK,UAAY,GACjC,KAAK,KAAO,CACR,UAAWA,EAAK,UAChB,SAAU,CACN,KAAM,KAAK,IAAK,CACnB,CACb,EACQ,KAAK,YAAcA,EAAK,YACxB,KAAK,MAAQA,EAAK,MAClB,KAAK,OAAS,KAAK,aAAeC,EAAS,CACvC,MAAO,IAAM,CAET,GAAI,KAAK,KAAK,SAAS,QAAU,KAAM,CACnC,MAAM1C,EAAM,KAAK,gBACbuC,EAAUvC,CAAG,GACbA,EAAI,MAAMb,GAAO,CACb8C,EAAI,MAAM,iCAAkC9C,CAAG,CAC3E,CAAyB,EAGT,KAAK,YAAW,CACnB,CACb,CAAS,EAED,KAAK,KAAO,KAAK,KAAK,KAAK,IAAI,CAClC,CACD,YAAYA,EAAK,CACT,KAAK,cAGT,KAAK,KAAK,SAAS,UAAY,KAAK,IAAG,EACvC,KAAK,YAAc,GACnB8C,EAAI,MAAM,oCAAqC,KAAK,KAAK,UAAW,KAAK,GAAI9C,CAAG,EAC5EA,GAAO,MAAQ,KAAK,QAAU,OAC9B,KAAK,OAASA,GAEd,KAAK,YACL,KAAK,KAAK,SAAS,MAAQ,KAAK,IAAG,EAC/B,KAAK,OAAS,MACd,KAAK,MAAM,KAAK,MAAM,GAGjC,CACD,UAAUA,EAAK,CACP,KAAK,YAGT,KAAK,KAAK,SAAS,WAAa,KAAK,IAAG,EACxC,KAAK,UAAY,GACjB8C,EAAI,MAAM,kCAAmC,KAAK,KAAK,UAAW,KAAK,GAAI9C,CAAG,EAC1EA,GAAO,MAAQ,KAAK,QAAU,OAC9B,KAAK,OAASA,GAEd,KAAK,cACL,KAAK,KAAK,SAAS,MAAQ,KAAK,IAAG,EAC/B,KAAK,OAAS,MACd,KAAK,MAAM,KAAK,MAAM,GAGjC,CAED,OAAQ,CACJ8C,EAAI,MAAM,qBAAsB,KAAK,KAAK,UAAW,KAAK,EAAE,EAC5D,KAAK,UAAS,EACd,KAAK,WAAU,CAClB,CAED,WAAY,CACRA,EAAI,MAAM,yBAA0B,KAAK,KAAK,UAAW,KAAK,EAAE,EAC5D,MAAK,aAGT,KAAK,aAAa,KACrB,CAED,YAAa,CAET,GADAA,EAAI,MAAM,0BAA2B,KAAK,KAAK,UAAW,KAAK,EAAE,EAC7D,MAAK,UAGT,MAAK,gBAAgB,QACrB,GAAI,CAGA,MAAMjC,EAAM,KAAK,iBACbuC,EAAUvC,CAAG,GACbA,EAAI,MAAMb,GAAO,CACb8C,EAAI,MAAM,kCAAmC9C,CAAG,CACpE,CAAiB,CAER,OACMA,EAAP,CACI8C,EAAI,MAAM,mCAAoC,KAAK,KAAK,UAAW,KAAK,GAAI9C,CAAG,CAClF,CACD,KAAK,UAAS,EACjB,CAED,MAAMA,EAAK,CACP8C,EAAI,MAAM,qBAAsB,KAAK,KAAK,UAAW,KAAK,GAAI9C,CAAG,EAEjE,KAAK,aAAa,IAAIA,CAAG,EACzB,KAAK,gBAAgB,QACrB,KAAK,UAAUA,CAAG,CACrB,CAED,OAAQ,CACJ,MAAMA,EAAM,IAAIwD,EAAU,eAAgBR,CAAgB,EAC1D,KAAK,gBAAgB,QACrB,KAAK,aAAa,IAAIhD,CAAG,EACzB,KAAK,UAAUA,CAAG,CACrB,CACD,MAAM,KAAKwB,EAAQ,CACf,GAAI,KAAK,SACL,MAAM,IAAIgC,EAAU,gCAAiCL,EAAe,EAGxE,GADA,KAAK,SAAW,GACZ,KAAK,UACL,MAAM,IAAIK,EAAU,4BAA6BN,EAAc,EAEnE,MAAMjE,EAASJ,EAAU,CACrB,KAAK,gBAAgB,OACrB,KAAK,gBAAgB,OACrB,KAAK,gBAAgB,MACjC,CAAS,EACD,GAAI,CAEA,GADA2C,EAASiC,EAAgBjC,EAAQvC,CAAM,EACnC,KAAK,KAAK,YAAc,WAAY,CACpC,MAAM4B,EAAM,KAAK,gBACbuC,EAAUvC,CAAG,GACb,MAAMA,EAGd,cAAeP,KAAQkB,EACnB,KAAOlB,EAAK,OAAS,GAAG,CACpB,GAAIA,EAAK,QAAU,KAAK,YAAa,CACjC,MAAMO,EAAM,KAAK,SAASP,aAAgB,WAAa,IAAIT,EAAeS,CAAI,EAAIA,CAAI,EAClF8C,EAAUvC,CAAG,GACb,MAAMA,EAEV,MAEJP,EAAOA,aAAgB,WAAa,IAAIT,EAAeS,CAAI,EAAIA,EAC/D,MAAMO,EAAM,KAAK,SAASP,EAAK,QAAQ,EAAG,KAAK,WAAW,CAAC,EACvD8C,EAAUvC,CAAG,GACb,MAAMA,EAEVP,EAAK,QAAQ,KAAK,WAAW,EAGxC,OACMN,EAAP,CACI,GAAIA,EAAI,OAAS,WAAaA,EAAI,UAAY,4BAA6B,CACvE,GAAI,KAAK,gBAAgB,OAAO,QAC5B,OAEA,KAAK,gBAAgB,OAAO,UAC5BA,EAAI,QAAU,eACdA,EAAI,KAAOgD,GAEX,KAAK,gBAAgB,OAAO,UAC5BhD,EAAI,QAAU,iBACdA,EAAI,KAAOiD,IAInB,GAAIjD,EAAI,OAASgD,EACbF,EAAI,MAAM,qBAAsB,KAAK,KAAK,UAAW,KAAK,EAAE,MAE3D,CACDA,EAAI,MAAM,qBAAsB,KAAK,KAAK,UAAW,KAAK,GAAI9C,CAAG,EACjE,GAAI,CACA,MAAMa,EAAM,KAAK,YACbuC,EAAUvC,CAAG,GACb,MAAMA,EAEV,KAAK,KAAK,SAAS,MAAQ,KAAK,IAAG,CACtC,OACMb,EAAP,CACI8C,EAAI,MAAM,mCAAoC,KAAK,KAAK,UAAW,KAAK,GAAI9C,CAAG,CAClF,EAEL,WAAK,aAAa,IAAIA,CAAG,EACzB,KAAK,UAAUA,CAAG,EACZA,CACT,QACO,CACJf,EAAO,MAAK,CACf,CACD,GAAI,CACA,MAAM4B,EAAM,KAAK,iBACbuC,EAAUvC,CAAG,GACb,MAAMA,CAEb,OACMb,EAAP,CACI8C,EAAI,MAAM,mCAAoC,KAAK,KAAK,UAAW,KAAK,GAAI9C,CAAG,CAClF,CACD,KAAK,UAAS,CACjB,CAKD,WAAWM,EAAM,CACb,KAAK,aAAa,KAAKA,CAAI,CAC9B,CAKD,sBAAuB,CACnB,OAAO,KAAK,aAAa,cAC5B,CACL,CCrPA,MAAMoD,WAAoBL,EAAe,CAKrC,YAAYC,EAAM,CACd,MAAMA,CAAI,EALd1D,EAAA,aACAA,EAAA,iBACAA,EAAA,aACAA,EAAA,cAGI,KAAK,MAAQ0D,EAAK,YAAc,WAAajE,EAAwBC,EACrE,KAAK,KAAOgE,EAAK,KACjB,KAAK,KAAOA,EAAK,KACjB,KAAK,SAAWA,EAAK,QACxB,CACD,eAAgB,CACZ,KAAK,KAAK,CAAE,GAAI,KAAK,SAAU,KAAMjE,EAAsB,WAAY,KAAM,IAAIQ,EAAe8D,EAAqB,KAAK,IAAI,CAAC,CAAC,CAAE,CACrI,CACD,SAASrD,EAAM,CACX,KAAK,KAAK,CAAE,GAAI,KAAK,SAAU,KAAM,KAAK,MAAM,QAAS,KAAAA,CAAM,EAClE,CACD,WAAY,CACR,KAAK,KAAK,CAAE,GAAI,KAAK,SAAU,KAAM,KAAK,MAAM,KAAK,CAAE,CAC1D,CACD,gBAAiB,CACb,KAAK,KAAK,CAAE,GAAI,KAAK,SAAU,KAAM,KAAK,MAAM,KAAK,CAAE,CAC1D,CACD,eAAgB,CAEf,CACL,CACO,SAASsD,GAAanC,EAAS,CAClC,KAAM,CAAE,GAAAxB,EAAI,KAAA4D,EAAM,KAAAC,EAAM,MAAAC,EAAO,KAAA7D,EAAO,YAAa,WAAA8D,EAAazE,CAAc,EAAGkC,EACjF,OAAO,IAAIiC,GAAY,CACnB,GAAIxD,IAAS,YAAe,IAAID,IAAQ,IAAIA,IAC5C,SAAUA,EACV,KAAM,GAAG4D,GAAe5D,IACxB,UAAWC,IAAS,YAAc,WAAa,UAC/C,YAAa8D,EACb,MAAAD,EACA,KAAAD,CACR,CAAK,CACL,CCjCA,MAAMhB,EAAMC,EAAO,cAAc,EAC3BkB,GAA6C,KAC7CC,GAA8C,KAC9CC,GAAyB,KAAO,KAAO,EACvCC,GAAuB,EAC7B,SAASC,EAAahE,EAAK,CACvB,MAAMiE,EAAS,CACX,GAAGjE,EACH,KAAM,GAAGjB,EAAiBiB,EAAI,IAAI,MAAMA,EAAI,OACpD,EACI,OAAIA,EAAI,OAASlB,EAAa,aAC1BmF,EAAO,KAAOC,EAAmBlE,EAAI,gBAAgB,WAAaA,EAAI,KAAOA,EAAI,KAAK,SAAU,KAEhGA,EAAI,OAASlB,EAAa,mBAAqBkB,EAAI,OAASlB,EAAa,oBACzEmF,EAAO,KAAOC,EAAmBlE,EAAI,gBAAgB,WAAaA,EAAI,KAAOA,EAAI,KAAK,SAAU,EAAE,QAAQ,GAEvGiE,CACX,CACO,MAAME,EAAiB,CAU1B,YAAYlB,EAAM,CATlB1D,EAAA,gBAAW,gBACXA,EAAA,aACAA,EAAA,eACAA,EAAA,kBACAA,EAAA,iBACAA,EAAA,cACAA,EAAA,gBACAA,EAAA,wBACAA,EAAA,oBAEI0D,EAAOA,GAAQ,GACf,KAAK,UAAY,EACjB,KAAK,SAAW,CAIZ,WAAY,IAAI,IAIhB,UAAW,IAAI,GAC3B,EACQ,KAAK,MAAQA,EAIb,KAAK,KAAO,KAAK,cAIjB,MAAM9B,EAAS,KAAK,gBACpB,KAAK,QAAUA,EACf,KAAK,OAASA,EAId,KAAK,gBAAkB,IAAI,gBAC3B,KAAK,YAAc,IAAIiD,oBAAkB,CACrC,OAAQnB,EAAK,qBAAuBc,GACpC,SAAU,CACtB,CAAS,CACJ,CAID,IAAI,SAAU,CAEV,MAAMM,EAAU,GAChB,UAAWC,KAAU,KAAK,SAAS,WAAW,OAAM,EAChDD,EAAQ,KAAKC,CAAM,EAEvB,UAAWA,KAAU,KAAK,SAAS,UAAU,OAAM,EAC/CD,EAAQ,KAAKC,CAAM,EAEvB,OAAOD,CACV,CAKD,UAAUb,EAAM,CACZ,GAAI,KAAK,gBAAgB,OAAO,QAC5B,MAAM,IAAI,MAAM,sBAAsB,EAE1C,MAAM5D,EAAK,KAAK,YAChB4D,EAAOA,GAAQ,KAAO5D,EAAG,WAAa4D,EAAK,WAC3C,MAAMe,EAAW,KAAK,SAAS,WAC/B,OAAO,KAAK,WAAW,CAAE,GAAA3E,EAAI,KAAA4D,EAAM,KAAM,YAAa,SAAAe,CAAQ,CAAE,CACnE,CAID,MAAM5E,EAAK,CACH,KAAK,gBAAgB,OAAO,UAE5BA,GAAO,KACP,KAAK,QAAQ,QAAQ6E,GAAK,CAAEA,EAAE,MAAM7E,CAAG,CAAE,CAAE,EAG3C,KAAK,QAAQ,QAAQ6E,GAAK,CAAEA,EAAE,MAAK,CAAG,CAAE,EAE5C,KAAK,gBAAgB,QACxB,CAID,mBAAmBpD,EAAS,CACxB,KAAM,CAAE,GAAAxB,EAAI,KAAA4D,CAAM,EAAGpC,EACfmD,EAAW,KAAK,SAAS,UAC/B,OAAO,KAAK,WAAW,CAAE,GAAA3E,EAAI,KAAA4D,EAAM,KAAM,WAAY,SAAAe,CAAQ,CAAE,CAClE,CACD,WAAWnD,EAAS,CAChB,KAAM,CAAE,GAAAxB,EAAI,KAAA4D,EAAM,KAAA3D,EAAM,SAAA0E,CAAQ,EAAKnD,EAErC,GADAqB,EAAI,mBAAoB5C,EAAMD,CAAE,EAC5BC,IAAS,aAAe,KAAK,SAAS,WAAW,QAAU,KAAK,MAAM,oBAAsBgE,IAC5F,MAAM,IAAIV,EAAU,iCAAkC,+BAA+B,EAEzF,GAAIoB,EAAS,IAAI3E,CAAE,EACf,MAAM,IAAI,MAAM,GAAGC,YAAeD,mBAAoB,EAe1D,MAAM0E,EAASf,GAAa,CAAE,GAAA3D,EAAI,KAAA4D,EAAM,KAb1BxD,GAAQ,CACdyC,EAAI,SACJA,EAAI,MAAM,oBAAqB5C,EAAMD,EAAIoE,EAAahE,CAAG,CAAC,EAE9D,KAAK,QAAQ,KAAKA,CAAG,CACjC,EAQsD,KAAAH,EAAM,MAPtC,IAAM,CAChB4C,EAAI,6CAA8C5C,EAAMD,EAAI0E,EAAO,KAAK,QAAQ,EAChFC,EAAS,OAAO3E,CAAE,EACd,KAAK,MAAM,aAAe,MAC1B,KAAK,MAAM,YAAY0E,CAAM,CAE7C,EACmE,WAAY,KAAK,MAAM,UAAY,GAC9F,OAAAC,EAAS,IAAI3E,EAAI0E,CAAM,EAChBA,CACV,CAKD,aAAc,CAqBV,MApBa,OAAOnD,GAAW,CAC3B,MAAMvC,EAASJ,EAAU,CAAC,KAAK,gBAAgB,OAAQ,KAAK,MAAM,MAAM,CAAC,EACzE,GAAI,CACA2C,EAASiC,EAAgBjC,EAAQvC,CAAM,EACvC,MAAM6F,EAAU,IAAIrF,GAAQ,KAAK,MAAM,WAAY,KAAK,MAAM,8BAA8B,EAC5F,gBAAiBK,KAAS0B,EACtB,UAAWnB,KAAOyE,EAAQ,MAAMhF,CAAK,EACjC,MAAM,KAAK,gBAAgBO,CAAG,EAGtC,KAAK,QAAQ,KAChB,OACML,EAAP,CACI8C,EAAI,gBAAiB9C,CAAG,EACxB,KAAK,QAAQ,IAAIA,CAAG,CACvB,QACO,CACJf,EAAO,MAAK,CACf,CACb,CAEK,CAKD,eAAgB,CAIZ,MAAMuC,EAASuD,EAAU,CACrB,WAAY,GACZ,MALW/E,GAAQ,CACnB,KAAK,MAAMA,CAAG,CAC1B,CAIA,CAAS,EACD,OAAO,OAAO,OAAOyC,GAAOjB,EAAQ,KAAK,MAAM,YAAY,EAAG,CAC1D,KAAMA,EAAO,KACb,IAAKA,EAAO,IACZ,OAAQA,EAAO,MAC3B,CAAS,CACJ,CACD,MAAM,gBAAgBwD,EAAS,CAC3B,KAAM,CAAE,GAAA/E,EAAI,KAAAC,CAAM,EAAG8E,EAKrB,GAJIlC,EAAI,SACJA,EAAI,MAAM,mBAAoBuB,EAAaW,CAAO,CAAC,EAGnDA,EAAQ,OAAS7F,EAAa,WAAY,CAC1C,GAAI,KAAK,SAAS,UAAU,QAAU,KAAK,MAAM,mBAAqB8E,IAA6C,CAC/GnB,EAAI,+BAA+B,EAGnC,KAAK,QAAQ,KAAK,CACd,GAAA7C,EACA,KAAMd,EAAa,cACvC,CAAiB,EAID,GAAI,CACA,MAAM,KAAK,YAAY,QAAQ,aAAc,CAAC,CACjD,MACD,CACI2D,EAAI,4GAA4G,EAEhH,KAAK,QAAQ,IAAI,IAAI,MAAM,uBAAuB,CAAC,EACnD,MACH,CACD,OAEJ,MAAM6B,EAAS,KAAK,mBAAmB,CAAE,GAAA1E,EAAI,KAAMsE,EAAmBS,EAAQ,gBAAgB,WAAaA,EAAQ,KAAOA,EAAQ,KAAK,SAAQ,CAAE,CAAC,CAAE,EAChJ,KAAK,MAAM,kBAAoB,MAC/B,KAAK,MAAM,iBAAiBL,CAAM,EAEtC,OAGJ,MAAMA,IADQzE,EAAO,KAAO,EAAI,KAAK,SAAS,WAAa,KAAK,SAAS,WACrD,IAAID,CAAE,EAC1B,GAAI0E,GAAU,KAAM,CAChB7B,EAAI,wCAAyC7C,EAAIb,EAAiBc,CAAI,CAAC,EACvE,OAEJ,MAAM+E,EAAgB,KAAK,MAAM,qBAAuBd,GACxD,OAAQjE,EAAI,CACR,KAAKf,EAAa,kBAClB,KAAKA,EAAa,iBACd,GAAIwF,EAAO,qBAAsB,EAAGM,EAAe,CAE/C,KAAK,QAAQ,KAAK,CACd,GAAID,EAAQ,GACZ,KAAM9E,IAASf,EAAa,kBAAoBA,EAAa,eAAiBA,EAAa,eACnH,CAAqB,EAED,MAAM+F,EAAQ,IAAI1B,EAAU,iFAAkF,8BAA8B,EAC5ImB,EAAO,MAAMO,CAAK,EAClB,OAGJP,EAAO,WAAWK,EAAQ,IAAI,EAC9B,MACJ,KAAK7F,EAAa,gBAClB,KAAKA,EAAa,eAEdwF,EAAO,UAAS,EAChB,MACJ,KAAKxF,EAAa,gBAClB,KAAKA,EAAa,eAEdwF,EAAO,MAAK,EACZ,MACJ,QACI7B,EAAI,0BAA2B5C,CAAI,CAC1C,CACJ,CACL,CCxQA,MAAMiF,EAAM,CAGR,YAAY7B,EAAO,GAAI,CAFvB1D,EAAA,gBAAW,gBACXA,EAAA,cAEI,KAAK,MAAQ0D,CAChB,CACD,kBAAkBA,EAAO,GAAI,CACzB,OAAO,IAAIkB,GAAiB,CACxB,GAAGlB,EACH,GAAG,KAAK,KACpB,CAAS,CACJ,CACL,CACO,SAAS8B,GAAM9B,EAAO,GAAI,CAC7B,MAAO,IAAM,IAAI6B,GAAM7B,CAAI,CAC/B,CCTO,IAAI+B,GACV,SAAUA,EAAgB,CAIvBA,EAAeA,EAAe,UAAe,CAAC,EAAI,YAIlDA,EAAeA,EAAe,SAAc,CAAC,EAAI,UACrD,GAAGA,IAAmBA,EAAiB,GAAG,ECX1C,MAAMC,GAAsB,SAAY,CACpC,IAAIC,EACJ,OAAIC,GAAaC,EACbF,GAAoB,MAAKG,EAAA,IAAC,OAAO,gCAAuB,EAAC,oHAAE,QAEtDC,EACLJ,GAAoB,MAAMG,EAAA,WAAO,iCAAwB,EAAC,iGAAE,QAEvDE,EACLL,GAAoB,MAAKG,EAAA,IAAC,OAAO,uCAAmC,qKAC/D,QAEAG,EACLN,GAAoB,MAAKG,EAAA,IAAC,OAAO,0BAAiB,oIAAG,SAGrD,QAAQ,KAAK,oEAAoE,EACjFH,GAAoB,MAAKG,EAAA,IAAC,OAAO,gCAAuB,EAAC,oHAAE,SAExDH,CACX,EAEMO,GAAkB,KACb,CACH,OAAQ,CACJ,aAAc,CAACV,IAAO,EACtB,qBAAsB,CAACW,GAAO,EAC9B,iBAAkB,CACd,eAAgBV,EAAe,QAClC,CACJ,EACD,MAAO,CAAE,QAAS,GAAM,IAAK,CAAE,QAAS,GAAM,OAAQ,GAAQ,CACtE,GAEe,eAAeW,GAASC,EAAM,gBAAiB,CAC1D,MAAMC,EAASJ,KACTP,EAAmB,MAAMD,KAC/BY,EAAO,KAAOD,EACd,MAAME,EAAeC,EAAaF,EAAQX,CAAgB,EAC1D,OAAO,MAAM5G,EAAOwH,CAAY,CACpC","names":["create","createImport","anySignal","signals","controller","onAbort","signal","clear","MessageTypes","MessageTypeNames","InitiatorMessageTypes","ReceiverMessageTypes","MAX_MSG_SIZE","MAX_MSG_QUEUE_SIZE","Decoder","maxMessageSize","maxUnprocessedMessageQueueSize","__publicField","Uint8ArrayList","chunk","msgs","err","id","type","length","offset","msg","data","h","readVarInt","end","MSB","REST","buf","res","shift","counter","b","l","isAsyncIterable","thing","DEFAULT_BATCH_SIZE","DEFAULT_SERIALIZE","list","batchedBytes","source","options","buffer","ended","deferred","defer","size","yieldAfter","serialize","timeout","allocUnsafe","POOL_SIZE","Encoder","pool","varint","header","encoder","encode","minSendBytes","messages","obj","m","log","logger","ERR_STREAM_RESET","ERR_STREAM_ABORT","ERR_SINK_ENDED","ERR_DOUBLE_SINK","isPromise","AbstractStream","init","pushable","CodeError","abortableSource","MplexStream","uint8ArrayFromString","createStream","name","send","onEnd","maxMsgSize","MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION","MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION","MAX_STREAM_BUFFER_SIZE","DISCONNECT_THRESHOLD","printMessage","output","uint8ArrayToString","MplexStreamMuxer","RateLimiterMemory","streams","stream","registry","s","decoder","pushableV","message","maxBufferSize","error","Mplex","mplex","FaultTolerance","obtConfigPlateforme","configPlateforme","isBrowser","isElectronRenderer","__vitePreload","isWebWorker","isElectronMain","isNode","obtConfigCommun","noise","initSFIP","dir","config","configFinale","mergeOptions"],"sources":["../../../../node_modules/ipfs-core/src/index.js","../../../../node_modules/@libp2p/mplex/node_modules/any-signal/dist/src/index.js","../../../../node_modules/@libp2p/mplex/dist/src/message-types.js","../../../../node_modules/@libp2p/mplex/dist/src/decode.js","../../../../node_modules/it-batched-bytes/dist/src/index.js","../../../../node_modules/@libp2p/mplex/dist/src/alloc-unsafe-browser.js","../../../../node_modules/@libp2p/mplex/dist/src/encode.js","../../../../node_modules/@libp2p/mplex/node_modules/@libp2p/interface-stream-muxer/dist/src/stream.js","../../../../node_modules/@libp2p/mplex/dist/src/stream.js","../../../../node_modules/@libp2p/mplex/dist/src/mplex.js","../../../../node_modules/@libp2p/mplex/dist/src/index.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/interface-transport/dist/src/index.js","../../../../node_modules/@constl/ipa/dist/src/sfip/index.js"],"sourcesContent":["import { create as createImport } from './components/index.js'\nimport globSourceImport from 'ipfs-utils/src/files/glob-source.js'\nimport urlSourceImport from 'ipfs-utils/src/files/url-source.js'\n\n/**\n * @typedef {import('ipfs-core-types').IPFS} IPFS\n * @typedef {import('./types').Options} Options\n * @typedef {import('./types').Libp2pFactoryFn} Libp2pFactoryFn\n * @typedef {import('./types').Libp2pFactoryFnArgs} Libp2pFactoryFnArgs\n * @typedef {import('./types').InitOptions} InitOptions\n * @typedef {import('./types').RelayOptions} RelayOptions\n * @typedef {import('./types').PreloadOptions} PreloadOptions\n * @typedef {import('./types').ExperimentalOptions} ExperimentalOptions\n * @typedef {import('./types').Preload} Preload\n * @typedef {import('./types').MfsPreload} MfsPreload\n * @typedef {import('./types').LoadBaseFn} LoadBaseFn\n * @typedef {import('./types').LoadCodecFn} LoadCodecFn\n * @typedef {import('./types').LoadHasherFn} LoadHasherFn\n * @typedef {import('./types').IPLDOptions} IPLDOptions\n */\n\nexport const create = createImport\nexport const globSource = globSourceImport\nexport const urlSource = urlSourceImport\n","/**\n * Takes an array of AbortSignals and returns a single signal.\n * If any signals are aborted, the returned signal will be aborted.\n */\nexport function anySignal(signals) {\n    const controller = new globalThis.AbortController();\n    function onAbort() {\n        controller.abort();\n        for (const signal of signals) {\n            if (signal?.removeEventListener != null) {\n                signal.removeEventListener('abort', onAbort);\n            }\n        }\n    }\n    for (const signal of signals) {\n        if (signal?.aborted === true) {\n            onAbort();\n            break;\n        }\n        if (signal?.addEventListener != null) {\n            signal.addEventListener('abort', onAbort);\n        }\n    }\n    function clear() {\n        for (const signal of signals) {\n            if (signal?.removeEventListener != null) {\n                signal.removeEventListener('abort', onAbort);\n            }\n        }\n    }\n    const signal = controller.signal;\n    signal.clear = clear;\n    return signal;\n}\n//# sourceMappingURL=index.js.map","export var MessageTypes;\n(function (MessageTypes) {\n    MessageTypes[MessageTypes[\"NEW_STREAM\"] = 0] = \"NEW_STREAM\";\n    MessageTypes[MessageTypes[\"MESSAGE_RECEIVER\"] = 1] = \"MESSAGE_RECEIVER\";\n    MessageTypes[MessageTypes[\"MESSAGE_INITIATOR\"] = 2] = \"MESSAGE_INITIATOR\";\n    MessageTypes[MessageTypes[\"CLOSE_RECEIVER\"] = 3] = \"CLOSE_RECEIVER\";\n    MessageTypes[MessageTypes[\"CLOSE_INITIATOR\"] = 4] = \"CLOSE_INITIATOR\";\n    MessageTypes[MessageTypes[\"RESET_RECEIVER\"] = 5] = \"RESET_RECEIVER\";\n    MessageTypes[MessageTypes[\"RESET_INITIATOR\"] = 6] = \"RESET_INITIATOR\";\n})(MessageTypes || (MessageTypes = {}));\nexport const MessageTypeNames = Object.freeze({\n    0: 'NEW_STREAM',\n    1: 'MESSAGE_RECEIVER',\n    2: 'MESSAGE_INITIATOR',\n    3: 'CLOSE_RECEIVER',\n    4: 'CLOSE_INITIATOR',\n    5: 'RESET_RECEIVER',\n    6: 'RESET_INITIATOR'\n});\nexport const InitiatorMessageTypes = Object.freeze({\n    NEW_STREAM: MessageTypes.NEW_STREAM,\n    MESSAGE: MessageTypes.MESSAGE_INITIATOR,\n    CLOSE: MessageTypes.CLOSE_INITIATOR,\n    RESET: MessageTypes.RESET_INITIATOR\n});\nexport const ReceiverMessageTypes = Object.freeze({\n    MESSAGE: MessageTypes.MESSAGE_RECEIVER,\n    CLOSE: MessageTypes.CLOSE_RECEIVER,\n    RESET: MessageTypes.RESET_RECEIVER\n});\n//# sourceMappingURL=message-types.js.map","import { Uint8ArrayList } from 'uint8arraylist';\nimport { MessageTypeNames, MessageTypes } from './message-types.js';\nexport const MAX_MSG_SIZE = 1 << 20; // 1MB\nexport const MAX_MSG_QUEUE_SIZE = 4 << 20; // 4MB\nexport class Decoder {\n    _buffer;\n    _headerInfo;\n    _maxMessageSize;\n    _maxUnprocessedMessageQueueSize;\n    constructor(maxMessageSize = MAX_MSG_SIZE, maxUnprocessedMessageQueueSize = MAX_MSG_QUEUE_SIZE) {\n        this._buffer = new Uint8ArrayList();\n        this._headerInfo = null;\n        this._maxMessageSize = maxMessageSize;\n        this._maxUnprocessedMessageQueueSize = maxUnprocessedMessageQueueSize;\n    }\n    write(chunk) {\n        if (chunk == null || chunk.length === 0) {\n            return [];\n        }\n        this._buffer.append(chunk);\n        if (this._buffer.byteLength > this._maxUnprocessedMessageQueueSize) {\n            throw Object.assign(new Error('unprocessed message queue size too large!'), { code: 'ERR_MSG_QUEUE_TOO_BIG' });\n        }\n        const msgs = [];\n        while (this._buffer.length !== 0) {\n            if (this._headerInfo == null) {\n                try {\n                    this._headerInfo = this._decodeHeader(this._buffer);\n                }\n                catch (err) {\n                    if (err.code === 'ERR_MSG_TOO_BIG') {\n                        throw err;\n                    }\n                    break; // We haven't received enough data yet\n                }\n            }\n            const { id, type, length, offset } = this._headerInfo;\n            const bufferedDataLength = this._buffer.length - offset;\n            if (bufferedDataLength < length) {\n                break; // not enough data yet\n            }\n            const msg = {\n                id,\n                type\n            };\n            if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {\n                msg.data = this._buffer.sublist(offset, offset + length);\n            }\n            msgs.push(msg);\n            this._buffer.consume(offset + length);\n            this._headerInfo = null;\n        }\n        return msgs;\n    }\n    /**\n     * Attempts to decode the message header from the buffer\n     */\n    _decodeHeader(data) {\n        const { value: h, offset } = readVarInt(data);\n        const { value: length, offset: end } = readVarInt(data, offset);\n        const type = h & 7;\n        // @ts-expect-error h is a number not a CODE\n        if (MessageTypeNames[type] == null) {\n            throw new Error(`Invalid type received: ${type}`);\n        }\n        // test message type varint + data length\n        if (length > this._maxMessageSize) {\n            throw Object.assign(new Error('message size too large!'), { code: 'ERR_MSG_TOO_BIG' });\n        }\n        // @ts-expect-error h is a number not a CODE\n        return { id: h >> 3, type, offset: offset + end, length };\n    }\n}\nconst MSB = 0x80;\nconst REST = 0x7F;\nfunction readVarInt(buf, offset = 0) {\n    let res = 0;\n    let shift = 0;\n    let counter = offset;\n    let b;\n    const l = buf.length;\n    do {\n        if (counter >= l || shift > 49) {\n            offset = 0;\n            throw new RangeError('Could not decode varint');\n        }\n        b = buf.get(counter++);\n        res += shift < 28\n            ? (b & REST) << shift\n            : (b & REST) * Math.pow(2, shift);\n        shift += 7;\n    } while (b >= MSB);\n    offset = counter - offset;\n    return {\n        value: res,\n        offset\n    };\n}\n//# sourceMappingURL=decode.js.map","import defer from 'p-defer';\nimport { Uint8ArrayList } from 'uint8arraylist';\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nconst DEFAULT_BATCH_SIZE = 1024 * 1024;\nconst DEFAULT_SERIALIZE = (buf, list) => { list.append(buf); };\nfunction batchedBytes(source, options) {\n    if (isAsyncIterable(source)) {\n        return (async function* () {\n            let buffer = new Uint8ArrayList();\n            let ended = false;\n            let deferred = defer();\n            let size = Number(options?.size ?? DEFAULT_BATCH_SIZE);\n            if (isNaN(size) || size === 0 || size < 0) {\n                size = DEFAULT_BATCH_SIZE;\n            }\n            if (size !== Math.round(size)) {\n                throw new Error('Batch size must be an integer');\n            }\n            const yieldAfter = options?.yieldAfter ?? 0;\n            const serialize = options?.serialize ?? DEFAULT_SERIALIZE;\n            void Promise.resolve().then(async () => {\n                try {\n                    let timeout;\n                    for await (const buf of source) {\n                        // @ts-expect-error - if buf is not `Uint8Array | Uint8ArrayList` we cannot use the default serializer\n                        serialize(buf, buffer);\n                        if (buffer.byteLength >= size) {\n                            clearTimeout(timeout);\n                            deferred.resolve();\n                            continue;\n                        }\n                        timeout = setTimeout(() => {\n                            deferred.resolve();\n                        }, yieldAfter);\n                    }\n                    clearTimeout(timeout);\n                    deferred.resolve();\n                }\n                catch (err) {\n                    deferred.reject(err);\n                }\n                finally {\n                    ended = true;\n                }\n            });\n            while (!ended) { // eslint-disable-line no-unmodified-loop-condition\n                await deferred.promise;\n                deferred = defer();\n                if (buffer.byteLength > 0) {\n                    const b = buffer;\n                    buffer = new Uint8ArrayList();\n                    yield b.subarray();\n                }\n            }\n        })();\n    }\n    return (function* () {\n        const buffer = new Uint8ArrayList();\n        let size = Number(options?.size ?? DEFAULT_BATCH_SIZE);\n        if (isNaN(size) || size === 0 || size < 0) {\n            size = DEFAULT_BATCH_SIZE;\n        }\n        if (size !== Math.round(size)) {\n            throw new Error('Batch size must be an integer');\n        }\n        const serialize = options?.serialize ?? DEFAULT_SERIALIZE;\n        for (const buf of source) {\n            // @ts-expect-error - if buf is not `Uint8Array | Uint8ArrayList` we cannot use the default serializer\n            serialize(buf, buffer);\n            if (buffer.byteLength >= size) {\n                yield buffer.subarray(0, size);\n                buffer.consume(size);\n            }\n        }\n        if (buffer.byteLength > 0) {\n            yield buffer.subarray();\n        }\n    })();\n}\nexport default batchedBytes;\n//# sourceMappingURL=index.js.map","export function allocUnsafe(size) {\n    return new Uint8Array(size);\n}\n//# sourceMappingURL=alloc-unsafe-browser.js.map","import batchedBytes from 'it-batched-bytes';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport varint from 'varint';\nimport { allocUnsafe } from './alloc-unsafe.js';\nimport { MessageTypes } from './message-types.js';\nconst POOL_SIZE = 10 * 1024;\nclass Encoder {\n    _pool;\n    _poolOffset;\n    constructor() {\n        this._pool = allocUnsafe(POOL_SIZE);\n        this._poolOffset = 0;\n    }\n    /**\n     * Encodes the given message and adds it to the passed list\n     */\n    write(msg, list) {\n        const pool = this._pool;\n        let offset = this._poolOffset;\n        varint.encode(msg.id << 3 | msg.type, pool, offset);\n        offset += varint.encode.bytes ?? 0;\n        if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {\n            varint.encode(msg.data.length, pool, offset);\n        }\n        else {\n            varint.encode(0, pool, offset);\n        }\n        offset += varint.encode.bytes ?? 0;\n        const header = pool.subarray(this._poolOffset, offset);\n        if (POOL_SIZE - offset < 100) {\n            this._pool = allocUnsafe(POOL_SIZE);\n            this._poolOffset = 0;\n        }\n        else {\n            this._poolOffset = offset;\n        }\n        list.append(header);\n        if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {\n            list.append(msg.data);\n        }\n    }\n}\nconst encoder = new Encoder();\n/**\n * Encode and yield one or more messages\n */\nexport async function* encode(source, minSendBytes = 0) {\n    if (minSendBytes == null || minSendBytes === 0) {\n        // just send the messages\n        for await (const messages of source) {\n            const list = new Uint8ArrayList();\n            for (const msg of messages) {\n                encoder.write(msg, list);\n            }\n            yield list.subarray();\n        }\n        return;\n    }\n    // batch messages up for sending\n    yield* batchedBytes(source, {\n        size: minSendBytes,\n        serialize: (obj, list) => {\n            for (const m of obj) {\n                encoder.write(m, list);\n            }\n        }\n    });\n}\n//# sourceMappingURL=encode.js.map","import { CodeError } from '@libp2p/interfaces/errors';\nimport { logger } from '@libp2p/logger';\nimport { abortableSource } from 'abortable-iterator';\nimport { anySignal } from 'any-signal';\nimport { pushable } from 'it-pushable';\nimport { Uint8ArrayList } from 'uint8arraylist';\nconst log = logger('libp2p:stream');\nconst ERR_STREAM_RESET = 'ERR_STREAM_RESET';\nconst ERR_STREAM_ABORT = 'ERR_STREAM_ABORT';\nconst ERR_SINK_ENDED = 'ERR_SINK_ENDED';\nconst ERR_DOUBLE_SINK = 'ERR_DOUBLE_SINK';\nfunction isPromise(res) {\n    return res != null && typeof res.then === 'function';\n}\nexport class AbstractStream {\n    id;\n    stat;\n    metadata;\n    source;\n    abortController;\n    resetController;\n    closeController;\n    sourceEnded;\n    sinkEnded;\n    sinkSunk;\n    endErr;\n    streamSource;\n    onEnd;\n    maxDataSize;\n    constructor(init) {\n        this.abortController = new AbortController();\n        this.resetController = new AbortController();\n        this.closeController = new AbortController();\n        this.sourceEnded = false;\n        this.sinkEnded = false;\n        this.sinkSunk = false;\n        this.id = init.id;\n        this.metadata = init.metadata ?? {};\n        this.stat = {\n            direction: init.direction,\n            timeline: {\n                open: Date.now()\n            }\n        };\n        this.maxDataSize = init.maxDataSize;\n        this.onEnd = init.onEnd;\n        this.source = this.streamSource = pushable({\n            onEnd: () => {\n                // already sent a reset message\n                if (this.stat.timeline.reset !== null) {\n                    const res = this.sendCloseRead();\n                    if (isPromise(res)) {\n                        res.catch(err => {\n                            log.error('error while sending close read', err);\n                        });\n                    }\n                }\n                this.onSourceEnd();\n            }\n        });\n        // necessary because the libp2p upgrader wraps the sink function\n        this.sink = this.sink.bind(this);\n    }\n    onSourceEnd(err) {\n        if (this.sourceEnded) {\n            return;\n        }\n        this.stat.timeline.closeRead = Date.now();\n        this.sourceEnded = true;\n        log.trace('%s stream %s source end - err: %o', this.stat.direction, this.id, err);\n        if (err != null && this.endErr == null) {\n            this.endErr = err;\n        }\n        if (this.sinkEnded) {\n            this.stat.timeline.close = Date.now();\n            if (this.onEnd != null) {\n                this.onEnd(this.endErr);\n            }\n        }\n    }\n    onSinkEnd(err) {\n        if (this.sinkEnded) {\n            return;\n        }\n        this.stat.timeline.closeWrite = Date.now();\n        this.sinkEnded = true;\n        log.trace('%s stream %s sink end - err: %o', this.stat.direction, this.id, err);\n        if (err != null && this.endErr == null) {\n            this.endErr = err;\n        }\n        if (this.sourceEnded) {\n            this.stat.timeline.close = Date.now();\n            if (this.onEnd != null) {\n                this.onEnd(this.endErr);\n            }\n        }\n    }\n    // Close for both Reading and Writing\n    close() {\n        log.trace('%s stream %s close', this.stat.direction, this.id);\n        this.closeRead();\n        this.closeWrite();\n    }\n    // Close for reading\n    closeRead() {\n        log.trace('%s stream %s closeRead', this.stat.direction, this.id);\n        if (this.sourceEnded) {\n            return;\n        }\n        this.streamSource.end();\n    }\n    // Close for writing\n    closeWrite() {\n        log.trace('%s stream %s closeWrite', this.stat.direction, this.id);\n        if (this.sinkEnded) {\n            return;\n        }\n        this.closeController.abort();\n        try {\n            // need to call this here as the sink method returns in the catch block\n            // when the close controller is aborted\n            const res = this.sendCloseWrite();\n            if (isPromise(res)) {\n                res.catch(err => {\n                    log.error('error while sending close write', err);\n                });\n            }\n        }\n        catch (err) {\n            log.trace('%s stream %s error sending close', this.stat.direction, this.id, err);\n        }\n        this.onSinkEnd();\n    }\n    // Close for reading and writing (local error)\n    abort(err) {\n        log.trace('%s stream %s abort', this.stat.direction, this.id, err);\n        // End the source with the passed error\n        this.streamSource.end(err);\n        this.abortController.abort();\n        this.onSinkEnd(err);\n    }\n    // Close immediately for reading and writing (remote error)\n    reset() {\n        const err = new CodeError('stream reset', ERR_STREAM_RESET);\n        this.resetController.abort();\n        this.streamSource.end(err);\n        this.onSinkEnd(err);\n    }\n    async sink(source) {\n        if (this.sinkSunk) {\n            throw new CodeError('sink already called on stream', ERR_DOUBLE_SINK);\n        }\n        this.sinkSunk = true;\n        if (this.sinkEnded) {\n            throw new CodeError('stream closed for writing', ERR_SINK_ENDED);\n        }\n        const signal = anySignal([\n            this.abortController.signal,\n            this.resetController.signal,\n            this.closeController.signal\n        ]);\n        try {\n            source = abortableSource(source, signal);\n            if (this.stat.direction === 'outbound') { // If initiator, open a new stream\n                const res = this.sendNewStream();\n                if (isPromise(res)) {\n                    await res;\n                }\n            }\n            for await (let data of source) {\n                while (data.length > 0) {\n                    if (data.length <= this.maxDataSize) {\n                        const res = this.sendData(data instanceof Uint8Array ? new Uint8ArrayList(data) : data);\n                        if (isPromise(res)) { // eslint-disable-line max-depth\n                            await res;\n                        }\n                        break;\n                    }\n                    data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data;\n                    const res = this.sendData(data.sublist(0, this.maxDataSize));\n                    if (isPromise(res)) {\n                        await res;\n                    }\n                    data.consume(this.maxDataSize);\n                }\n            }\n        }\n        catch (err) {\n            if (err.type === 'aborted' && err.message === 'The operation was aborted') {\n                if (this.closeController.signal.aborted) {\n                    return;\n                }\n                if (this.resetController.signal.aborted) {\n                    err.message = 'stream reset';\n                    err.code = ERR_STREAM_RESET;\n                }\n                if (this.abortController.signal.aborted) {\n                    err.message = 'stream aborted';\n                    err.code = ERR_STREAM_ABORT;\n                }\n            }\n            // Send no more data if this stream was remotely reset\n            if (err.code === ERR_STREAM_RESET) {\n                log.trace('%s stream %s reset', this.stat.direction, this.id);\n            }\n            else {\n                log.trace('%s stream %s error', this.stat.direction, this.id, err);\n                try {\n                    const res = this.sendReset();\n                    if (isPromise(res)) {\n                        await res;\n                    }\n                    this.stat.timeline.reset = Date.now();\n                }\n                catch (err) {\n                    log.trace('%s stream %s error sending reset', this.stat.direction, this.id, err);\n                }\n            }\n            this.streamSource.end(err);\n            this.onSinkEnd(err);\n            throw err;\n        }\n        finally {\n            signal.clear();\n        }\n        try {\n            const res = this.sendCloseWrite();\n            if (isPromise(res)) {\n                await res;\n            }\n        }\n        catch (err) {\n            log.trace('%s stream %s error sending close', this.stat.direction, this.id, err);\n        }\n        this.onSinkEnd();\n    }\n    /**\n     * When an extending class reads data from it's implementation-specific source,\n     * call this method to allow the stream consumer to read the data.\n     */\n    sourcePush(data) {\n        this.streamSource.push(data);\n    }\n    /**\n     * Returns the amount of unread data - can be used to prevent large amounts of\n     * data building up when the stream consumer is too slow.\n     */\n    sourceReadableLength() {\n        return this.streamSource.readableLength;\n    }\n}\n//# sourceMappingURL=stream.js.map","import { AbstractStream } from '@libp2p/interface-stream-muxer/stream';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { MAX_MSG_SIZE } from './decode.js';\nimport { InitiatorMessageTypes, ReceiverMessageTypes } from './message-types.js';\nclass MplexStream extends AbstractStream {\n    name;\n    streamId;\n    send;\n    types;\n    constructor(init) {\n        super(init);\n        this.types = init.direction === 'outbound' ? InitiatorMessageTypes : ReceiverMessageTypes;\n        this.send = init.send;\n        this.name = init.name;\n        this.streamId = init.streamId;\n    }\n    sendNewStream() {\n        this.send({ id: this.streamId, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(uint8ArrayFromString(this.name)) });\n    }\n    sendData(data) {\n        this.send({ id: this.streamId, type: this.types.MESSAGE, data });\n    }\n    sendReset() {\n        this.send({ id: this.streamId, type: this.types.RESET });\n    }\n    sendCloseWrite() {\n        this.send({ id: this.streamId, type: this.types.CLOSE });\n    }\n    sendCloseRead() {\n        // mplex does not support close read, only close write\n    }\n}\nexport function createStream(options) {\n    const { id, name, send, onEnd, type = 'initiator', maxMsgSize = MAX_MSG_SIZE } = options;\n    return new MplexStream({\n        id: type === 'initiator' ? (`i${id}`) : `r${id}`,\n        streamId: id,\n        name: `${name == null ? id : name}`,\n        direction: type === 'initiator' ? 'outbound' : 'inbound',\n        maxDataSize: maxMsgSize,\n        onEnd,\n        send\n    });\n}\n//# sourceMappingURL=stream.js.map","import { CodeError } from '@libp2p/interfaces/errors';\nimport { logger } from '@libp2p/logger';\nimport { abortableSource } from 'abortable-iterator';\nimport { anySignal } from 'any-signal';\nimport { pushableV } from 'it-pushable';\nimport { RateLimiterMemory } from 'rate-limiter-flexible';\nimport { toString as uint8ArrayToString } from 'uint8arrays';\nimport { Decoder } from './decode.js';\nimport { encode } from './encode.js';\nimport { MessageTypes, MessageTypeNames } from './message-types.js';\nimport { createStream } from './stream.js';\nconst log = logger('libp2p:mplex');\nconst MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;\nconst MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;\nconst MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4; // 4MB\nconst DISCONNECT_THRESHOLD = 5;\nfunction printMessage(msg) {\n    const output = {\n        ...msg,\n        type: `${MessageTypeNames[msg.type]} (${msg.type})`\n    };\n    if (msg.type === MessageTypes.NEW_STREAM) {\n        output.data = uint8ArrayToString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());\n    }\n    if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {\n        output.data = uint8ArrayToString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), 'base16');\n    }\n    return output;\n}\nexport class MplexStreamMuxer {\n    protocol = '/mplex/6.7.0';\n    sink;\n    source;\n    _streamId;\n    _streams;\n    _init;\n    _source;\n    closeController;\n    rateLimiter;\n    constructor(init) {\n        init = init ?? {};\n        this._streamId = 0;\n        this._streams = {\n            /**\n             * Stream to ids map\n             */\n            initiators: new Map(),\n            /**\n             * Stream to ids map\n             */\n            receivers: new Map()\n        };\n        this._init = init;\n        /**\n         * An iterable sink\n         */\n        this.sink = this._createSink();\n        /**\n         * An iterable source\n         */\n        const source = this._createSource();\n        this._source = source;\n        this.source = source;\n        /**\n         * Close controller\n         */\n        this.closeController = new AbortController();\n        this.rateLimiter = new RateLimiterMemory({\n            points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,\n            duration: 1\n        });\n    }\n    /**\n     * Returns a Map of streams and their ids\n     */\n    get streams() {\n        // Inbound and Outbound streams may have the same ids, so we need to make those unique\n        const streams = [];\n        for (const stream of this._streams.initiators.values()) {\n            streams.push(stream);\n        }\n        for (const stream of this._streams.receivers.values()) {\n            streams.push(stream);\n        }\n        return streams;\n    }\n    /**\n     * Initiate a new stream with the given name. If no name is\n     * provided, the id of the stream will be used.\n     */\n    newStream(name) {\n        if (this.closeController.signal.aborted) {\n            throw new Error('Muxer already closed');\n        }\n        const id = this._streamId++;\n        name = name == null ? id.toString() : name.toString();\n        const registry = this._streams.initiators;\n        return this._newStream({ id, name, type: 'initiator', registry });\n    }\n    /**\n     * Close or abort all tracked streams and stop the muxer\n     */\n    close(err) {\n        if (this.closeController.signal.aborted)\n            return;\n        if (err != null) {\n            this.streams.forEach(s => { s.abort(err); });\n        }\n        else {\n            this.streams.forEach(s => { s.close(); });\n        }\n        this.closeController.abort();\n    }\n    /**\n     * Called whenever an inbound stream is created\n     */\n    _newReceiverStream(options) {\n        const { id, name } = options;\n        const registry = this._streams.receivers;\n        return this._newStream({ id, name, type: 'receiver', registry });\n    }\n    _newStream(options) {\n        const { id, name, type, registry } = options;\n        log('new %s stream %s', type, id);\n        if (type === 'initiator' && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {\n            throw new CodeError('Too many outbound streams open', 'ERR_TOO_MANY_OUTBOUND_STREAMS');\n        }\n        if (registry.has(id)) {\n            throw new Error(`${type} stream ${id} already exists!`);\n        }\n        const send = (msg) => {\n            if (log.enabled) {\n                log.trace('%s stream %s send', type, id, printMessage(msg));\n            }\n            this._source.push(msg);\n        };\n        const onEnd = () => {\n            log('%s stream with id %s and protocol %s ended', type, id, stream.stat.protocol);\n            registry.delete(id);\n            if (this._init.onStreamEnd != null) {\n                this._init.onStreamEnd(stream);\n            }\n        };\n        const stream = createStream({ id, name, send, type, onEnd, maxMsgSize: this._init.maxMsgSize });\n        registry.set(id, stream);\n        return stream;\n    }\n    /**\n     * Creates a sink with an abortable source. Incoming messages will\n     * also have their size restricted. All messages will be varint decoded.\n     */\n    _createSink() {\n        const sink = async (source) => {\n            const signal = anySignal([this.closeController.signal, this._init.signal]);\n            try {\n                source = abortableSource(source, signal);\n                const decoder = new Decoder(this._init.maxMsgSize, this._init.maxUnprocessedMessageQueueSize);\n                for await (const chunk of source) {\n                    for (const msg of decoder.write(chunk)) {\n                        await this._handleIncoming(msg);\n                    }\n                }\n                this._source.end();\n            }\n            catch (err) {\n                log('error in sink', err);\n                this._source.end(err); // End the source with an error\n            }\n            finally {\n                signal.clear();\n            }\n        };\n        return sink;\n    }\n    /**\n     * Creates a source that restricts outgoing message sizes\n     * and varint encodes them\n     */\n    _createSource() {\n        const onEnd = (err) => {\n            this.close(err);\n        };\n        const source = pushableV({\n            objectMode: true,\n            onEnd\n        });\n        return Object.assign(encode(source, this._init.minSendBytes), {\n            push: source.push,\n            end: source.end,\n            return: source.return\n        });\n    }\n    async _handleIncoming(message) {\n        const { id, type } = message;\n        if (log.enabled) {\n            log.trace('incoming message', printMessage(message));\n        }\n        // Create a new stream?\n        if (message.type === MessageTypes.NEW_STREAM) {\n            if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {\n                log('too many inbound streams open');\n                // not going to allow this stream, send the reset message manually\n                // instead of setting it up just to tear it down\n                this._source.push({\n                    id,\n                    type: MessageTypes.RESET_RECEIVER\n                });\n                // if we've hit our stream limit, and the remote keeps trying to open\n                // more new streams, if they are doing this very quickly maybe they\n                // are attacking us and we should close the connection\n                try {\n                    await this.rateLimiter.consume('new-stream', 1);\n                }\n                catch {\n                    log('rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection');\n                    // since there's no backpressure in mplex, the only thing we can really do to protect ourselves is close the connection\n                    this._source.end(new Error('Too many open streams'));\n                    return;\n                }\n                return;\n            }\n            const stream = this._newReceiverStream({ id, name: uint8ArrayToString(message.data instanceof Uint8Array ? message.data : message.data.subarray()) });\n            if (this._init.onIncomingStream != null) {\n                this._init.onIncomingStream(stream);\n            }\n            return;\n        }\n        const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;\n        const stream = list.get(id);\n        if (stream == null) {\n            log('missing stream %s for message type %s', id, MessageTypeNames[type]);\n            return;\n        }\n        const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE;\n        switch (type) {\n            case MessageTypes.MESSAGE_INITIATOR:\n            case MessageTypes.MESSAGE_RECEIVER:\n                if (stream.sourceReadableLength() > maxBufferSize) {\n                    // Stream buffer has got too large, reset the stream\n                    this._source.push({\n                        id: message.id,\n                        type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR\n                    });\n                    // Inform the stream consumer they are not fast enough\n                    const error = new CodeError('Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers', 'ERR_STREAM_INPUT_BUFFER_FULL');\n                    stream.abort(error);\n                    return;\n                }\n                // We got data from the remote, push it into our local stream\n                stream.sourcePush(message.data);\n                break;\n            case MessageTypes.CLOSE_INITIATOR:\n            case MessageTypes.CLOSE_RECEIVER:\n                // We should expect no more data from the remote, stop reading\n                stream.closeRead();\n                break;\n            case MessageTypes.RESET_INITIATOR:\n            case MessageTypes.RESET_RECEIVER:\n                // Stop reading and writing to the stream immediately\n                stream.reset();\n                break;\n            default:\n                log('unknown message type %s', type);\n        }\n    }\n}\n//# sourceMappingURL=mplex.js.map","import { MplexStreamMuxer } from './mplex.js';\nclass Mplex {\n    protocol = '/mplex/6.7.0';\n    _init;\n    constructor(init = {}) {\n        this._init = init;\n    }\n    createStreamMuxer(init = {}) {\n        return new MplexStreamMuxer({\n            ...init,\n            ...this._init\n        });\n    }\n}\nexport function mplex(init = {}) {\n    return () => new Mplex(init);\n}\n//# sourceMappingURL=index.js.map","export const symbol = Symbol.for('@libp2p/transport');\nexport function isTransport(other) {\n    return other != null && Boolean(other[symbol]);\n}\n/**\n * Enum Transport Manager Fault Tolerance values\n */\nexport var FaultTolerance;\n(function (FaultTolerance) {\n    /**\n     * should be used for failing in any listen circumstance\n     */\n    FaultTolerance[FaultTolerance[\"FATAL_ALL\"] = 0] = \"FATAL_ALL\";\n    /**\n     * should be used for not failing when not listening\n     */\n    FaultTolerance[FaultTolerance[\"NO_FATAL\"] = 1] = \"NO_FATAL\";\n})(FaultTolerance || (FaultTolerance = {}));\n//# sourceMappingURL=index.js.map","import { isBrowser, isElectronMain, isElectronRenderer, isNode, isWebWorker, } from \"wherearewe\";\nimport { mplex } from \"@libp2p/mplex\";\nimport { create } from \"ipfs-core\";\nimport { noise } from \"@chainsafe/libp2p-noise\";\nimport mergeOptions from \"merge-options\";\nimport { FaultTolerance } from \"@libp2p/interface-transport\";\nconst obtConfigPlateforme = async () => {\n    let configPlateforme;\n    if (isBrowser || isElectronRenderer) {\n        configPlateforme = (await import(\"./configNavigateur.js\")).default;\n    }\n    else if (isWebWorker) {\n        configPlateforme = (await import(\"./configTravailleur.js\")).default;\n    }\n    else if (isElectronMain) {\n        configPlateforme = (await import(\"./config\\u00C9lectronPrincipal.js\"))\n            .default;\n    }\n    else if (isNode) {\n        configPlateforme = (await import(\"./configNode.js\")).default;\n    }\n    else {\n        console.warn(\"Plateforme non reconnue. On utilisera la configuration navigateur.\");\n        configPlateforme = (await import(\"./configNavigateur.js\")).default;\n    }\n    return configPlateforme;\n};\n// https://github.com/libp2p/js-libp2p-webrtc-direct/issues/98\nconst obtConfigCommun = () => {\n    return {\n        libp2p: {\n            streamMuxers: [mplex()],\n            connectionEncryption: [noise()],\n            transportManager: {\n                faultTolerance: FaultTolerance.NO_FATAL,\n            },\n        },\n        relay: { enabled: true, hop: { enabled: true, active: true } },\n    };\n};\nexport default async function initSFIP(dir = \"./constl/sfip\") {\n    const config = obtConfigCommun();\n    const configPlateforme = await obtConfigPlateforme();\n    config.repo = dir;\n    const configFinale = mergeOptions(config, configPlateforme);\n    return await create(configFinale);\n}\n//# sourceMappingURL=index.js.map"],"file":"index-4ab19f7f.js"}