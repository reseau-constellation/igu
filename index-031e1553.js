import{D as _t,c as R,a as we,b as I,e as ee,d as z,f as vt,w as Je,s as Te,x as ye,g as te,m as Qe,h as Ze,i as et,u as Et,j as tt,k as xt,l as St,t as K,_ as ve,n as At,o as Ct,p as Lt,q as Pt}from"./index-1b8ce02e.js";const kt=async r=>await new _t().spawn(r);var p={};p.MediaStream=window.MediaStream;p.MediaStreamTrack=window.MediaStreamTrack;p.RTCDataChannel=window.RTCDataChannel;p.RTCDataChannelEvent=window.RTCDataChannelEvent;p.RTCDtlsTransport=window.RTCDtlsTransport;p.RTCIceCandidate=window.RTCIceCandidate;p.RTCIceTransport=window.RTCIceTransport;p.RTCPeerConnection=window.RTCPeerConnection;p.RTCPeerConnectionIceEvent=window.RTCPeerConnectionIceEvent;p.RTCRtpReceiver=window.RTCRtpReceiver;p.RTCRtpSender=window.RTCRtpSender;p.RTCRtpTransceiver=window.RTCRtpTransceiver;p.RTCSctpTransport=window.RTCSctpTransport;p.RTCSessionDescription=window.RTCSessionDescription;p.getUserMedia=window.getUserMedia;p.mediaDevices=navigator.mediaDevices;const nt=Symbol.for("@achingbrain/uint8arraylist");function Me(r,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const n of r){const s=t+n.byteLength;if(e<s)return{buf:n,index:e-t};t=s}throw new RangeError("index is out of bounds")}function J(r){return Boolean(r?.[nt])}class T{constructor(...e){Object.defineProperty(this,nt,{value:!0}),this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const n of e)if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.push(n);else if(J(n))t+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const n of e.reverse())if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.unshift(n);else if(J(n))t+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=Me(this.bufs,e);return t.buf[t.index]}set(e,t){const n=Me(this.bufs,e);n.buf[n.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let n=0;n<e.length;n++)this.set(t+n,e[n]);else if(J(e))for(let n=0;n<e.length;n++)this.set(t+n,e.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:n,length:s}=this._subList(e,t);return R(n,s)}subarray(e,t){const{bufs:n,length:s}=this._subList(e,t);return n.length===1?n[0]:R(n,s)}sublist(e,t){const{bufs:n,length:s}=this._subList(e,t),i=new T;return i.length=s,i.bufs=n,i}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:[...this.bufs],length:this.length};const n=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,e>=c)continue;const d=e>=a&&e<c,u=t>a&&t<=c;if(d&&u){if(e===a&&t===c){n.push(o);break}const f=e-a;n.push(o.subarray(f,f+(t-e)));break}if(d){if(e===0){n.push(o);continue}n.push(o.subarray(e-a));continue}if(u){if(t===c){n.push(o);break}n.push(o.subarray(0,t-a));break}n.push(o)}return{bufs:n,length:t-e}}indexOf(e,t=0){if(!J(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const s=n.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let f=0;f<i;f++)o[f]=-1;for(let f=0;f<s;f++)o[n[f]]=f;const a=o,c=this.byteLength-n.byteLength,d=n.byteLength-1;let u;for(let f=t;f<=c;f+=u){u=0;for(let m=d;m>=0;m--){const N=this.get(f+m);if(n[m]!==N){u=Math.max(1,m-a[N]);break}}if(u===0)return f}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const n=we(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,t),this.write(n,e)}getInt16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,t)}setInt16(e,t,n){const s=I(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,t,n),this.write(s,e)}getInt32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,t)}setInt32(e,t,n){const s=I(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,t,n),this.write(s,e)}getBigInt64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,t)}setBigInt64(e,t,n){const s=I(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,t,n),this.write(s,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const n=we(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,t),this.write(n,e)}getUint16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,t)}setUint16(e,t,n){const s=I(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,t,n),this.write(s,e)}getUint32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,t)}setUint32(e,t,n){const s=I(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,t,n),this.write(s,e)}getBigUint64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,t)}setBigUint64(e,t,n){const s=I(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,t,n),this.write(s,e)}getFloat32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,t)}setFloat32(e,t,n){const s=I(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,t,n),this.write(s,e)}getFloat64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,t)}setFloat64(e,t,n){const s=I(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,t,n),this.write(s,e)}equals(e){if(e==null||!(e instanceof T)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!ee(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const n=new T;return n.bufs=e,t==null&&(t=e.reduce((s,i)=>s+i.byteLength,0)),n.length=t,n}}function Ut(r){const e=async function*(){let t=yield,n=new T;for await(const s of r){if(t==null){n.append(s),t=yield n,n=new T;continue}for(n.append(s);n.length>=t;){const i=n.sublist(0,t);if(n.consume(t),t=yield i,t==null){n.length>0&&(t=yield n,n=new T);break}}}if(t!=null)throw Object.assign(new Error(`stream ended before ${t} bytes became available`),{code:"ERR_UNDER_READ",buffer:n})}();return e.next(),e}class Ie{constructor(e){if(!(e>0)||e-1&e)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}class pe{constructor(e={}){this.hwm=e.splitLimit??16,this.head=new Ie(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return e?.byteLength!=null?e.byteLength:1}push(e){if(e?.value!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new Ie(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return e?.value!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}function Ee(r={}){return rt(t=>{const n=t.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function as(r={}){return rt(t=>{let n;const s=[];for(;!t.isEmpty()&&(n=t.shift(),n!=null);){if(n.error!=null)throw n.error;n.done===!1&&s.push(n.value)}return n==null?{done:!0}:{done:n.done===!0,value:s}},r)}function rt(r,e){e=e??{};let t=e.onEnd,n=new pe,s,i,o;const a=async()=>n.isEmpty()?o?{done:!0}:await new Promise((h,k)=>{i=b=>{i=null,n.push(b);try{h(r(n))}catch(_){k(_)}return s}}):r(n),c=h=>i!=null?i(h):(n.push(h),s),d=h=>(n=new pe,i!=null?i({error:h}):(n.push({error:h}),s)),u=h=>{if(o)return s;if(e?.objectMode!==!0&&h?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return c({done:!1,value:h})},f=h=>o?s:(o=!0,h!=null?d(h):c({done:!0})),m=()=>(n=new pe,f(),{done:!0}),N=h=>(f(h),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:a,return:m,throw:N,push:u,end:f,get readableLength(){return n.size}},t==null)return s;const l=s;return s={[Symbol.asyncIterator](){return this},next(){return l.next()},throw(h){return l.throw(h),t!=null&&(t(h),t=void 0),{done:!0}},return(){return l.return(),t!=null&&(t(),t=void 0),{done:!0}},push:u,end(h){return l.end(h),t!=null&&(t(h),t=void 0),s},get readableLength(){return l.readableLength}},s}function st(){const r={};return r.promise=new Promise((e,t)=>{r.resolve=e,r.reject=t}),r}function Tt(r){const e=Ee(),t=Ut(r.source),n=st();let s;const i=r.sink(async function*(){yield*e,yield*await n.promise}());return i.catch(a=>{s=a}),{reader:t,writer:e,stream:{sink:async a=>s!=null?await Promise.reject(s):(n.resolve(a),await i),source:t},rest:()=>e.end(),write:e.push,read:async()=>{const a=await t.next();if(a.value!=null)return a.value}}}function Ke(r){return r instanceof Uint8Array?{get(e){return r[e]},set(e,t){r[e]=t}}:{get(e){return r.get(e)},set(e,t){r.set(e,t)}}}const De=4294967296;class P{constructor(e=0,t=0){this.hi=e,this.lo=t}toBigInt(e){if(e===!0)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(BigInt(t)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toNumber(e){return Number(this.toBigInt(e))}zzDecode(){const e=-(this.lo&1),t=((this.lo>>>1|this.hi<<31)^e)>>>0,n=(this.hi>>>1^e)>>>0;return new P(n,t)}zzEncode(){const e=this.hi>>31,t=((this.hi<<1|this.lo>>>31)^e)>>>0,n=(this.lo<<1^e)>>>0;return new P(t,n)}toBytes(e,t=0){const n=Ke(e);for(;this.hi>0;)n.set(t++,this.lo&127|128),this.lo=(this.lo>>>7|this.hi<<25)>>>0,this.hi>>>=7;for(;this.lo>127;)n.set(t++,this.lo&127|128),this.lo=this.lo>>>7;n.set(t++,this.lo)}static fromBigInt(e){if(e===0n)return new P;const t=e<0;t&&(e=-e);let n=Number(e>>32n)|0,s=Number(e-(BigInt(n)<<32n))|0;return t&&(n=~n>>>0,s=~s>>>0,++s>De&&(s=0,++n>De&&(n=0))),new P(n,s)}static fromNumber(e){if(e===0)return new P;const t=e<0;t&&(e=-e);let n=e>>>0,s=(e-n)/4294967296>>>0;return t&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new P(s,n)}static fromBytes(e,t=0){const n=Ke(e),s=new P;let i=0;if(e.length-t>4){for(;i<4;++i)if(s.lo=(s.lo|(n.get(t)&127)<<i*7)>>>0,n.get(t++)<128)return s;if(s.lo=(s.lo|(n.get(t)&127)<<28)>>>0,s.hi=(s.hi|(n.get(t)&127)>>4)>>>0,n.get(t++)<128)return s;i=0}else for(;i<4;++i){if(t>=e.length)throw RangeError(`index out of range: ${t} > ${e.length}`);if(s.lo=(s.lo|(n.get(t)&127)<<i*7)>>>0,n.get(t++)<128)return s}if(e.length-t>4){for(;i<5;++i)if(s.hi=(s.hi|(n.get(t)&127)<<i*7+3)>>>0,n.get(t++)<128)return s}else if(t<e.byteLength)for(;i<5;++i){if(t>=e.length)throw RangeError(`index out of range: ${t} > ${e.length}`);if(s.hi=(s.hi|(n.get(t)&127)<<i*7+3)>>>0,n.get(t++)<128)return s}throw RangeError("invalid varint encoding")}}const Mt=Math.pow(2,7),It=Math.pow(2,14),Kt=Math.pow(2,21),Dt=Math.pow(2,28),Rt=Math.pow(2,35),Nt=Math.pow(2,42),Ot=Math.pow(2,49),Ht=Math.pow(2,56),Bt=Math.pow(2,63),V={encodingLength(r){return r<Mt?1:r<It?2:r<Kt?3:r<Dt?4:r<Rt?5:r<Nt?6:r<Ot?7:r<Ht?8:r<Bt?9:10},encode(r,e,t=0){if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return e==null&&(e=we(V.encodingLength(r))),P.fromNumber(r).toBytes(e,t),e},decode(r,e=0){return P.fromBytes(r,e).toNumber(!0)}};function zt(r){return globalThis?.Buffer?.allocUnsafe!=null?globalThis.Buffer.allocUnsafe(r):new Uint8Array(r)}const le=r=>{const e=V.encodingLength(r),t=zt(e);return V.encode(r,t),le.bytes=e,t};le.bytes=0;function it(r){r=r??{};const e=r.lengthEncoder??le;return async function*(n){for await(const s of n){const i=e(s.byteLength);i instanceof Uint8Array?yield i:yield*i,s instanceof Uint8Array?yield s:yield*s}}}it.single=(r,e)=>{e=e??{};const t=e.lengthEncoder??le;return new T(t(r.byteLength),r)};const $t=8,Vt=1024*1024*4;var D;(function(r){r[r.LENGTH=0]="LENGTH",r[r.DATA=1]="DATA"})(D||(D={}));const xe=r=>{const e=V.decode(r);return xe.bytes=V.encodingLength(e),e};xe.bytes=0;function ne(r){return async function*(t){const n=new T;let s=D.LENGTH,i=-1;const o=r?.lengthDecoder??xe,a=r?.maxLengthLength??$t,c=r?.maxDataLength??Vt;for await(const d of t)for(n.append(d);n.byteLength>0;){if(s===D.LENGTH)try{if(i=o(n),i<0)throw z(new Error("invalid message length"),"ERR_INVALID_MSG_LENGTH");if(i>c)throw z(new Error("message length too long"),"ERR_MSG_DATA_TOO_LONG");const u=o.bytes;n.consume(u),r?.onLength!=null&&r.onLength(i),s=D.DATA}catch(u){if(u instanceof RangeError){if(n.byteLength>a)throw z(new Error("message length length too long"),"ERR_MSG_LENGTH_TOO_LONG");break}throw u}if(s===D.DATA){if(n.byteLength<i)break;const u=n.sublist(0,i);n.consume(i),r?.onData!=null&&r.onData(u),yield u,s=D.LENGTH}}if(n.byteLength>0)throw z(new Error("unexpected end of input"),"ERR_UNEXPECTED_EOF")}}ne.fromReader=(r,e)=>{let t=1;const n=async function*(){for(;;)try{const{done:i,value:o}=await r.next(t);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{t=1}}();return ne({...e??{},onLength:i=>{t=i}})(n)};function Re(r,e={}){const t=Tt(r),n=ne.fromReader(t.reader,e),s={read:async i=>{const{value:o}=await t.reader.next(i);if(o==null)throw new Error("Value is null");return o},readLP:async()=>{const{value:i}=await n.next();if(i==null)throw new Error("Value is null");return i},readPB:async i=>{const o=await s.readLP();if(o==null)throw new Error("Value is null");const a=o instanceof Uint8Array?o:o.subarray();return i.decode(a)},write:i=>{i instanceof Uint8Array?t.writer.push(i):t.writer.push(i.subarray())},writeLP:i=>{s.write(it.single(i,e))},writePB:(i,o)=>{s.writeLP(o.encode(i))},pb:i=>({read:async()=>await s.readPB(i),write:o=>s.writePB(o,i)}),unwrap:()=>(t.rest(),t.stream)};return s}function Ne(){const r=st();let e=!1;return{sink:async t=>{if(e)throw new Error("already piped");e=!0,r.resolve(t)},source:async function*(){yield*await r.promise}()}}function Ft(){const r=Ne(),e=Ne();return[{source:r.source,sink:e.sink},{source:e.source,sink:r.sink}]}async function*jt(...r){const e=Ee({objectMode:!0});Promise.resolve().then(async()=>{try{await Promise.all(r.map(async t=>{for await(const n of t)e.push(n)})),e.end()}catch(t){e.end(t)}}),yield*e}const Xt=(...r)=>{let e;for(;r.length>0;)e=r.shift()(e);return e},ot=r=>r!=null&&(typeof r[Symbol.asyncIterator]=="function"||typeof r[Symbol.iterator]=="function"||typeof r.next=="function"),ge=r=>r!=null&&typeof r.sink=="function"&&ot(r.source),Gt=r=>e=>{const t=r.sink(e);if(t.then!=null){const n=Ee({objectMode:!0});return t.then(()=>{n.end()},i=>{n.end(i)}),jt(n,async function*(){yield*r.source,n.end()}())}return r.source};function qt(r,...e){if(ge(r)){const n=r;r=()=>n.source}else if(ot(r)){const n=r;r=()=>n}const t=[r,...e];if(t.length>1&&ge(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let n=1;n<t.length-1;n++)ge(t[n])&&(t[n]=Gt(t[n]));return Xt(...t)}const F=65535,Oe=F-16,Wt=Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS);var at={},j={},Se={};Object.defineProperty(Se,"__esModule",{value:!0});function Yt(r){return typeof r.saveState<"u"&&typeof r.restoreState<"u"&&typeof r.cleanSavedState<"u"}Se.isSerializableHash=Yt;Object.defineProperty(j,"__esModule",{value:!0});var L=Se,Jt=vt,Qt=Je,ct=function(){function r(e,t){this._finished=!1,this._inner=new e,this._outer=new e,this.blockSize=this._outer.blockSize,this.digestLength=this._outer.digestLength;var n=new Uint8Array(this.blockSize);t.length>this.blockSize?this._inner.update(t).finish(n).clean():n.set(t);for(var s=0;s<n.length;s++)n[s]^=54;this._inner.update(n);for(var s=0;s<n.length;s++)n[s]^=106;this._outer.update(n),L.isSerializableHash(this._inner)&&L.isSerializableHash(this._outer)&&(this._innerKeyedState=this._inner.saveState(),this._outerKeyedState=this._outer.saveState()),Qt.wipe(n)}return r.prototype.reset=function(){if(!L.isSerializableHash(this._inner)||!L.isSerializableHash(this._outer))throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");return this._inner.restoreState(this._innerKeyedState),this._outer.restoreState(this._outerKeyedState),this._finished=!1,this},r.prototype.clean=function(){L.isSerializableHash(this._inner)&&this._inner.cleanSavedState(this._innerKeyedState),L.isSerializableHash(this._outer)&&this._outer.cleanSavedState(this._outerKeyedState),this._inner.clean(),this._outer.clean()},r.prototype.update=function(e){return this._inner.update(e),this},r.prototype.finish=function(e){return this._finished?(this._outer.finish(e),this):(this._inner.finish(e),this._outer.update(e.subarray(0,this.digestLength)).finish(e),this._finished=!0,this)},r.prototype.digest=function(){var e=new Uint8Array(this.digestLength);return this.finish(e),e},r.prototype.saveState=function(){if(!L.isSerializableHash(this._inner))throw new Error("hmac: can't saveState() because hash doesn't implement it");return this._inner.saveState()},r.prototype.restoreState=function(e){if(!L.isSerializableHash(this._inner)||!L.isSerializableHash(this._outer))throw new Error("hmac: can't restoreState() because hash doesn't implement it");return this._inner.restoreState(e),this._outer.restoreState(this._outerKeyedState),this._finished=!1,this},r.prototype.cleanSavedState=function(e){if(!L.isSerializableHash(this._inner))throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");this._inner.cleanSavedState(e)},r}();j.HMAC=ct;function Zt(r,e,t){var n=new ct(r,e);n.update(t);var s=n.digest();return n.clean(),s}j.hmac=Zt;j.equal=Jt.equal;Object.defineProperty(at,"__esModule",{value:!0});var He=j,Be=Je,en=function(){function r(e,t,n,s){n===void 0&&(n=new Uint8Array(0)),this._counter=new Uint8Array(1),this._hash=e,this._info=s;var i=He.hmac(this._hash,n,t);this._hmac=new He.HMAC(e,i),this._buffer=new Uint8Array(this._hmac.digestLength),this._bufpos=this._buffer.length}return r.prototype._fillBuffer=function(){this._counter[0]++;var e=this._counter[0];if(e===0)throw new Error("hkdf: cannot expand more");this._hmac.reset(),e>1&&this._hmac.update(this._buffer),this._info&&this._hmac.update(this._info),this._hmac.update(this._counter),this._hmac.finish(this._buffer),this._bufpos=0},r.prototype.expand=function(e){for(var t=new Uint8Array(e),n=0;n<t.length;n++)this._bufpos===this._buffer.length&&this._fillBuffer(),t[n]=this._buffer[this._bufpos++];return t},r.prototype.clean=function(){this._hmac.clean(),Be.wipe(this._buffer),Be.wipe(this._counter),this._bufpos=0},r}(),tn=at.HKDF=en;const nn={hashSHA256(r){return Te.hash(r)},getHKDF(r,e){const s=new tn(Te.SHA256,e,r).expand(96),i=s.subarray(0,32),o=s.subarray(32,64),a=s.subarray(64,96);return[i,o,a]},generateX25519KeyPair(){const r=ye.generateKeyPair();return{publicKey:r.publicKey,privateKey:r.secretKey}},generateX25519KeyPairFromSeed(r){const e=ye.generateKeyPairFromSeed(r);return{publicKey:e.publicKey,privateKey:e.secretKey}},generateX25519SharedKey(r,e){return ye.sharedKey(r,e)},chaCha20Poly1305Encrypt(r,e,t,n){return new te.ChaCha20Poly1305(n).seal(e,r,t)},chaCha20Poly1305Decrypt(r,e,t,n,s){return new te.ChaCha20Poly1305(n).open(e,r,t,s)}},rn=r=>globalThis.Buffer?globalThis.Buffer.allocUnsafe(r):new Uint8Array(r),re=r=>{const e=rn(2);return new DataView(e.buffer,e.byteOffset,e.byteLength).setUint16(0,r,!1),e};re.bytes=2;const Z=r=>{if(r.length<2)throw RangeError("Could not decode int16BE");return r instanceof Uint8Array?new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,!1):r.getUint16(0)};Z.bytes=2;function sn(r){return R([r.ne,r.ciphertext],r.ne.length+r.ciphertext.length)}function on(r){return R([r.ne,r.ns,r.ciphertext],r.ne.length+r.ns.length+r.ciphertext.length)}function an(r){return R([r.ns,r.ciphertext],r.ns.length+r.ciphertext.length)}function cn(r){if(r.length<32)throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");return{ne:r.subarray(0,32),ciphertext:r.subarray(32,r.length),ns:new Uint8Array(0)}}function hn(r){if(r.length<80)throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");return{ne:r.subarray(0,32),ns:r.subarray(32,80),ciphertext:r.subarray(80,r.length)}}function un(r){if(r.length<48)throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");return{ne:new Uint8Array(0),ns:r.subarray(0,48),ciphertext:r.subarray(48,r.length)}}function ln(r,e){return async function*(t){for await(const n of t)for(let s=0;s<n.length;s+=Oe){let i=s+Oe;i>n.length&&(i=n.length);const o=r.encrypt(n.subarray(s,i),r.session);e?.encryptedPackets.increment(),yield re(o.byteLength),yield o}}}function fn(r,e){return async function*(t){for await(const n of t)for(let s=0;s<n.length;s+=F){let i=s+F;if(i>n.length&&(i=n.length),i-te.TAG_LENGTH<s)throw new Error("Invalid chunk");const o=n.subarray(s,i),a=n.subarray(s,i-te.TAG_LENGTH),{plaintext:c,valid:d}=r.decrypt(o,r.session,a);if(!d)throw e?.decryptErrors.increment(),new Error("Failed to validate decrypted chunk");e?.decryptedPackets.increment(),yield c}}}class se extends Error{constructor(e="Unexpected Peer"){super(e),this.code=se.code}static get code(){return"ERR_UNEXPECTED_PEER"}}class O extends Error{constructor(e="Invalid crypto exchange"){super(e),this.code=O.code}static get code(){return"ERR_INVALID_CRYPTO_EXCHANGE"}}var dn=ht,ze=128,yn=127,pn=~yn,gn=Math.pow(2,31);function ht(r,e,t){e=e||[],t=t||0;for(var n=t;r>=gn;)e[t++]=r&255|ze,r/=128;for(;r&pn;)e[t++]=r&255|ze,r>>>=7;return e[t]=r|0,ht.bytes=t-n+1,e}var wn=be,bn=128,$e=127;function be(r,n){var t=0,n=n||0,s=0,i=n,o,a=r.length;do{if(i>=a)throw be.bytes=0,new RangeError("Could not decode varint");o=r[i++],t+=s<28?(o&$e)<<s:(o&$e)*Math.pow(2,s),s+=7}while(o>=bn);return be.bytes=i-n,t}var mn=Math.pow(2,7),_n=Math.pow(2,14),vn=Math.pow(2,21),En=Math.pow(2,28),xn=Math.pow(2,35),Sn=Math.pow(2,42),An=Math.pow(2,49),Cn=Math.pow(2,56),Ln=Math.pow(2,63),Pn=function(r){return r<mn?1:r<_n?2:r<vn?3:r<En?4:r<xn?5:r<Sn?6:r<An?7:r<Cn?8:r<Ln?9:10},kn={encode:dn,decode:wn,encodingLength:Pn},ie=kn;const me=(r,e=0)=>[ie.decode(r,e),ie.decode.bytes],oe=(r,e,t=0)=>(ie.encode(r,e,t),e),ae=r=>ie.encodingLength(r),Un=(r,e)=>{if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0},fe=r=>{if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")},Tn=r=>new TextEncoder().encode(r),Mn=r=>new TextDecoder().decode(r),H=(r,e)=>{const t=e.byteLength,n=ae(r),s=n+ae(t),i=new Uint8Array(s+t);return oe(r,i,0),oe(t,i,n),i.set(e,s),new Ce(r,t,e,i)},Ae=r=>{const e=fe(r),[t,n]=me(e),[s,i]=me(e.subarray(n)),o=e.subarray(n+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new Ce(t,s,o,e)},In=(r,e)=>{if(r===e)return!0;{const t=e;return r.code===t.code&&r.size===t.size&&t.bytes instanceof Uint8Array&&Un(r.bytes,t.bytes)}};class Ce{constructor(e,t,n,s){this.code=e,this.size=t,this.digest=n,this.bytes=s}}function Kn(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var s=0;s<r.length;s++){var i=r.charAt(s),o=i.charCodeAt(0);if(t[o]!==255)throw new TypeError(i+" is ambiguous");t[o]=s}var a=r.length,c=r.charAt(0),d=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function f(l){if(l instanceof Uint8Array||(ArrayBuffer.isView(l)?l=new Uint8Array(l.buffer,l.byteOffset,l.byteLength):Array.isArray(l)&&(l=Uint8Array.from(l))),!(l instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(l.length===0)return"";for(var h=0,k=0,b=0,_=l.length;b!==_&&l[b]===0;)b++,h++;for(var A=(_-b)*u+1>>>0,v=new Uint8Array(A);b!==_;){for(var C=l[b],M=0,x=A-1;(C!==0||M<k)&&x!==-1;x--,M++)C+=256*v[x]>>>0,v[x]=C%a>>>0,C=C/a>>>0;if(C!==0)throw new Error("Non-zero carry");k=M,b++}for(var U=A-k;U!==A&&v[U]===0;)U++;for(var Y=c.repeat(h);U<A;++U)Y+=r.charAt(v[U]);return Y}function m(l){if(typeof l!="string")throw new TypeError("Expected String");if(l.length===0)return new Uint8Array;var h=0;if(l[h]!==" "){for(var k=0,b=0;l[h]===c;)k++,h++;for(var _=(l.length-h)*d+1>>>0,A=new Uint8Array(_);l[h];){var v=t[l.charCodeAt(h)];if(v===255)return;for(var C=0,M=_-1;(v!==0||C<b)&&M!==-1;M--,C++)v+=a*A[M]>>>0,A[M]=v%256>>>0,v=v/256>>>0;if(v!==0)throw new Error("Non-zero carry");b=C,h++}if(l[h]!==" "){for(var x=_-b;x!==_&&A[x]===0;)x++;for(var U=new Uint8Array(k+(_-x)),Y=k;x!==_;)U[Y++]=A[x++];return U}}}function N(l){var h=m(l);if(h)return h;throw new Error(`Non-${e} character`)}return{encode:f,decodeUnsafe:m,decode:N}}var Dn=Kn,Rn=Dn;class Nn{constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class On{constructor(e,t,n){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return ut(this,e)}}class Hn{constructor(e){this.decoders=e}or(e){return ut(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const ut=(r,e)=>new Hn({...r.decoders||{[r.prefix]:r},...e.decoders||{[e.prefix]:e}});class Bn{constructor(e,t,n,s){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=s,this.encoder=new Nn(e,t,n),this.decoder=new On(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const de=({name:r,prefix:e,encode:t,decode:n})=>new Bn(r,e,t,n),X=({prefix:r,name:e,alphabet:t})=>{const{encode:n,decode:s}=Rn(t,e);return de({prefix:r,name:e,encode:n,decode:i=>fe(s(i))})},zn=(r,e,t,n)=>{const s={};for(let u=0;u<e.length;++u)s[e[u]]=u;let i=r.length;for(;r[i-1]==="=";)--i;const o=new Uint8Array(i*t/8|0);let a=0,c=0,d=0;for(let u=0;u<i;++u){const f=s[r[u]];if(f===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<t|f,a+=t,a>=8&&(a-=8,o[d++]=255&c>>a)}if(a>=t||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return o},$n=(r,e,t)=>{const n=e[e.length-1]==="=",s=(1<<t)-1;let i="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>t;)o-=t,i+=e[s&a>>o];if(o&&(i+=e[s&a<<t-o]),n)for(;i.length*t&7;)i+="=";return i},g=({name:r,prefix:e,bitsPerChar:t,alphabet:n})=>de({prefix:e,name:r,encode(s){return $n(s,n,t)},decode(s){return zn(s,n,t,r)}}),S=X({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Vn=X({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),Fn=Object.freeze(Object.defineProperty({__proto__:null,base58btc:S,base58flickr:Vn},Symbol.toStringTag,{value:"Module"})),$=g({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),jn=g({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Xn=g({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Gn=g({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),qn=g({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Wn=g({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Yn=g({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Jn=g({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Qn=g({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),Zn=Object.freeze(Object.defineProperty({__proto__:null,base32:$,base32hex:qn,base32hexpad:Yn,base32hexpadupper:Jn,base32hexupper:Wn,base32pad:Xn,base32padupper:Gn,base32upper:jn,base32z:Qn},Symbol.toStringTag,{value:"Module"})),er=(r,e)=>{const{bytes:t,version:n}=r;switch(n){case 0:return nr(t,_e(r),e||S.encoder);default:return rr(t,_e(r),e||$.encoder)}},Ve=new WeakMap,_e=r=>{const e=Ve.get(r);if(e==null){const t=new Map;return Ve.set(r,t),t}return e};class y{constructor(e,t,n,s){this.code=t,this.version=e,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==B)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==sr)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return y.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=H(e,t);return y.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return y.equals(this,e)}static equals(e,t){const n=t;return n&&e.code===n.code&&e.version===n.version&&In(e.multihash,n.multihash)}toString(e){return er(this,e)}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof y)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:n,code:s,multihash:i,bytes:o}=t;return new y(n,s,i,o||Fe(n,s,i.bytes))}else if(t[ir]===!0){const{version:n,multihash:s,code:i}=t,o=Ae(s);return y.create(n,i,o)}else return null}static create(e,t,n){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==B)throw new Error(`Version 0 CID must use dag-pb (code: ${B}) block encoding`);return new y(e,t,n,n.bytes)}case 1:{const s=Fe(e,t,n.bytes);return new y(e,t,n,s)}default:throw new Error("Invalid version")}}static createV0(e){return y.create(0,B,e)}static createV1(e,t){return y.create(1,e,t)}static decode(e){const[t,n]=y.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=y.inspectBytes(e),n=t.size-t.multihashSize,s=fe(e.subarray(n,n+t.multihashSize));if(s.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=s.subarray(t.multihashSize-t.digestSize),o=new Ce(t.multihashCode,t.digestSize,i,s);return[t.version===0?y.createV0(o):y.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[f,m]=me(e.subarray(t));return t+=m,f};let s=n(),i=B;if(s===18?(s=0,t=0):i=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=t,a=n(),c=n(),d=t+c,u=d-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:u,size:d}}static parse(e,t){const[n,s]=tr(e,t),i=y.decode(s);return _e(i).set(n,e),i}}const tr=(r,e)=>{switch(r[0]){case"Q":{const t=e||S;return[S.prefix,t.decode(`${S.prefix}${r}`)]}case S.prefix:{const t=e||S;return[S.prefix,t.decode(r)]}case $.prefix:{const t=e||$;return[$.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}},nr=(r,e,t)=>{const{prefix:n}=t;if(n!==S.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const s=e.get(n);if(s==null){const i=t.encode(r).slice(1);return e.set(n,i),i}else return s},rr=(r,e,t)=>{const{prefix:n}=t,s=e.get(n);if(s==null){const i=t.encode(r);return e.set(n,i),i}else return s},B=112,sr=18,Fe=(r,e,t)=>{const n=ae(r),s=n+ae(e),i=new Uint8Array(s+t.byteLength);return oe(r,i,0),oe(e,i,n),i.set(t,s),i},ir=Symbol.for("@ipld/js-cid/CID"),or=de({prefix:"\0",name:"identity",encode:r=>Mn(r),decode:r=>Tn(r)}),ar=Object.freeze(Object.defineProperty({__proto__:null,identity:or},Symbol.toStringTag,{value:"Module"})),cr=g({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),hr=Object.freeze(Object.defineProperty({__proto__:null,base2:cr},Symbol.toStringTag,{value:"Module"})),ur=g({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),lr=Object.freeze(Object.defineProperty({__proto__:null,base8:ur},Symbol.toStringTag,{value:"Module"})),fr=X({prefix:"9",name:"base10",alphabet:"0123456789"}),dr=Object.freeze(Object.defineProperty({__proto__:null,base10:fr},Symbol.toStringTag,{value:"Module"})),yr=g({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),pr=g({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),gr=Object.freeze(Object.defineProperty({__proto__:null,base16:yr,base16upper:pr},Symbol.toStringTag,{value:"Module"})),wr=X({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),br=X({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),mr=Object.freeze(Object.defineProperty({__proto__:null,base36:wr,base36upper:br},Symbol.toStringTag,{value:"Module"})),_r=g({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),vr=g({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Er=g({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),xr=g({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),Sr=Object.freeze(Object.defineProperty({__proto__:null,base64:_r,base64pad:vr,base64url:Er,base64urlpad:xr},Symbol.toStringTag,{value:"Module"})),lt=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),Ar=lt.reduce((r,e,t)=>(r[t]=e,r),[]),Cr=lt.reduce((r,e,t)=>(r[e.codePointAt(0)]=t,r),[]);function Lr(r){return r.reduce((e,t)=>(e+=Ar[t],e),"")}function Pr(r){const e=[];for(const t of r){const n=Cr[t.codePointAt(0)];if(n===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(n)}return new Uint8Array(e)}const kr=de({prefix:"🚀",name:"base256emoji",encode:Lr,decode:Pr}),Ur=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:kr},Symbol.toStringTag,{value:"Module"})),ft=({name:r,code:e,encode:t})=>new Tr(r,e,t);class Tr{constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?H(this.code,t):t.then(n=>H(this.code,n))}else throw Error("Unknown type, must be binary type")}}const dt=r=>async e=>new Uint8Array(await crypto.subtle.digest(r,e)),Le=ft({name:"sha2-256",code:18,encode:dt("SHA-256")});ft({name:"sha2-512",code:19,encode:dt("SHA-512")});const yt=0,Mr="identity",pt=fe,Ir=r=>H(yt,pt(r)),ce={code:yt,name:Mr,encode:pt,digest:Ir};new TextEncoder;new TextDecoder;const je={...ar,...hr,...lr,...dr,...gr,...Zn,...mr,...Fn,...Sr,...Ur},gt=Symbol.for("@libp2p/peer-id");function cs(r){return r!=null&&Boolean(r[gt])}const Kr=Symbol.for("nodejs.util.inspect.custom"),Dr=Object.values(je).map(r=>r.decoder).reduce((r,e)=>r.or(e),je.identity.decoder),wt=114,Pe=36,ke=37;class Ue{constructor(e){this.type=e.type,this.multihash=e.multihash,this.privateKey=e.privateKey,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}get[gt](){return!0}toString(){return this.string==null&&(this.string=S.encode(this.multihash.bytes).slice(1)),this.string}toCID(){return y.createV1(wt,this.multihash)}toBytes(){return this.multihash.bytes}toJSON(){return this.toString()}equals(e){if(e instanceof Uint8Array)return ee(this.multihash.bytes,e);if(typeof e=="string")return Rr(e).equals(this);if(e?.multihash?.bytes!=null)return ee(this.multihash.bytes,e.multihash.bytes);throw new Error("not valid Id")}[Kr](){return`PeerId(${this.toString()})`}}class G extends Ue{constructor(e){super({...e,type:"RSA"}),this.type="RSA",this.publicKey=e.publicKey}}class q extends Ue{constructor(e){super({...e,type:"Ed25519"}),this.type="Ed25519",this.publicKey=e.multihash.digest}}class W extends Ue{constructor(e){super({...e,type:"secp256k1"}),this.type="secp256k1",this.publicKey=e.multihash.digest}}function hs(r){if(r.type==="RSA")return new G(r);if(r.type==="Ed25519")return new q(r);if(r.type==="secp256k1")return new W(r);throw z(new Error("Not a PeerId"),"ERR_INVALID_PARAMETERS")}function Rr(r,e){if(r.charAt(0)==="1"||r.charAt(0)==="Q"){const t=Ae(S.decode(`z${r}`));return r.startsWith("12D")?new q({multihash:t}):r.startsWith("16U")?new W({multihash:t}):new G({multihash:t})}return Nr(Dr.decode(r))}function Nr(r){try{const e=Ae(r);if(e.code===ce.code){if(e.digest.length===Pe)return new q({multihash:e});if(e.digest.length===ke)return new W({multihash:e})}if(e.code===Le.code)return new G({multihash:e})}catch{return Or(y.decode(r))}throw new Error("Supplied PeerID CID is invalid")}function Or(r){if(r==null||r.multihash==null||r.version==null||r.version===1&&r.code!==wt)throw new Error("Supplied PeerID CID is invalid");const e=r.multihash;if(e.code===Le.code)return new G({multihash:r.multihash});if(e.code===ce.code){if(e.digest.length===Pe)return new q({multihash:r.multihash});if(e.digest.length===ke)return new W({multihash:r.multihash})}throw new Error("Supplied PeerID CID is invalid")}async function bt(r,e){return r.length===Pe?new q({multihash:H(ce.code,r),privateKey:e}):r.length===ke?new W({multihash:H(ce.code,r),privateKey:e}):new G({multihash:await Le.digest(r),publicKey:r,privateKey:e})}var he;(function(r){let e;r.codec=()=>(e==null&&(e=Qe((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.webtransportCerthashes!=null)for(const i of t.webtransportCerthashes)n.uint32(10),n.bytes(i);s.lengthDelimited!==!1&&n.ldelim()},(t,n)=>{const s={webtransportCerthashes:[]},i=n==null?t.len:t.pos+n;for(;t.pos<i;){const o=t.uint32();switch(o>>>3){case 1:s.webtransportCerthashes.push(t.bytes());break;default:t.skipType(o&7);break}}return s})),e),r.encode=t=>Ze(t,r.codec()),r.decode=t=>et(t,r.codec())})(he||(he={}));var ue;(function(r){let e;r.codec=()=>(e==null&&(e=Qe((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),(s.writeDefaults===!0||t.identityKey!=null&&t.identityKey.byteLength>0)&&(n.uint32(10),n.bytes(t.identityKey)),(s.writeDefaults===!0||t.identitySig!=null&&t.identitySig.byteLength>0)&&(n.uint32(18),n.bytes(t.identitySig)),t.extensions!=null&&(n.uint32(34),he.codec().encode(t.extensions,n,{writeDefaults:!1})),s.lengthDelimited!==!1&&n.ldelim()},(t,n)=>{const s={identityKey:new Uint8Array(0),identitySig:new Uint8Array(0)},i=n==null?t.len:t.pos+n;for(;t.pos<i;){const o=t.uint32();switch(o>>>3){case 1:s.identityKey=t.bytes();break;case 2:s.identitySig=t.bytes();break;case 4:s.extensions=he.codec().decode(t,t.uint32());break;default:t.skipType(o&7);break}}return s})),e),r.encode=t=>Ze(t,r.codec()),r.decode=t=>et(t,r.codec())})(ue||(ue={}));async function Hr(r,e,t){const n=await zr(r,mt(e));if(r.publicKey==null)throw new Error("PublicKey was missing from local PeerId");return Br(r.publicKey,n,t)}function Br(r,e,t){return ue.encode({identityKey:r,identitySig:e,extensions:t??{webtransportCerthashes:[]}}).subarray()}async function zr(r,e){if(r.privateKey==null)throw new Error("PrivateKey was missing from PeerId");return await(await Et(r.privateKey)).sign(e)}async function Xe(r){return await bt(r.identityKey)}function Ge(r){return ue.decode(r)}function mt(r){const e=tt("noise-libp2p-static-key:");return R([e,r],e.length+r.length)}async function qe(r,e,t){const n=await bt(e.identityKey);if(!n.equals(t))throw new Error("Peer ID doesn't match libp2p public key.");const s=mt(r);if(n.publicKey==null)throw new Error("PublicKey was missing from PeerId");if(e.identitySig==null)throw new Error("Signature was missing from message");if(!await xt(n.publicKey).verify(s,e.identitySig))throw new Error("Static key doesn't match to peer that signed payload!");return n}function Q(r){return!(!(r instanceof Uint8Array)||r.length!==32)}const w=St("libp2p:noise");let E;Wt?E=w:E=Object.assign(()=>{},{enabled:!1,trace:()=>{},error:()=>{}});function $r(r){E(`LOCAL_STATIC_PUBLIC_KEY ${K(r.publicKey,"hex")}`),E(`LOCAL_STATIC_PRIVATE_KEY ${K(r.privateKey,"hex")}`)}function We(r){r?(E(`LOCAL_PUBLIC_EPHEMERAL_KEY ${K(r.publicKey,"hex")}`),E(`LOCAL_PRIVATE_EPHEMERAL_KEY ${K(r.privateKey,"hex")}`)):E("Missing local ephemeral keys.")}function Vr(r){E(`REMOTE_STATIC_PUBLIC_KEY ${K(r,"hex")}`)}function Ye(r){E(`REMOTE_EPHEMERAL_PUBLIC_KEY ${K(r,"hex")}`)}function Fr(r){r.cs1&&r.cs2?(E(`CIPHER_STATE_1 ${r.cs1.n.getUint64()} ${K(r.cs1.k,"hex")}`),E(`CIPHER_STATE_2 ${r.cs2.n.getUint64()} ${K(r.cs2.k,"hex")}`)):E("Missing cipher state.")}const jr=0,Xr=4294967295,Gr="Cipherstate has reached maximum n, a new handshake must be performed";class qr{constructor(e=jr){this.n=e,this.bytes=new Uint8Array(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,e,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>Xr)throw new Error(Gr)}}class Wr{constructor(e){this.crypto=e}encryptWithAd(e,t,n){const s=this.encrypt(e.k,e.n,t,n);return e.n.increment(),s}decryptWithAd(e,t,n,s){const{plaintext:i,valid:o}=this.decrypt(e.k,e.n,t,n,s);return o&&e.n.increment(),{plaintext:i,valid:o}}hasKey(e){return!this.isEmptyKey(e.k)}createEmptyKey(){return new Uint8Array(32)}isEmptyKey(e){const t=this.createEmptyKey();return ee(t,e)}encrypt(e,t,n,s){return t.assertValue(),this.crypto.chaCha20Poly1305Encrypt(s,t.getBytes(),n,e)}encryptAndHash(e,t){let n;return this.hasKey(e.cs)?n=this.encryptWithAd(e.cs,e.h,t):n=t,this.mixHash(e,n),n}decrypt(e,t,n,s,i){t.assertValue();const o=this.crypto.chaCha20Poly1305Decrypt(s,t.getBytes(),n,e,i);return o?{plaintext:o,valid:!0}:{plaintext:new Uint8Array(0),valid:!1}}decryptAndHash(e,t){let n,s=!0;return this.hasKey(e.cs)?{plaintext:n,valid:s}=this.decryptWithAd(e.cs,e.h,t):n=t,this.mixHash(e,t),{plaintext:n,valid:s}}dh(e,t){try{const n=this.crypto.generateX25519SharedKey(e,t);return n.length===32?n:n.subarray(0,32)}catch(n){return w(n.message),new Uint8Array(32)}}mixHash(e,t){e.h=this.getHash(e.h,t)}getHash(e,t){return this.crypto.hashSHA256(R([e,t],e.length+t.length))}mixKey(e,t){const[n,s]=this.crypto.getHKDF(e.ck,t);e.cs=this.initializeKey(s),e.ck=n}initializeKey(e){return{k:e,n:new qr}}initializeSymmetric(e){const t=tt(e,"utf-8"),n=this.hashProtocolName(t),s=n,i=this.createEmptyKey();return{cs:this.initializeKey(i),ck:s,h:n}}hashProtocolName(e){if(e.length<=32){const t=new Uint8Array(32);return t.set(e),t}else return this.getHash(e,new Uint8Array(0))}split(e){const[t,n]=this.crypto.getHKDF(e.ck,new Uint8Array(0)),s=this.initializeKey(t),i=this.initializeKey(n);return{cs1:s,cs2:i}}writeMessageRegular(e,t){const n=this.encryptWithAd(e,new Uint8Array(0),t),s=this.createEmptyKey(),i=new Uint8Array(0);return{ne:s,ns:i,ciphertext:n}}readMessageRegular(e,t){return this.decryptWithAd(e,new Uint8Array(0),t.ciphertext)}}class Yr extends Wr{initializeInitiator(e,t,n,s){const i="Noise_XX_25519_ChaChaPoly_SHA256",o=this.initializeSymmetric(i);this.mixHash(o,e);const a=new Uint8Array(32);return{ss:o,s:t,rs:n,psk:s,re:a}}initializeResponder(e,t,n,s){const i="Noise_XX_25519_ChaChaPoly_SHA256",o=this.initializeSymmetric(i);this.mixHash(o,e);const a=new Uint8Array(32);return{ss:o,s:t,rs:n,psk:s,re:a}}writeMessageA(e,t,n){const s=new Uint8Array(0);n!==void 0?e.e=n:e.e=this.crypto.generateX25519KeyPair();const i=e.e.publicKey;this.mixHash(e.ss,i);const o=this.encryptAndHash(e.ss,t);return{ne:i,ns:s,ciphertext:o}}writeMessageB(e,t){e.e=this.crypto.generateX25519KeyPair();const n=e.e.publicKey;this.mixHash(e.ss,n),this.mixKey(e.ss,this.dh(e.e.privateKey,e.re));const s=e.s.publicKey,i=this.encryptAndHash(e.ss,s);this.mixKey(e.ss,this.dh(e.s.privateKey,e.re));const o=this.encryptAndHash(e.ss,t);return{ne:n,ns:i,ciphertext:o}}writeMessageC(e,t){const n=e.s.publicKey,s=this.encryptAndHash(e.ss,n);this.mixKey(e.ss,this.dh(e.s.privateKey,e.re));const i=this.encryptAndHash(e.ss,t),a={ne:this.createEmptyKey(),ns:s,ciphertext:i},{cs1:c,cs2:d}=this.split(e.ss);return{h:e.ss.h,messageBuffer:a,cs1:c,cs2:d}}readMessageA(e,t){return Q(t.ne)&&(e.re=t.ne),this.mixHash(e.ss,e.re),this.decryptAndHash(e.ss,t.ciphertext)}readMessageB(e,t){if(Q(t.ne)&&(e.re=t.ne),this.mixHash(e.ss,e.re),!e.e)throw new Error("Handshake state `e` param is missing.");this.mixKey(e.ss,this.dh(e.e.privateKey,e.re));const{plaintext:n,valid:s}=this.decryptAndHash(e.ss,t.ns);s&&Q(n)&&(e.rs=n),this.mixKey(e.ss,this.dh(e.e.privateKey,e.rs));const{plaintext:i,valid:o}=this.decryptAndHash(e.ss,t.ciphertext);return{plaintext:i,valid:s&&o}}readMessageC(e,t){const{plaintext:n,valid:s}=this.decryptAndHash(e.ss,t.ns);if(s&&Q(n)&&(e.rs=n),!e.e)throw new Error("Handshake state `e` param is missing.");this.mixKey(e.ss,this.dh(e.e.privateKey,e.rs));const{plaintext:i,valid:o}=this.decryptAndHash(e.ss,t.ciphertext),{cs1:a,cs2:c}=this.split(e.ss);return{h:e.ss.h,plaintext:i,valid:s&&o,cs1:a,cs2:c}}initSession(e,t,n){const s=this.createEmptyKey(),i=new Uint8Array(32);let o;return e?o=this.initializeInitiator(t,n,i,s):o=this.initializeResponder(t,n,i,s),{hs:o,i:e,mc:0}}sendMessage(e,t,n){let s;if(e.mc===0)s=this.writeMessageA(e.hs,t,n);else if(e.mc===1)s=this.writeMessageB(e.hs,t);else if(e.mc===2){const{h:i,messageBuffer:o,cs1:a,cs2:c}=this.writeMessageC(e.hs,t);s=o,e.h=i,e.cs1=a,e.cs2=c}else if(e.mc>2)if(e.i){if(!e.cs1)throw new Error("CS1 (cipher state) is not defined");s=this.writeMessageRegular(e.cs1,t)}else{if(!e.cs2)throw new Error("CS2 (cipher state) is not defined");s=this.writeMessageRegular(e.cs2,t)}else throw new Error("Session invalid.");return e.mc++,s}recvMessage(e,t){let n=new Uint8Array(0),s=!1;if(e.mc===0)({plaintext:n,valid:s}=this.readMessageA(e.hs,t));else if(e.mc===1)({plaintext:n,valid:s}=this.readMessageB(e.hs,t));else if(e.mc===2){const{h:i,plaintext:o,valid:a,cs1:c,cs2:d}=this.readMessageC(e.hs,t);n=o,s=a,e.h=i,e.cs1=c,e.cs2=d}return e.mc++,{plaintext:n,valid:s}}}class Jr{constructor(e,t,n,s,i,o,a,c){this.remoteExtensions={webtransportCerthashes:[]},this.isInitiator=e,this.payload=t,this.prologue=n,this.staticKeypair=i,this.connection=o,a&&(this.remotePeer=a),this.xx=c??new Yr(s),this.session=this.xx.initSession(this.isInitiator,this.prologue,this.staticKeypair)}async propose(){if($r(this.session.hs.s),this.isInitiator){w("Stage 0 - Initiator starting to send first message.");const e=this.xx.sendMessage(this.session,new Uint8Array(0));this.connection.writeLP(sn(e)),w("Stage 0 - Initiator finished sending first message."),We(this.session.hs.e)}else{w("Stage 0 - Responder waiting to receive first message...");const e=cn((await this.connection.readLP()).subarray()),{valid:t}=this.xx.recvMessage(this.session,e);if(!t)throw new O("xx handshake stage 0 validation fail");w("Stage 0 - Responder received first message."),Ye(this.session.hs.re)}}async exchange(){if(this.isInitiator){w("Stage 1 - Initiator waiting to receive first message from responder...");const e=hn((await this.connection.readLP()).subarray()),{plaintext:t,valid:n}=this.xx.recvMessage(this.session,e);if(!n)throw new O("xx handshake stage 1 validation fail");w("Stage 1 - Initiator received the message."),Ye(this.session.hs.re),Vr(this.session.hs.rs),w("Initiator going to check remote's signature...");try{const s=Ge(t);this.remotePeer=this.remotePeer||await Xe(s),await qe(this.session.hs.rs,s,this.remotePeer),this.setRemoteNoiseExtension(s.extensions)}catch(s){const i=s;throw new se(`Error occurred while verifying signed payload: ${i.message}`)}w("All good with the signature!")}else{w("Stage 1 - Responder sending out first message with signed payload and static key.");const e=this.xx.sendMessage(this.session,this.payload);this.connection.writeLP(on(e)),w("Stage 1 - Responder sent the second handshake message with signed payload."),We(this.session.hs.e)}}async finish(){if(this.isInitiator){w("Stage 2 - Initiator sending third handshake message.");const e=this.xx.sendMessage(this.session,this.payload);this.connection.writeLP(an(e)),w("Stage 2 - Initiator sent message with signed payload.")}else{w("Stage 2 - Responder waiting for third handshake message...");const e=un((await this.connection.readLP()).subarray()),{plaintext:t,valid:n}=this.xx.recvMessage(this.session,e);if(!n)throw new O("xx handshake stage 2 validation fail");w("Stage 2 - Responder received the message, finished handshake.");try{const s=Ge(t);this.remotePeer=this.remotePeer||await Xe(s),await qe(this.session.hs.rs,s,this.remotePeer),this.setRemoteNoiseExtension(s.extensions)}catch(s){const i=s;throw new se(`Error occurred while verifying signed payload: ${i.message}`)}}Fr(this.session)}encrypt(e,t){const n=this.getCS(t);return this.xx.encryptWithAd(n,new Uint8Array(0),e)}decrypt(e,t,n){const s=this.getCS(t,!1);return this.xx.decryptWithAd(s,new Uint8Array(0),e,n)}getRemoteStaticKey(){return this.session.hs.rs}getCS(e,t=!0){if(!e.cs1||!e.cs2)throw new O("Handshake not completed properly, cipher state does not exist.");return this.isInitiator?t?e.cs1:e.cs2:t?e.cs2:e.cs1}setRemoteNoiseExtension(e){e&&(this.remoteExtensions=e)}}function Qr(r){return{xxHandshakeSuccesses:r.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:r.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:r.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:r.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:r.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}class Zr{constructor(e={}){this.protocol="/noise";const{staticNoiseKey:t,extensions:n,crypto:s,prologueBytes:i,metrics:o}=e;this.crypto=s??nn,this.extensions=n,this.metrics=o?Qr(o):void 0,t?this.staticKeys=this.crypto.generateX25519KeyPairFromSeed(t):this.staticKeys=this.crypto.generateX25519KeyPair(),this.prologue=i??new Uint8Array(0)}async secureOutbound(e,t,n){const s=Re(t,{lengthEncoder:re,lengthDecoder:Z,maxDataLength:F}),i=await this.performHandshake({connection:s,isInitiator:!0,localPeer:e,remotePeer:n});return{conn:await this.createSecureConnection(s,i),remoteExtensions:i.remoteExtensions,remotePeer:i.remotePeer}}async secureInbound(e,t,n){const s=Re(t,{lengthEncoder:re,lengthDecoder:Z,maxDataLength:F}),i=await this.performHandshake({connection:s,isInitiator:!1,localPeer:e,remotePeer:n});return{conn:await this.createSecureConnection(s,i),remotePeer:i.remotePeer,remoteExtensions:i.remoteExtensions}}async performHandshake(e){const t=await Hr(e.localPeer,this.staticKeys.publicKey,this.extensions);return await this.performXXHandshake(e,t)}async performXXHandshake(e,t){const{isInitiator:n,remotePeer:s,connection:i}=e,o=new Jr(n,t,this.prologue,this.crypto,this.staticKeys,i,s);try{await o.propose(),await o.exchange(),await o.finish(),this.metrics?.xxHandshakeSuccesses.increment()}catch(a){if(this.metrics?.xxHandshakeErrors.increment(),a instanceof Error)throw a.message=`Error occurred during XX handshake: ${a.message}`,a}return o}async createSecureConnection(e,t){const[n,s]=Ft(),i=e.unwrap();return await qt(n,ln(t,this.metrics),i,ne({lengthDecoder:Z}),fn(t,this.metrics),n),s}}function es(r={}){return()=>new Zr(r)}const ts=ve(()=>import("./configNavigateur-170fcca4.js"),["configNavigateur-170fcca4.js","index-3f008de2.js","index-1b8ce02e.js","index-93e3afde.css","index-c6f3d1f2.js"]),ns=ve(()=>import("./configNode-d6db90b9.js"),["configNode-d6db90b9.js","index-3f008de2.js","index-1b8ce02e.js","index-93e3afde.css","index-c6f3d1f2.js","source-55a07a62.js"]),rs=async()=>{if(At||Ct)return(await ts).default;if(Lt)return{};if(Pt)return(await ns).default();throw new Error("Environnement non supporté")},ss=()=>({libp2p:{modules:{},connectionManager:{autoDial:!1},config:{peerDiscovery:{webRTCStar:{enabled:!0}},transport:{WebRTCStar:{wrtc:p,connEncryption:[es]}}},transportManager:{faultTolerance:1}},relay:{enabled:!0,hop:{enabled:!0,active:!0}},config:{Addresses:{Swarm:["/dns4/arcane-springs-02799.herokuapp.com/tcp/443/wss/p2p-webrtc-star/","/dns4/p2p-circuit-constellation.herokuapp.com/tcp/443/wss/p2p/QmY8XpuX6VnaUVDz4uA14vpjv3CZYLif3wLPqCkgU2KLSB"]}}});async function is(r="./constl/sfip"){const e={type:"proc",disposable:!1,test:!1,ipfsModule:await ve(()=>import("./index-4aa542dd.js"),["index-4aa542dd.js","index-1b8ce02e.js","index-93e3afde.css","index-3f008de2.js","source-55a07a62.js"])},t=ss(),n=await rs();t.libp2p.modules=n,t.repo=r,e.ipfsOptions=t;const s=await kt(e);return await s.init(),await s.start(),s.api}const us=Object.freeze(Object.defineProperty({__proto__:null,default:is},Symbol.toStringTag,{value:"Module"}));export{T as U,Ee as a,Rr as b,bt as c,Nr as d,qt as e,J as f,it as g,ne as h,cs as i,Tt as j,hs as k,as as l,jt as m,es as n,us as o,st as p,V as u};
//# sourceMappingURL=index-031e1553.js.map
