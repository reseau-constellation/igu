{"version":3,"file":"index-Yv9Tg3_u.js","sources":["../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/dist/src/constants.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/dist/src/socket-to-conn.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/dist/src/utils.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/dist/src/listener.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/dist/src/transport.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/dist/src/index.js"],"sourcesContent":["// p2p multi-address code\nexport const CODE_P2P = 421;\nexport const CODE_CIRCUIT = 290;\n// Time to wait for a connection to close gracefully before destroying it manually\nexport const CLOSE_TIMEOUT = 2000;\n//# sourceMappingURL=constants.js.map","import { abortableSource } from 'abortable-iterator';\nimport { CLOSE_TIMEOUT } from './constants.js';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:webrtc-star:socket');\n/**\n * Convert a socket into a MultiaddrConnection\n * https://github.com/libp2p/js-libp2p-interfaces/tree/master/src/transport#multiaddrconnection\n */\nexport function toMultiaddrConnection(socket, options) {\n    const { sink, source } = socket;\n    const maConn = {\n        remoteAddr: options.remoteAddr,\n        async sink(source) {\n            if (options.signal != null) {\n                source = abortableSource(source, options.signal);\n            }\n            try {\n                await sink(source);\n            }\n            catch (err) {\n                // If aborted we can safely ignore\n                if (err.type !== 'aborted') {\n                    // If the source errored the socket will already have been destroyed by\n                    // toIterable.duplex(). If the socket errored it will already be\n                    // destroyed. There's nothing to do here except log the error & return.\n                    log.error(err);\n                }\n            }\n        },\n        source: (options.signal != null) ? abortableSource(source, options.signal) : source,\n        timeline: { open: Date.now() },\n        async close() {\n            if (socket.closed) {\n                return;\n            }\n            const start = Date.now();\n            // Attempt to end the socket. If it takes longer to close than the\n            // timeout, destroy it manually.\n            const timeout = setTimeout(() => {\n                if (maConn.remoteAddr != null) {\n                    const { host, port } = maConn.remoteAddr.toOptions();\n                    log('timeout closing socket to %s:%s after %dms, destroying it manually', host, port, Date.now() - start);\n                }\n                if (!socket.closed) {\n                    socket.close().catch(err => {\n                        log.error('could not close socket', err);\n                    });\n                }\n            }, CLOSE_TIMEOUT);\n            try {\n                await socket.close();\n            }\n            finally {\n                clearTimeout(timeout);\n            }\n        }\n    };\n    socket.addEventListener('close', () => {\n        // In instances where `close` was not explicitly called,\n        // such as an iterable stream ending, ensure we have set the close\n        // timeline\n        if (maConn.timeline.close == null) {\n            maConn.timeline.close = Date.now();\n        }\n    }, {\n        once: true\n    });\n    return maConn;\n}\n//# sourceMappingURL=socket-to-conn.js.map","import { multiaddr, isName } from '@multiformats/multiaddr';\nexport function cleanUrlSIO(ma) {\n    const maStrSplit = ma.toString().split('/');\n    const tcpProto = ma.protos()[1].name;\n    const wsProto = ma.protos()[2].name;\n    const tcpPort = ma.stringTuples()[1][1];\n    if (tcpProto !== 'tcp' || (wsProto !== 'ws' && wsProto !== 'wss')) {\n        throw new Error(`invalid multiaddr: ${ma.toString()}`);\n    }\n    if (!isName(ma)) {\n        return `http://${maStrSplit[2]}:${maStrSplit[4]}`;\n    }\n    if (wsProto === 'ws') {\n        return `http://${maStrSplit[2]}${tcpPort == null || tcpPort === '80' ? '' : `:${tcpPort}`}`;\n    }\n    if (wsProto === 'wss') {\n        return `https://${maStrSplit[2]}${tcpPort == null || tcpPort === '443' ? '' : `:${tcpPort}`}`;\n    }\n    throw new Error('invalid multiaddr: ' + ma.toString());\n}\nexport function cleanMultiaddr(maStr) {\n    const legacy = '/libp2p-webrtc-star';\n    if (maStr.startsWith(legacy)) {\n        maStr = maStr.substring(legacy.length, maStr.length);\n        let ma = multiaddr(maStr);\n        const tuppleIPFS = ma.stringTuples().filter((tupple) => {\n            return tupple[0] === 421; // ipfs code\n        })[0];\n        if (tuppleIPFS[1] == null) {\n            throw new Error('invalid multiaddr: ' + maStr);\n        }\n        ma = ma.decapsulate('p2p');\n        ma = ma.encapsulate('/p2p-webrtc-star');\n        ma = ma.encapsulate(`/p2p/${tuppleIPFS[1]}`);\n        maStr = ma.toString();\n    }\n    return maStr;\n}\n//# sourceMappingURL=utils.js.map","import { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { connect } from 'socket.io-client';\nimport pDefer from 'p-defer';\nimport { WebRTCReceiver } from '@libp2p/webrtc-peer';\nimport { toMultiaddrConnection } from './socket-to-conn.js';\nimport { cleanUrlSIO } from './utils.js';\nimport { CODE_P2P } from './constants.js';\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events';\nconst log = logger('libp2p:webrtc-star:listener');\nconst sioOptions = {\n    transports: ['websocket'],\n    path: '/socket.io-next/' // This should be removed when socket.io@2 support is removed\n};\nclass SigServer extends EventEmitter {\n    constructor(signallingUrl, signallingAddr, upgrader, handler, channelOptions) {\n        super();\n        this.signallingAddr = signallingAddr;\n        this.socket = connect(signallingUrl, sioOptions);\n        this.connections = [];\n        this.channels = new Map();\n        this.pendingSignals = new Map();\n        this.upgrader = upgrader;\n        this.handler = handler;\n        this.channelOptions = channelOptions;\n        this.handleWsHandshake = this.handleWsHandshake.bind(this);\n        let previouslyConnected = false;\n        this.socket.on('connect_error', err => {\n            // @ts-expect-error `.type` is missing from the types\n            if (previouslyConnected && err.type === 'TransportError') {\n                // if we've had an open connection before, and this is a\n                // transport error, let socket.io's reconnect logic take over\n                return;\n            }\n            this.dispatchEvent(new CustomEvent('error', {\n                detail: err\n            }));\n        });\n        this.socket.on('error', (err) => {\n            this.dispatchEvent(new CustomEvent('error', {\n                detail: err\n            }));\n        });\n        this.socket.on('ws-handshake', this.handleWsHandshake);\n        this.socket.on('ws-peer', (maStr) => {\n            this.dispatchEvent(new CustomEvent('peer', {\n                detail: maStr\n            }));\n        });\n        this.socket.on('connect', () => {\n            this.socket.emit('ss-join', this.signallingAddr.toString());\n            if (previouslyConnected) {\n                this.dispatchEvent(new CustomEvent('reconnect'));\n            }\n        });\n        this.socket.once('connect', () => {\n            // make sure we can reconnect in future\n            previouslyConnected = true;\n            this.dispatchEvent(new CustomEvent('listening'));\n        });\n        this.socket.on('disconnect', () => {\n            this.dispatchEvent(new CustomEvent('disconnect'));\n        });\n    }\n    _createChannel(intentId, srcMultiaddr, dstMultiaddr) {\n        const channelOptions = {\n            ...this.channelOptions\n        };\n        const channel = new WebRTCReceiver(channelOptions);\n        const onError = (evt) => {\n            const err = evt.detail;\n            log.error('incoming connection errored', err);\n        };\n        channel.addEventListener('error', onError);\n        channel.addEventListener('close', () => {\n            channel.removeEventListener('error', onError);\n        }, {\n            once: true\n        });\n        channel.addEventListener('signal', (evt) => {\n            const signal = evt.detail;\n            this.socket.emit('ss-handshake', {\n                intentId,\n                srcMultiaddr,\n                dstMultiaddr,\n                answer: true,\n                signal\n            });\n        });\n        channel.addEventListener('ready', () => {\n            const maConn = toMultiaddrConnection(channel, { remoteAddr: this.signallingAddr });\n            log('new inbound connection %s', maConn.remoteAddr);\n            try {\n                this.upgrader.upgradeInbound(maConn)\n                    .then(conn => {\n                    log('inbound connection %s upgraded', maConn.remoteAddr);\n                    this.connections.push(maConn);\n                    const untrackConn = () => {\n                        this.connections = this.connections.filter(c => c !== maConn);\n                        this.channels.delete(intentId);\n                        this.pendingSignals.delete(intentId);\n                    };\n                    channel.addEventListener('close', untrackConn, {\n                        once: true\n                    });\n                    this.dispatchEvent(new CustomEvent('connection', {\n                        detail: conn\n                    }));\n                    this.handler(conn);\n                })\n                    .catch(err => {\n                    log.error('inbound connection failed to upgrade', err);\n                    maConn.close().catch(err => {\n                        log.error('inbound connection failed to close after failing to upgrade', err);\n                    });\n                });\n            }\n            catch (err) {\n                log.error('inbound connection failed to upgrade', err);\n                maConn.close().catch(err => {\n                    log.error('inbound connection failed to close after failing to upgrade', err);\n                });\n            }\n        }, {\n            once: true\n        });\n        return channel;\n    }\n    handleWsHandshake(offer) {\n        log('incoming handshake. signal type \"%s\" is answer %s', offer.signal.type, offer.answer);\n        if (offer.answer === true || offer.err != null || offer.intentId == null) {\n            return;\n        }\n        const intentId = offer.intentId;\n        let pendingSignals = this.pendingSignals.get(intentId);\n        if (pendingSignals == null) {\n            pendingSignals = [];\n            this.pendingSignals.set(intentId, pendingSignals);\n        }\n        pendingSignals.push(offer);\n        let channel = this.channels.get(intentId);\n        if (channel == null) {\n            if (offer.signal.type !== 'offer') {\n                log('handshake is not an offer and channel does not exist, buffering until we receive an offer');\n                return;\n            }\n            log('creating new channel to handle offer handshake');\n            channel = this._createChannel(offer.intentId, offer.srcMultiaddr, offer.dstMultiaddr);\n            this.channels.set(intentId, channel);\n        }\n        else {\n            log('channel already exists, using it to handle handshake');\n        }\n        while (pendingSignals.length > 0) {\n            const handshake = pendingSignals.shift();\n            if (handshake?.signal != null) {\n                channel.handleSignal(handshake.signal);\n            }\n        }\n    }\n    async close() {\n        // Close listener\n        this.socket.emit('ss-leave', this.signallingAddr.toString());\n        this.socket.removeAllListeners();\n        this.socket.close();\n        await Promise.all([\n            ...this.connections.map(async (maConn) => { await maConn.close(); }),\n            ...Array.from(this.channels.values()).map(async (channel) => { await channel.close(); })\n        ]);\n        this.dispatchEvent(new CustomEvent('close'));\n    }\n}\nclass WebRTCListener extends EventEmitter {\n    constructor(upgrader, handler, peerId, transport, options) {\n        super();\n        this.upgrader = upgrader;\n        this.handler = handler;\n        this.peerId = peerId;\n        this.transport = transport;\n        this.options = options;\n    }\n    async listen(ma) {\n        // Should only be used if not already listening\n        if (this.listeningAddr != null) {\n            throw errCode(new Error('listener already in use'), 'ERR_ALREADY_LISTENING');\n        }\n        const defer = pDefer(); // eslint-disable-line @typescript-eslint/no-invalid-void-type\n        // Should be kept unmodified\n        this.listeningAddr = ma;\n        let signallingAddr;\n        if (!ma.protoCodes().includes(CODE_P2P)) {\n            signallingAddr = ma.encapsulate(`/p2p/${this.peerId.toString()}`);\n        }\n        else {\n            signallingAddr = ma;\n        }\n        const signallingUrl = this.signallingUrl = cleanUrlSIO(ma);\n        log('connecting to signalling server on: %s', this.signallingUrl);\n        const server = new SigServer(this.signallingUrl, signallingAddr, this.upgrader, this.handler, this.options.channelOptions);\n        server.addEventListener('error', (evt) => {\n            const err = evt.detail;\n            log('error connecting to signalling server %o', err);\n            server.close().catch(err => {\n                log.error('error closing server after error', err);\n            });\n            defer.reject(err);\n        });\n        server.addEventListener('listening', () => {\n            log('connected to signalling server');\n            this.dispatchEvent(new CustomEvent('listening'));\n            defer.resolve();\n        });\n        server.addEventListener('peer', (evt) => {\n            this.transport.peerDiscovered(evt.detail);\n        });\n        server.addEventListener('connection', (evt) => {\n            const conn = evt.detail;\n            if (conn.remoteAddr == null) {\n                try {\n                    conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(`/p2p/${conn.remotePeer.toString()}`);\n                }\n                catch (err) {\n                    log.error('could not determine remote address', err);\n                }\n            }\n            this.dispatchEvent(new CustomEvent('connection', {\n                detail: conn\n            }));\n        });\n        server.addEventListener('disconnect', () => {\n            // Ensure we error if we try to dial while we are disconnected from\n            // the signalling server\n            this.transport.sigServers.delete(signallingUrl);\n        });\n        server.addEventListener('reconnect', () => {\n            // We can dial via the signalling server again\n            this.transport.sigServers.set(signallingUrl, server);\n        });\n        // Store listen and signal reference addresses\n        this.transport.sigServers.set(this.signallingUrl, server);\n        await defer.promise;\n    }\n    async close() {\n        if (this.signallingUrl != null) {\n            const server = this.transport.sigServers.get(this.signallingUrl);\n            if (server != null) {\n                await server.close();\n                this.transport.sigServers.delete(this.signallingUrl);\n            }\n        }\n        this.dispatchEvent(new CustomEvent('close'));\n        // Reset state\n        this.listeningAddr = undefined;\n    }\n    getAddrs() {\n        if (this.listeningAddr != null) {\n            return [\n                this.listeningAddr\n            ];\n        }\n        return [];\n    }\n}\nexport function createListener(upgrader, handler, peerId, transport, options) {\n    return new WebRTCListener(upgrader, handler, peerId, transport, options);\n}\n//# sourceMappingURL=listener.js.map","import { logger } from '@libp2p/logger';\nimport errcode from 'err-code';\nimport { AbortError } from 'abortable-iterator';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport * as mafmt from '@multiformats/mafmt';\nimport { CODE_CIRCUIT } from './constants.js';\nimport { createListener } from './listener.js';\nimport { toMultiaddrConnection } from './socket-to-conn.js';\nimport { cleanMultiaddr, cleanUrlSIO } from './utils.js';\nimport { WebRTCInitiator } from '@libp2p/webrtc-peer';\nimport randomBytes from 'iso-random-stream/src/random.js';\nimport { toString as uint8ArrayToString } from 'uint8arrays';\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { symbol } from '@libp2p/interface-transport';\nimport { symbol as peerDiscoverySymbol } from '@libp2p/interface-peer-discovery';\nconst webrtcSupport = 'RTCPeerConnection' in globalThis;\nconst log = logger('libp2p:webrtc-star');\nconst noop = () => { };\nexport class WebRTCStarDiscovery extends EventEmitter {\n    constructor() {\n        super(...arguments);\n        this.started = false;\n    }\n    get [peerDiscoverySymbol]() {\n        return true;\n    }\n    get [Symbol.toStringTag]() {\n        return '@libp2p/webrtc-star-discovery';\n    }\n    isStarted() {\n        return this.started;\n    }\n    async start() {\n        this.started = true;\n    }\n    async stop() {\n        this.started = false;\n    }\n    dispatchEvent(event) {\n        if (!this.isStarted()) {\n            return false;\n        }\n        return super.dispatchEvent(event);\n    }\n}\n/**\n * @class WebRTCStar\n */\nexport class WebRTCStar {\n    constructor(init) {\n        if (init?.wrtc != null) {\n            this.wrtc = init.wrtc;\n        }\n        // Keep Signalling references\n        this.sigServers = new Map();\n        // Discovery\n        this._discovery = new WebRTCStarDiscovery();\n        this.discovery = () => this._discovery;\n        this.peerDiscovered = this.peerDiscovered.bind(this);\n    }\n    get [symbol]() {\n        return true;\n    }\n    get [Symbol.toStringTag]() {\n        return '@libp2p/webrtc-star';\n    }\n    async dial(ma, options) {\n        const rawConn = await this._connect(ma, options);\n        const maConn = toMultiaddrConnection(rawConn, { remoteAddr: ma, signal: options.signal });\n        log('new outbound connection %s', maConn.remoteAddr);\n        const conn = await options.upgrader.upgradeOutbound(maConn);\n        log('outbound connection %s upgraded', maConn.remoteAddr);\n        return conn;\n    }\n    async _connect(ma, options) {\n        if (options.signal?.aborted === true) {\n            throw new AbortError();\n        }\n        const channelOptions = {\n            ...(options.channelOptions ?? {})\n        };\n        // Use custom WebRTC implementation\n        if (this.wrtc != null) {\n            channelOptions.wrtc = this.wrtc;\n        }\n        const cOpts = ma.toOptions();\n        const intentId = uint8ArrayToString(randomBytes(36), 'hex');\n        return await new Promise((resolve, reject) => {\n            const sio = this.sigServers.get(cleanUrlSIO(ma));\n            if (sio?.socket == null) {\n                reject(errcode(new Error('unknown signal server to use'), 'ERR_UNKNOWN_SIGNAL_SERVER'));\n                return;\n            }\n            let connected = false;\n            log('dialing %s:%s', cOpts.host, cOpts.port);\n            const channel = new WebRTCInitiator(channelOptions);\n            const onError = (evt) => {\n                const err = evt.detail;\n                if (!connected) {\n                    const msg = `connection error ${cOpts.host}:${cOpts.port}: ${err.message}`;\n                    log.error(msg);\n                    done(err);\n                }\n            };\n            const onReady = () => {\n                connected = true;\n                log('connection opened %s:%s', cOpts.host, cOpts.port);\n                done();\n            };\n            const onAbort = () => {\n                log.error('connection aborted %s:%s', cOpts.host, cOpts.port);\n                channel.close().finally(() => {\n                    done(new AbortError());\n                });\n            };\n            const done = (err) => {\n                channel.removeEventListener('ready', onReady);\n                options.signal?.removeEventListener('abort', onAbort);\n                if (err == null) {\n                    resolve(channel);\n                }\n                else {\n                    reject(err);\n                }\n            };\n            channel.addEventListener('ready', onReady, {\n                once: true\n            });\n            channel.addEventListener('close', () => {\n                channel.removeEventListener('error', onError);\n            });\n            options.signal?.addEventListener('abort', onAbort);\n            channel.addEventListener('signal', (evt) => {\n                const signal = evt.detail;\n                sio.socket.emit('ss-handshake', {\n                    intentId,\n                    srcMultiaddr: sio.signallingAddr.toString(),\n                    dstMultiaddr: ma.toString(),\n                    signal\n                });\n            });\n            sio.socket.on('ws-handshake', (offer) => {\n                if (offer.intentId === intentId && offer.err != null) {\n                    channel.close().finally(() => {\n                        reject(errcode(new Error(offer.err), 'ERR_SIGNALLING_FAILED'));\n                    });\n                }\n                if (offer.intentId !== intentId || offer.answer == null || channel.closed) {\n                    return;\n                }\n                channel.handleSignal(offer.signal);\n            });\n        });\n    }\n    /**\n     * Creates a WebrtcStar listener. The provided `handler` function will be called\n     * anytime a new incoming Connection has been successfully upgraded via\n     * `upgrader.upgradeInbound`.\n     */\n    createListener(options) {\n        if (!webrtcSupport && this.wrtc == null) {\n            throw errcode(new Error('no WebRTC support'), 'ERR_NO_WEBRTC_SUPPORT');\n        }\n        options.channelOptions = options.channelOptions ?? {};\n        if (this.wrtc != null) {\n            options.channelOptions.wrtc = this.wrtc;\n        }\n        if (this.peerId == null) {\n            throw errcode(new Error('PeerId not set'), 'ERR_MISSING_PEER_ID');\n        }\n        return createListener(options.upgrader, options.handler ?? noop, this.peerId, this, options);\n    }\n    /**\n     * Takes a list of `Multiaddr`s and returns only valid TCP addresses\n     */\n    filter(multiaddrs) {\n        multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n        return multiaddrs.filter((ma) => {\n            if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n                return false;\n            }\n            return mafmt.P2PWebRTCStar.matches(ma);\n        });\n    }\n    peerDiscovered(maStr) {\n        log('peer discovered: %s', maStr);\n        maStr = cleanMultiaddr(maStr);\n        const ma = multiaddr(maStr);\n        const peerIdStr = ma.getPeerId();\n        if (peerIdStr == null) {\n            return;\n        }\n        const peerId = peerIdFromString(peerIdStr);\n        this._discovery.dispatchEvent(new CustomEvent('peer', {\n            detail: {\n                id: peerId,\n                multiaddrs: [ma],\n                protocols: []\n            }\n        }));\n    }\n}\n//# sourceMappingURL=transport.js.map","import { WebRTCStar } from './transport.js';\nexport function webRTCStar(init = {}) {\n    const transport = new WebRTCStar(init);\n    return {\n        transport: (components) => {\n            transport.peerId = components.peerId;\n            return transport;\n        },\n        discovery: transport.discovery\n    };\n}\n//# sourceMappingURL=index.js.map"],"names":["CODE_P2P","CODE_CIRCUIT","CLOSE_TIMEOUT","log","logger","toMultiaddrConnection","socket","options","sink","source","maConn","abortableSource","err","start","timeout","host","port","cleanUrlSIO","ma","maStrSplit","tcpProto","wsProto","tcpPort","isName","cleanMultiaddr","maStr","legacy","multiaddr","tuppleIPFS","tupple","sioOptions","SigServer","EventEmitter","signallingUrl","signallingAddr","upgrader","handler","channelOptions","connect","previouslyConnected","CustomEvent","intentId","srcMultiaddr","dstMultiaddr","channel","WebRTCReceiver","onError","evt","signal","conn","untrackConn","c","offer","pendingSignals","handshake","WebRTCListener","peerId","transport","errCode","defer","pDefer","server","createListener","webrtcSupport","noop","WebRTCStarDiscovery","peerDiscoverySymbol","event","WebRTCStar","init","symbol","rawConn","AbortError","cOpts","uint8ArrayToString","randomBytes","resolve","reject","sio","errcode","connected","WebRTCInitiator","msg","done","onReady","onAbort","multiaddrs","mafmt.P2PWebRTCStar","peerIdStr","peerIdFromString","webRTCStar","components"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}