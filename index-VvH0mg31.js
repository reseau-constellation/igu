import{l as B,s as q,n as L,U as V,b as v,p as J}from"./index-fmMv2BuW.js";function G(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),o=0;o<t.length;o++)t[o]=255;for(var s=0;s<r.length;s++){var n=r.charAt(s),i=n.charCodeAt(0);if(t[i]!==255)throw new TypeError(n+" is ambiguous");t[i]=s}var a=r.length,d=r.charAt(0),c=Math.log(a)/Math.log(256),f=Math.log(256)/Math.log(a);function h(l){if(l instanceof Uint8Array||(ArrayBuffer.isView(l)?l=new Uint8Array(l.buffer,l.byteOffset,l.byteLength):Array.isArray(l)&&(l=Uint8Array.from(l))),!(l instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(l.length===0)return"";for(var w=0,P=0,y=0,S=l.length;y!==S&&l[y]===0;)y++,w++;for(var E=(S-y)*f+1>>>0,g=new Uint8Array(E);y!==S;){for(var _=l[y],A=0,x=E-1;(_!==0||A<P)&&x!==-1;x--,A++)_+=256*g[x]>>>0,g[x]=_%a>>>0,_=_/a>>>0;if(_!==0)throw new Error("Non-zero carry");P=A,y++}for(var T=E-P;T!==E&&g[T]===0;)T++;for(var O=d.repeat(w);T<E;++T)O+=r.charAt(g[T]);return O}function u(l){if(typeof l!="string")throw new TypeError("Expected String");if(l.length===0)return new Uint8Array;var w=0;if(l[w]!==" "){for(var P=0,y=0;l[w]===d;)P++,w++;for(var S=(l.length-w)*c+1>>>0,E=new Uint8Array(S);l[w];){var g=t[l.charCodeAt(w)];if(g===255)return;for(var _=0,A=S-1;(g!==0||_<y)&&A!==-1;A--,_++)g+=a*E[A]>>>0,E[A]=g%256>>>0,g=g/256>>>0;if(g!==0)throw new Error("Non-zero carry");y=_,w++}if(l[w]!==" "){for(var x=S-y;x!==S&&E[x]===0;)x++;for(var T=new Uint8Array(P+(S-x)),O=P;x!==S;)T[O++]=E[x++];return T}}}function b(l){var w=u(l);if(w)return w;throw new Error(`Non-${e} character`)}return{encode:h,decodeUnsafe:u,decode:b}}var H=G,K=H;const D=r=>{if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")},Q=r=>new TextEncoder().encode(r),X=r=>new TextDecoder().decode(r);class Z{constructor(e,t,o){this.name=e,this.prefix=t,this.baseEncode=o}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class Y{constructor(e,t,o){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=o}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return F(this,e)}}class ee{constructor(e){this.decoders=e}or(e){return F(this,e)}decode(e){const t=e[0],o=this.decoders[t];if(o)return o.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const F=(r,e)=>new ee({...r.decoders||{[r.prefix]:r},...e.decoders||{[e.prefix]:e}});class re{constructor(e,t,o,s){this.name=e,this.prefix=t,this.baseEncode=o,this.baseDecode=s,this.encoder=new Z(e,t,o),this.decoder=new Y(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const C=({name:r,prefix:e,encode:t,decode:o})=>new re(r,e,t,o),M=({prefix:r,name:e,alphabet:t})=>{const{encode:o,decode:s}=K(t,e);return C({prefix:r,name:e,encode:o,decode:n=>D(s(n))})},te=(r,e,t,o)=>{const s={};for(let f=0;f<e.length;++f)s[e[f]]=f;let n=r.length;for(;r[n-1]==="=";)--n;const i=new Uint8Array(n*t/8|0);let a=0,d=0,c=0;for(let f=0;f<n;++f){const h=s[r[f]];if(h===void 0)throw new SyntaxError(`Non-${o} character`);d=d<<t|h,a+=t,a>=8&&(a-=8,i[c++]=255&d>>a)}if(a>=t||255&d<<8-a)throw new SyntaxError("Unexpected end of data");return i},ne=(r,e,t)=>{const o=e[e.length-1]==="=",s=(1<<t)-1;let n="",i=0,a=0;for(let d=0;d<r.length;++d)for(a=a<<8|r[d],i+=8;i>t;)i-=t,n+=e[s&a>>i];if(i&&(n+=e[s&a<<t-i]),o)for(;n.length*t&7;)n+="=";return n},p=({name:r,prefix:e,bitsPerChar:t,alphabet:o})=>C({prefix:e,name:r,encode(s){return ne(s,o,t)},decode(s){return te(s,o,t,r)}}),oe=C({prefix:"\0",name:"identity",encode:r=>X(r),decode:r=>Q(r)}),ae=Object.freeze(Object.defineProperty({__proto__:null,identity:oe},Symbol.toStringTag,{value:"Module"})),se=p({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),ie=Object.freeze(Object.defineProperty({__proto__:null,base2:se},Symbol.toStringTag,{value:"Module"})),ce=p({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),de=Object.freeze(Object.defineProperty({__proto__:null,base8:ce},Symbol.toStringTag,{value:"Module"})),le=M({prefix:"9",name:"base10",alphabet:"0123456789"}),he=Object.freeze(Object.defineProperty({__proto__:null,base10:le},Symbol.toStringTag,{value:"Module"})),ue=p({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),fe=p({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),pe=Object.freeze(Object.defineProperty({__proto__:null,base16:ue,base16upper:fe},Symbol.toStringTag,{value:"Module"})),be=p({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),we=p({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),me=p({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),ge=p({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),ye=p({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),xe=p({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),ve=p({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Se=p({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Ee=p({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),_e=Object.freeze(Object.defineProperty({__proto__:null,base32:be,base32hex:ye,base32hexpad:ve,base32hexpadupper:Se,base32hexupper:xe,base32pad:me,base32padupper:ge,base32upper:we,base32z:Ee},Symbol.toStringTag,{value:"Module"})),Te=M({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Ae=M({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),Pe=Object.freeze(Object.defineProperty({__proto__:null,base36:Te,base36upper:Ae},Symbol.toStringTag,{value:"Module"})),Me=M({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Oe=M({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),Ce=Object.freeze(Object.defineProperty({__proto__:null,base58btc:Me,base58flickr:Oe},Symbol.toStringTag,{value:"Module"})),$e=p({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Ue=p({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),je=p({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Ne=p({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),ze=Object.freeze(Object.defineProperty({__proto__:null,base64:$e,base64pad:Ue,base64url:je,base64urlpad:Ne},Symbol.toStringTag,{value:"Module"})),R=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),ke=R.reduce((r,e,t)=>(r[t]=e,r),[]),Ie=R.reduce((r,e,t)=>(r[e.codePointAt(0)]=t,r),[]);function De(r){return r.reduce((e,t)=>(e+=ke[t],e),"")}function Fe(r){const e=[];for(const t of r){const o=Ie[t.codePointAt(0)];if(o===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(o)}return new Uint8Array(e)}const Re=C({prefix:"🚀",name:"base256emoji",encode:De,decode:Fe}),We=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:Re},Symbol.toStringTag,{value:"Module"}));var Be=W,U=128,qe=127,Le=~qe,Ve=Math.pow(2,31);function W(r,e,t){e=e||[],t=t||0;for(var o=t;r>=Ve;)e[t++]=r&255|U,r/=128;for(;r&Le;)e[t++]=r&255|U,r>>>=7;return e[t]=r|0,W.bytes=t-o+1,e}var Je=$,Ge=128,j=127;function $(r,o){var t=0,o=o||0,s=0,n=o,i,a=r.length;do{if(n>=a)throw $.bytes=0,new RangeError("Could not decode varint");i=r[n++],t+=s<28?(i&j)<<s:(i&j)*Math.pow(2,s),s+=7}while(i>=Ge);return $.bytes=n-o,t}var He=Math.pow(2,7),Ke=Math.pow(2,14),Qe=Math.pow(2,21),Xe=Math.pow(2,28),Ze=Math.pow(2,35),Ye=Math.pow(2,42),er=Math.pow(2,49),rr=Math.pow(2,56),tr=Math.pow(2,63),nr=function(r){return r<He?1:r<Ke?2:r<Qe?3:r<Xe?4:r<Ze?5:r<Ye?6:r<er?7:r<rr?8:r<tr?9:10},or={encode:Be,decode:Je,encodingLength:nr},N=or;const z=(r,e=0)=>[N.decode(r,e),N.decode.bytes],ar=r=>{const e=D(r),[t,o]=z(e),[s,n]=z(e.subarray(o)),i=e.subarray(o+n);if(i.byteLength!==s)throw new Error("Incorrect length");return new sr(t,s,i,e)};class sr{constructor(e,t,o,s){this.code=e,this.size=t,this.digest=o,this.bytes=s}}new TextEncoder;new TextDecoder;const ir={...ae,...ie,...de,...he,...pe,..._e,...Pe,...Ce,...ze,...We},m=B("libp2p:webtransport"),cr=Object.values(ir).map(r=>r.decoder).reduce((r,e)=>r.or(e));function dr(r){return ar(cr.decode(r))}function k(){return{source:{[Symbol.asyncIterator](){return{async next(){return await new Promise(()=>{})}}}},sink:async r=>await new Promise(()=>{})}}async function I(r,e,t,o,s){const n=r.writable.getWriter(),i=r.readable.getReader();await n.ready;function a(){const u=o.findIndex(b=>b===h);u!==-1&&(o.splice(u,1),h.stat.timeline.close=Date.now(),s?.(h))}let d=!1,c=!1;(async function(){const u=await n.closed.catch(b=>b);if(u!=null){const b=u.message;b.includes("aborted by the remote server")||b.includes("STOP_SENDING")||m.error(`WebTransport writer closed unexpectedly: streamId=${e} err=${u.message}`)}d=!0,d&&c&&a()})().catch(()=>{m.error("WebTransport failed to cleanup closed stream")}),async function(){const u=await i.closed.catch(b=>b);u!=null&&m.error(`WebTransport reader closed unexpectedly: streamId=${e} err=${u.message}`),c=!0,d&&c&&a()}().catch(()=>{m.error("WebTransport failed to cleanup closed stream")});let f=!1;const h={id:e,abort(u){d||(n.abort(),d=!0),h.closeRead(),c=!0,a()},close(){h.closeRead(),h.closeWrite(),a()},closeRead(){c||(i.cancel().catch(u=>{u.toString().includes("RESET_STREAM")===!0&&(d=!0)}),c=!0),d&&a()},closeWrite(){d||(d=!0,n.close().catch(u=>{u.toString().includes("RESET_STREAM")===!0&&(c=!0)})),c&&a()},reset(){h.close()},stat:{direction:t,timeline:{open:Date.now()}},metadata:{},source:async function*(){for(;;){const u=await i.read();if(u.done===!0){c=!0,d&&a();return}yield new V(u.value)}}(),sink:async function(u){if(f)throw new Error("sink already called on stream");f=!0;try{for await(const b of u)if(b instanceof Uint8Array)await n.write(b);else for(const l of b)await n.write(l)}finally{h.closeWrite()}}};return h}function lr(r){const e=r.stringTuples(),{url:t,certhashes:o,remotePeer:s}=e.reduce((n,[i,a])=>{switch(i){case v("ip6").code:case v("dns6").code:a?.includes(":")===!0&&(a=`[${a}]`);case v("ip4").code:case v("dns4").code:if(n.seenHost||n.seenPort)throw new Error("Invalid multiaddr, saw host and already saw the host or port");return{...n,url:`${n.url}${a??""}`,seenHost:!0};case v("quic").code:case v("quic-v1").code:case v("webtransport").code:if(!n.seenHost||!n.seenPort)throw new Error("Invalid multiaddr, Didn't see host and port, but saw quic/webtransport");return n;case v("udp").code:if(n.seenPort)throw new Error("Invalid multiaddr, saw port but already saw the port");return{...n,url:`${n.url}:${a??""}`,seenPort:!0};case v("certhash").code:if(!n.seenHost||!n.seenPort)throw new Error("Invalid multiaddr, saw the certhash before seeing the host and port");return{...n,certhashes:n.certhashes.concat([dr(a??"")])};case v("p2p").code:return{...n,remotePeer:J(a??"")};default:throw new Error(`unexpected component in multiaddr: ${i} ${v(i).name} ${a??""} `)}},{url:"https://",seenHost:!1,seenPort:!1,certhashes:[]});return{url:t,certhashes:o,remotePeer:s}}function hr(r,e){return e.filter(o=>!!r.find(s=>{if(o.length!==s.length)return!1;for(let n=0;n<o.length;n++)if(s[n]!==o[n])return!1;return!0})).length===e.length}class ur{constructor(e,t={}){this.components=e,this.config={maxInboundStreams:t.maxInboundStreams??1e3}}get[Symbol.toStringTag](){return"@libp2p/webtransport"}get[q](){return!0}async dial(e,t){m("dialing %s",e);const o=this.components.peerId;if(o===void 0)throw new Error("Need a local peerid");t=t??{};const{url:s,certhashes:n,remotePeer:i}=lr(e);if(n.length===0)throw new Error("Expected multiaddr to contain certhashes");const a=new WebTransport(`${s}/.well-known/libp2p-webtransport?type=noise`,{serverCertificateHashes:n.map(c=>({algorithm:"sha-256",value:c.digest}))});if(a.closed.catch(c=>{m.error("WebTransport transport closed due to:",c)}),await a.ready,i==null)throw new Error("Need a target peerid");if(!await this.authenticateWebTransport(a,o,i,n))throw new Error("Failed to authenticate webtransport");const d={close:async c=>{c!=null&&m("Closing webtransport with err:",c),a.close()},remoteAddr:e,timeline:{open:Date.now()},...k()};a.closed.catch(c=>{m.error("WebTransport connection closed:",c),d.timeline.close=Date.now()});try{t?.signal?.throwIfAborted()}catch(c){throw a.close(),c}return await t.upgrader.upgradeOutbound(d,{skipEncryption:!0,muxerFactory:this.webtransportMuxer(a),skipProtection:!0})}async authenticateWebTransport(e,t,o,s){const n=await e.createBidirectionalStream(),i=n.writable.getWriter(),a=n.readable.getReader();await i.ready;const d={source:async function*(){for(;;){const h=await a.read();if(h.value!=null&&(yield h.value),h.done===!0)break}}(),sink:async function(h){for await(const u of h)await i.write(u)}},c=L()(),{remoteExtensions:f}=await c.secureOutbound(t,d,o);if(i.close().catch(h=>{m.error(`Failed to close authentication stream writer: ${h.message}`)}),a.cancel().catch(h=>{m.error(`Failed to close authentication stream reader: ${h.message}`)}),!hr(f?.webtransportCerthashes??[],s.map(h=>h.bytes)))throw new Error("Our certhashes are not a subset of the remote's reported certhashes");return!0}webtransportMuxer(e){let t=0;const o=this.config;return{protocol:"webtransport",createStreamMuxer:s=>{typeof s=="function"&&(s={onIncomingStream:s});const n=[];(async function(){//! TODO unclear how to add backpressure here?
const a=e.incomingBidirectionalStreams.getReader();for(;;){const{done:d,value:c}=await a.read();if(d===!0)break;if(n.length>=o.maxInboundStreams)c.writable.close().catch(f=>{m.error(`Failed to close inbound stream that crossed our maxInboundStream limit: ${f.message}`)}),c.readable.cancel().catch(f=>{m.error(`Failed to close inbound stream that crossed our maxInboundStream limit: ${f.message}`)});else{const f=await I(c,String(t++),"inbound",n,s?.onStreamEnd);n.push(f),s?.onIncomingStream?.(f)}}})().catch(()=>{m.error("WebTransport failed to receive incoming stream")});const i={protocol:"webtransport",streams:n,newStream:async a=>{const d=await e.createBidirectionalStream(),c=await I(d,String(t++),s?.direction??"outbound",n,s?.onStreamEnd);return n.push(c),c},close:a=>{a!=null&&m("Closing webtransport muxer with err:",a),e.close()},...k()};try{s?.signal?.throwIfAborted()}catch(a){throw e.close(),a}return i}}}createListener(e){throw new Error("Webtransport servers are not supported in Node or the browser")}filter(e){return e.filter(t=>t.protoNames().includes("webtransport"))}}function pr(r={}){return e=>new ur(e,r)}export{pr as w};
//# sourceMappingURL=index-VvH0mg31.js.map
