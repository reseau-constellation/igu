import{l as b,b as m,F as $,G as C,H as y,I as w,p as P,J as u,K as D,L as W,o as L,t as N,M as U,W as M,N as x,x as F,Q as G}from"./index-19e85f20.js";const k=421,H=290,B=2e3,f=b("libp2p:webrtc-star:socket");function R(i,e){const{sink:t,source:s}=i,n={remoteAddr:e.remoteAddr,async sink(r){e.signal!=null&&(r=m(r,e.signal));try{await t(r)}catch(l){l.type!=="aborted"&&f.error(l)}},source:e.signal!=null?m(s,e.signal):s,timeline:{open:Date.now()},async close(){if(i.closed)return;const r=Date.now(),l=setTimeout(()=>{if(n.remoteAddr!=null){const{host:o,port:a}=n.remoteAddr.toOptions();f("timeout closing socket to %s:%s after %dms, destroying it manually",o,a,Date.now()-r)}i.closed||i.close().catch(o=>{f.error("could not close socket",o)})},B);try{await i.close()}finally{clearTimeout(l)}}};return i.addEventListener("close",()=>{n.timeline.close==null&&(n.timeline.close=Date.now())},{once:!0}),n}function _(i){const e=i.toString().split("/"),t=i.protos()[1].name,s=i.protos()[2].name,n=i.stringTuples()[1][1];if(t!=="tcp"||s!=="ws"&&s!=="wss")throw new Error(`invalid multiaddr: ${i.toString()}`);if(!$(i))return`http://${e[2]}:${e[4]}`;if(s==="ws")return`http://${e[2]}${n==null||n==="80"?"":`:${n}`}`;if(s==="wss")return`https://${e[2]}${n==null||n==="443"?"":`:${n}`}`;throw new Error("invalid multiaddr: "+i.toString())}function K(i){const e="/libp2p-webrtc-star";if(i.startsWith(e)){i=i.substring(e.length,i.length);let t=C(i);const s=t.stringTuples().filter(n=>n[0]===421)[0];if(s[1]==null)throw new Error("invalid multiaddr: "+i);t=t.decapsulate("p2p"),t=t.encapsulate("/p2p-webrtc-star"),t=t.encapsulate(`/p2p/${s[1]}`),i=t.toString()}return i}const c=b("libp2p:webrtc-star:listener"),J={transports:["websocket"],path:"/socket.io-next/"};class Q extends y{constructor(e,t,s,n,r){super(),this.signallingAddr=t,this.socket=D(e,J),this.connections=[],this.channels=new Map,this.pendingSignals=new Map,this.upgrader=s,this.handler=n,this.channelOptions=r,this.handleWsHandshake=this.handleWsHandshake.bind(this);let l=!1;this.socket.on("connect_error",o=>{l&&o.type==="TransportError"||this.dispatchEvent(new u("error",{detail:o}))}),this.socket.on("error",o=>{this.dispatchEvent(new u("error",{detail:o}))}),this.socket.on("ws-handshake",this.handleWsHandshake),this.socket.on("ws-peer",o=>{this.dispatchEvent(new u("peer",{detail:o}))}),this.socket.on("connect",()=>{this.socket.emit("ss-join",this.signallingAddr.toString()),l&&this.dispatchEvent(new u("reconnect"))}),this.socket.once("connect",()=>{l=!0,this.dispatchEvent(new u("listening"))}),this.socket.on("disconnect",()=>{this.dispatchEvent(new u("disconnect"))})}_createChannel(e,t,s){const n={...this.channelOptions},r=new W(n),l=o=>{const a=o.detail;c.error("incoming connection errored",a)};return r.addEventListener("error",l),r.addEventListener("close",()=>{r.removeEventListener("error",l)},{once:!0}),r.addEventListener("signal",o=>{const a=o.detail;this.socket.emit("ss-handshake",{intentId:e,srcMultiaddr:t,dstMultiaddr:s,answer:!0,signal:a})}),r.addEventListener("ready",()=>{const o=R(r,{remoteAddr:this.signallingAddr});c("new inbound connection %s",o.remoteAddr);try{this.upgrader.upgradeInbound(o).then(a=>{c("inbound connection %s upgraded",o.remoteAddr),this.connections.push(o);const g=()=>{this.connections=this.connections.filter(h=>h!==o),this.channels.delete(e),this.pendingSignals.delete(e)};r.addEventListener("close",g,{once:!0}),this.dispatchEvent(new u("connection",{detail:a})),this.handler(a)}).catch(a=>{c.error("inbound connection failed to upgrade",a),o.close().catch(g=>{c.error("inbound connection failed to close after failing to upgrade",g)})})}catch(a){c.error("inbound connection failed to upgrade",a),o.close().catch(g=>{c.error("inbound connection failed to close after failing to upgrade",g)})}},{once:!0}),r}handleWsHandshake(e){if(c('incoming handshake. signal type "%s" is answer %s',e.signal.type,e.answer),e.answer===!0||e.err!=null||e.intentId==null)return;const t=e.intentId;let s=this.pendingSignals.get(t);s==null&&(s=[],this.pendingSignals.set(t,s)),s.push(e);let n=this.channels.get(t);if(n==null){if(e.signal.type!=="offer"){c("handshake is not an offer and channel does not exist, buffering until we receive an offer");return}c("creating new channel to handle offer handshake"),n=this._createChannel(e.intentId,e.srcMultiaddr,e.dstMultiaddr),this.channels.set(t,n)}else c("channel already exists, using it to handle handshake");for(;s.length>0;){const r=s.shift();r?.signal!=null&&n.handleSignal(r.signal)}}async close(){this.socket.emit("ss-leave",this.signallingAddr.toString()),this.socket.removeAllListeners(),this.socket.close(),await Promise.all([...this.connections.map(async e=>{await e.close()}),...Array.from(this.channels.values()).map(async e=>{await e.close()})]),this.dispatchEvent(new u("close"))}}class V extends y{constructor(e,t,s,n,r){super(),this.upgrader=e,this.handler=t,this.peerId=s,this.transport=n,this.options=r}async listen(e){if(this.listeningAddr!=null)throw w(new Error("listener already in use"),"ERR_ALREADY_LISTENING");const t=P();this.listeningAddr=e;let s;e.protoCodes().includes(k)?s=e:s=e.encapsulate(`/p2p/${this.peerId.toString()}`);const n=this.signallingUrl=_(e);c("connecting to signalling server on: %s",this.signallingUrl);const r=new Q(this.signallingUrl,s,this.upgrader,this.handler,this.options.channelOptions);r.addEventListener("error",l=>{const o=l.detail;c("error connecting to signalling server %o",o),r.close().catch(a=>{c.error("error closing server after error",a)}),t.reject(o)}),r.addEventListener("listening",()=>{c("connected to signalling server"),this.dispatchEvent(new u("listening")),t.resolve()}),r.addEventListener("peer",l=>{this.transport.peerDiscovered(l.detail)}),r.addEventListener("connection",l=>{const o=l.detail;if(o.remoteAddr==null)try{o.remoteAddr=e.decapsulateCode(k).encapsulate(`/p2p/${o.remotePeer.toString()}`)}catch(a){c.error("could not determine remote address",a)}this.dispatchEvent(new u("connection",{detail:o}))}),r.addEventListener("disconnect",()=>{this.transport.sigServers.delete(n)}),r.addEventListener("reconnect",()=>{this.transport.sigServers.set(n,r)}),this.transport.sigServers.set(this.signallingUrl,r),await t.promise}async close(){if(this.signallingUrl!=null){const e=this.transport.sigServers.get(this.signallingUrl);e!=null&&(await e.close(),this.transport.sigServers.delete(this.signallingUrl))}this.dispatchEvent(new u("close")),this.listeningAddr=void 0}getAddrs(){return this.listeningAddr!=null?[this.listeningAddr]:[]}}function Y(i,e,t,s,n){return new V(i,e,t,s,n)}const j=Symbol.for("@libp2p/transport");var I;(function(i){i[i.FATAL_ALL=0]="FATAL_ALL",i[i.NO_FATAL=1]="NO_FATAL"})(I||(I={}));const q="RTCPeerConnection"in globalThis,p=b("libp2p:webrtc-star"),z=()=>{};class X extends y{constructor(){super(...arguments),this.started=!1}get[G](){return!0}get[Symbol.toStringTag](){return"@libp2p/webrtc-star-discovery"}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}dispatchEvent(e){return this.isStarted()?super.dispatchEvent(e):!1}}class Z{constructor(e){e?.wrtc!=null&&(this.wrtc=e.wrtc),this.sigServers=new Map,this._discovery=new X,this.discovery=()=>this._discovery,this.peerDiscovered=this.peerDiscovered.bind(this)}get[j](){return!0}get[Symbol.toStringTag](){return"@libp2p/webrtc-star"}async dial(e,t){const s=await this._connect(e,t),n=R(s,{remoteAddr:e,signal:t.signal});p("new outbound connection %s",n.remoteAddr);const r=await t.upgrader.upgradeOutbound(n);return p("outbound connection %s upgraded",n.remoteAddr),r}async _connect(e,t){if(t.signal?.aborted===!0)throw new L;const s={...t.channelOptions??{}};this.wrtc!=null&&(s.wrtc=this.wrtc);const n=e.toOptions(),r=N(U(36),"hex");return await new Promise((l,o)=>{const a=this.sigServers.get(_(e));if(a?.socket==null){o(w(new Error("unknown signal server to use"),"ERR_UNKNOWN_SIGNAL_SERVER"));return}let g=!1;p("dialing %s:%s",n.host,n.port);const h=new M(s),T=d=>{const v=d.detail;if(!g){const O=`connection error ${n.host}:${n.port}: ${v.message}`;p.error(O),E(v)}},A=()=>{g=!0,p("connection opened %s:%s",n.host,n.port),E()},S=()=>{p.error("connection aborted %s:%s",n.host,n.port),h.close().finally(()=>{E(new L)})},E=d=>{h.removeEventListener("ready",A),t.signal?.removeEventListener("abort",S),d==null?l(h):o(d)};h.addEventListener("ready",A,{once:!0}),h.addEventListener("close",()=>{h.removeEventListener("error",T)}),t.signal?.addEventListener("abort",S),h.addEventListener("signal",d=>{const v=d.detail;a.socket.emit("ss-handshake",{intentId:r,srcMultiaddr:a.signallingAddr.toString(),dstMultiaddr:e.toString(),signal:v})}),a.socket.on("ws-handshake",d=>{d.intentId===r&&d.err!=null&&h.close().finally(()=>{o(w(new Error(d.err),"ERR_SIGNALLING_FAILED"))}),!(d.intentId!==r||d.answer==null||h.closed)&&h.handleSignal(d.signal)})})}createListener(e){if(!q&&this.wrtc==null)throw w(new Error("no WebRTC support"),"ERR_NO_WEBRTC_SUPPORT");if(e.channelOptions=e.channelOptions??{},this.wrtc!=null&&(e.channelOptions.wrtc=this.wrtc),this.peerId==null)throw w(new Error("PeerId not set"),"ERR_MISSING_PEER_ID");return Y(e.upgrader,e.handler??z,this.peerId,this,e)}filter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>t.protoCodes().includes(H)?!1:x.matches(t))}peerDiscovered(e){p("peer discovered: %s",e),e=K(e);const t=C(e),s=t.getPeerId();if(s==null)return;const n=F(s);this._discovery.dispatchEvent(new u("peer",{detail:{id:n,multiaddrs:[t],protocols:[]}}))}}function te(i={}){const e=new Z(i);return{transport:t=>(e.peerId=t.peerId,e),discovery:e.discovery}}export{te as w};
//# sourceMappingURL=index-a40c67b4.js.map
