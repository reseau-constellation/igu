import{l as ie,s as ce,n as fe,p as le}from"./index-ItWRpVzo.js";var W;(function(r){r.Accept="accept",r.Ignore="ignore",r.Reject="reject"})(W||(W={}));var q;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(q||(q={}));function ue(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function be(r){return new TextEncoder().encode(r)}function he(r){return new TextDecoder().decode(r)}function de(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var o=0;o<r.length;o++){var a=r.charAt(o),i=a.charCodeAt(0);if(t[i]!==255)throw new TypeError(a+" is ambiguous");t[i]=o}var s=r.length,f=r.charAt(0),u=Math.log(s)/Math.log(256),b=Math.log(256)/Math.log(s);function l(c){if(c instanceof Uint8Array||(ArrayBuffer.isView(c)?c=new Uint8Array(c.buffer,c.byteOffset,c.byteLength):Array.isArray(c)&&(c=Uint8Array.from(c))),!(c instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(c.length===0)return"";for(var d=0,E=0,w=0,y=c.length;w!==y&&c[w]===0;)w++,d++;for(var m=(y-w)*b+1>>>0,p=new Uint8Array(m);w!==y;){for(var v=c[w],$=0,g=m-1;(v!==0||$<E)&&g!==-1;g--,$++)v+=256*p[g]>>>0,p[g]=v%s>>>0,v=v/s>>>0;if(v!==0)throw new Error("Non-zero carry");E=$,w++}for(var A=m-E;A!==m&&p[A]===0;)A++;for(var P=f.repeat(d);A<m;++A)P+=r.charAt(p[A]);return P}function h(c){if(typeof c!="string")throw new TypeError("Expected String");if(c.length===0)return new Uint8Array;var d=0;if(c[d]!==" "){for(var E=0,w=0;c[d]===f;)E++,d++;for(var y=(c.length-d)*u+1>>>0,m=new Uint8Array(y);c[d];){var p=t[c.charCodeAt(d)];if(p===255)return;for(var v=0,$=y-1;(p!==0||v<w)&&$!==-1;$--,v++)p+=s*m[$]>>>0,m[$]=p%256>>>0,p=p/256>>>0;if(p!==0)throw new Error("Non-zero carry");w=v,d++}if(c[d]!==" "){for(var g=y-w;g!==y&&m[g]===0;)g++;for(var A=new Uint8Array(E+(y-g)),P=E;g!==y;)A[P++]=m[g++];return A}}}function x(c){var d=h(c);if(d)return d;throw new Error(`Non-${e} character`)}return{encode:l,decodeUnsafe:h,decode:x}}var pe=de,we=pe;let ge=class{name;prefix;baseEncode;constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},ye=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,n){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return ee(this,e)}},me=class{decoders;constructor(e){this.decoders=e}or(e){return ee(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n!=null)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};function ee(r,e){return new me({...r.decoders??{[r.prefix]:r},...e.decoders??{[e.prefix]:e}})}let ve=class{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,n,o){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=o,this.encoder=new ge(e,t,n),this.decoder=new ye(e,t,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};function k({name:r,prefix:e,encode:t,decode:n}){return new ve(r,e,t,n)}function L({name:r,prefix:e,alphabet:t}){const{encode:n,decode:o}=we(t,r);return k({prefix:e,name:r,encode:n,decode:a=>ue(o(a))})}function xe(r,e,t,n){const o={};for(let b=0;b<e.length;++b)o[e[b]]=b;let a=r.length;for(;r[a-1]==="=";)--a;const i=new Uint8Array(a*t/8|0);let s=0,f=0,u=0;for(let b=0;b<a;++b){const l=o[r[b]];if(l===void 0)throw new SyntaxError(`Non-${n} character`);f=f<<t|l,s+=t,s>=8&&(s-=8,i[u++]=255&f>>s)}if(s>=t||255&f<<8-s)throw new SyntaxError("Unexpected end of data");return i}function Ae(r,e,t){const n=e[e.length-1]==="=",o=(1<<t)-1;let a="",i=0,s=0;for(let f=0;f<r.length;++f)for(s=s<<8|r[f],i+=8;i>t;)i-=t,a+=e[o&s>>i];if(i!==0&&(a+=e[o&s<<t-i]),n)for(;a.length*t&7;)a+="=";return a}function U({name:r,prefix:e,bitsPerChar:t,alphabet:n}){return k({prefix:e,name:r,encode(o){return Ae(o,n,t)},decode(o){return xe(o,n,t,r)}})}const Se=L({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),$e=L({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),Ue=Object.freeze(Object.defineProperty({__proto__:null,base58btc:Se,base58flickr:$e},Symbol.toStringTag,{value:"Module"})),_e=U({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Ee=U({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Oe=U({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Te=U({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Pe=U({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Ce=U({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),je=U({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Le=U({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Me=U({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),De=Object.freeze(Object.defineProperty({__proto__:null,base32:_e,base32hex:Pe,base32hexpad:je,base32hexpadupper:Le,base32hexupper:Ce,base32pad:Oe,base32padupper:Te,base32upper:Ee,base32z:Me},Symbol.toStringTag,{value:"Module"})),ze=L({prefix:"9",name:"base10",alphabet:"0123456789"}),ke=Object.freeze(Object.defineProperty({__proto__:null,base10:ze},Symbol.toStringTag,{value:"Module"})),Be=U({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Ne=U({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Fe=Object.freeze(Object.defineProperty({__proto__:null,base16:Be,base16upper:Ne},Symbol.toStringTag,{value:"Module"})),Ve=U({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),Ie=Object.freeze(Object.defineProperty({__proto__:null,base2:Ve},Symbol.toStringTag,{value:"Module"})),te=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),Re=te.reduce((r,e,t)=>(r[t]=e,r),[]),We=te.reduce((r,e,t)=>(r[e.codePointAt(0)]=t,r),[]);function qe(r){return r.reduce((e,t)=>(e+=Re[t],e),"")}function Je(r){const e=[];for(const t of r){const n=We[t.codePointAt(0)];if(n===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(n)}return new Uint8Array(e)}const Ke=k({prefix:"🚀",name:"base256emoji",encode:qe,decode:Je}),Ge=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:Ke},Symbol.toStringTag,{value:"Module"})),Qe=L({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Xe=L({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),Ze=Object.freeze(Object.defineProperty({__proto__:null,base36:Qe,base36upper:Xe},Symbol.toStringTag,{value:"Module"})),He=U({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Ye=U({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),et=U({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),tt=U({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),rt=Object.freeze(Object.defineProperty({__proto__:null,base64:He,base64pad:Ye,base64url:et,base64urlpad:tt},Symbol.toStringTag,{value:"Module"})),nt=U({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),ot=Object.freeze(Object.defineProperty({__proto__:null,base8:nt},Symbol.toStringTag,{value:"Module"})),at=k({prefix:"\0",name:"identity",encode:r=>he(r),decode:r=>be(r)}),st=Object.freeze(Object.defineProperty({__proto__:null,identity:at},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const it={...st,...Ie,...ot,...ke,...Fe,...De,...Ze,...Ue,...rt,...Ge},T=-1,F={},V={},ct=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,T,"ip6zone"],[43,8,"ipcidr"],[53,T,"dns",!0],[54,T,"dns4",!0],[55,T,"dns6",!0],[56,T,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,T,"unix",!1,!0],[421,T,"ipfs"],[421,T,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,T,"garlic64"],[448,0,"tls"],[449,T,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,T,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[777,T,"memory"]];ct.forEach(r=>{const e=ft(...r);V[e.code]=e,F[e.name]=e});function ft(r,e,t,n,o){return{code:r,size:e,name:t,resolvable:!!n,path:!!o}}function S(r){if(typeof r=="number"){if(V[r]!=null)return V[r];throw new Error(`no protocol with code: ${r}`)}else if(typeof r=="string"){if(F[r]!=null)return F[r];throw new Error(`no protocol with name: ${r}`)}throw new Error(`invalid protocol id type: ${typeof r}`)}S("ip4");S("ip6");S("ipcidr");const N=Object.values(it).map(r=>r.decoder);(function(){let r=N[0].or(N[1]);return N.slice(2).forEach(e=>r=r.or(e)),r})();S("dns").code,S("dns4").code,S("dns6").code,S("dnsaddr").code;function lt(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var o=0;o<r.length;o++){var a=r.charAt(o),i=a.charCodeAt(0);if(t[i]!==255)throw new TypeError(a+" is ambiguous");t[i]=o}var s=r.length,f=r.charAt(0),u=Math.log(s)/Math.log(256),b=Math.log(256)/Math.log(s);function l(c){if(c instanceof Uint8Array||(ArrayBuffer.isView(c)?c=new Uint8Array(c.buffer,c.byteOffset,c.byteLength):Array.isArray(c)&&(c=Uint8Array.from(c))),!(c instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(c.length===0)return"";for(var d=0,E=0,w=0,y=c.length;w!==y&&c[w]===0;)w++,d++;for(var m=(y-w)*b+1>>>0,p=new Uint8Array(m);w!==y;){for(var v=c[w],$=0,g=m-1;(v!==0||$<E)&&g!==-1;g--,$++)v+=256*p[g]>>>0,p[g]=v%s>>>0,v=v/s>>>0;if(v!==0)throw new Error("Non-zero carry");E=$,w++}for(var A=m-E;A!==m&&p[A]===0;)A++;for(var P=f.repeat(d);A<m;++A)P+=r.charAt(p[A]);return P}function h(c){if(typeof c!="string")throw new TypeError("Expected String");if(c.length===0)return new Uint8Array;var d=0;if(c[d]!==" "){for(var E=0,w=0;c[d]===f;)E++,d++;for(var y=(c.length-d)*u+1>>>0,m=new Uint8Array(y);c[d];){var p=t[c.charCodeAt(d)];if(p===255)return;for(var v=0,$=y-1;(p!==0||v<w)&&$!==-1;$--,v++)p+=s*m[$]>>>0,m[$]=p%256>>>0,p=p/256>>>0;if(p!==0)throw new Error("Non-zero carry");w=v,d++}if(c[d]!==" "){for(var g=y-w;g!==y&&m[g]===0;)g++;for(var A=new Uint8Array(E+(y-g)),P=E;g!==y;)A[P++]=m[g++];return A}}}function x(c){var d=h(c);if(d)return d;throw new Error(`Non-${e} character`)}return{encode:l,decodeUnsafe:h,decode:x}}var ut=lt,bt=ut;const re=r=>{if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")},ht=r=>new TextEncoder().encode(r),dt=r=>new TextDecoder().decode(r);class pt{constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class wt{constructor(e,t,n){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return ne(this,e)}}class gt{constructor(e){this.decoders=e}or(e){return ne(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const ne=(r,e)=>new gt({...r.decoders||{[r.prefix]:r},...e.decoders||{[e.prefix]:e}});class yt{constructor(e,t,n,o){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=o,this.encoder=new pt(e,t,n),this.decoder=new wt(e,t,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const B=({name:r,prefix:e,encode:t,decode:n})=>new yt(r,e,t,n),M=({prefix:r,name:e,alphabet:t})=>{const{encode:n,decode:o}=bt(t,e);return B({prefix:r,name:e,encode:n,decode:a=>re(o(a))})},mt=(r,e,t,n)=>{const o={};for(let b=0;b<e.length;++b)o[e[b]]=b;let a=r.length;for(;r[a-1]==="=";)--a;const i=new Uint8Array(a*t/8|0);let s=0,f=0,u=0;for(let b=0;b<a;++b){const l=o[r[b]];if(l===void 0)throw new SyntaxError(`Non-${n} character`);f=f<<t|l,s+=t,s>=8&&(s-=8,i[u++]=255&f>>s)}if(s>=t||255&f<<8-s)throw new SyntaxError("Unexpected end of data");return i},vt=(r,e,t)=>{const n=e[e.length-1]==="=",o=(1<<t)-1;let a="",i=0,s=0;for(let f=0;f<r.length;++f)for(s=s<<8|r[f],i+=8;i>t;)i-=t,a+=e[o&s>>i];if(i&&(a+=e[o&s<<t-i]),n)for(;a.length*t&7;)a+="=";return a},_=({name:r,prefix:e,bitsPerChar:t,alphabet:n})=>B({prefix:e,name:r,encode(o){return vt(o,n,t)},decode(o){return mt(o,n,t,r)}}),xt=B({prefix:"\0",name:"identity",encode:r=>dt(r),decode:r=>ht(r)}),At=Object.freeze(Object.defineProperty({__proto__:null,identity:xt},Symbol.toStringTag,{value:"Module"})),St=_({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),$t=Object.freeze(Object.defineProperty({__proto__:null,base2:St},Symbol.toStringTag,{value:"Module"})),Ut=_({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),_t=Object.freeze(Object.defineProperty({__proto__:null,base8:Ut},Symbol.toStringTag,{value:"Module"})),Et=M({prefix:"9",name:"base10",alphabet:"0123456789"}),Ot=Object.freeze(Object.defineProperty({__proto__:null,base10:Et},Symbol.toStringTag,{value:"Module"})),Tt=_({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Pt=_({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Ct=Object.freeze(Object.defineProperty({__proto__:null,base16:Tt,base16upper:Pt},Symbol.toStringTag,{value:"Module"})),jt=_({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Lt=_({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Mt=_({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Dt=_({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),zt=_({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),kt=_({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Bt=_({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Nt=_({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Ft=_({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),Vt=Object.freeze(Object.defineProperty({__proto__:null,base32:jt,base32hex:zt,base32hexpad:Bt,base32hexpadupper:Nt,base32hexupper:kt,base32pad:Mt,base32padupper:Dt,base32upper:Lt,base32z:Ft},Symbol.toStringTag,{value:"Module"})),It=M({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Rt=M({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),Wt=Object.freeze(Object.defineProperty({__proto__:null,base36:It,base36upper:Rt},Symbol.toStringTag,{value:"Module"})),qt=M({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Jt=M({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),Kt=Object.freeze(Object.defineProperty({__proto__:null,base58btc:qt,base58flickr:Jt},Symbol.toStringTag,{value:"Module"})),Gt=_({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Qt=_({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Xt=_({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Zt=_({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),Ht=Object.freeze(Object.defineProperty({__proto__:null,base64:Gt,base64pad:Qt,base64url:Xt,base64urlpad:Zt},Symbol.toStringTag,{value:"Module"})),oe=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),Yt=oe.reduce((r,e,t)=>(r[t]=e,r),[]),er=oe.reduce((r,e,t)=>(r[e.codePointAt(0)]=t,r),[]);function tr(r){return r.reduce((e,t)=>(e+=Yt[t],e),"")}function rr(r){const e=[];for(const t of r){const n=er[t.codePointAt(0)];if(n===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(n)}return new Uint8Array(e)}const nr=B({prefix:"🚀",name:"base256emoji",encode:tr,decode:rr}),or=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:nr},Symbol.toStringTag,{value:"Module"}));var ar=ae,J=128,sr=127,ir=~sr,cr=Math.pow(2,31);function ae(r,e,t){e=e||[],t=t||0;for(var n=t;r>=cr;)e[t++]=r&255|J,r/=128;for(;r&ir;)e[t++]=r&255|J,r>>>=7;return e[t]=r|0,ae.bytes=t-n+1,e}var fr=I,lr=128,K=127;function I(r,n){var t=0,n=n||0,o=0,a=n,i,s=r.length;do{if(a>=s)throw I.bytes=0,new RangeError("Could not decode varint");i=r[a++],t+=o<28?(i&K)<<o:(i&K)*Math.pow(2,o),o+=7}while(i>=lr);return I.bytes=a-n,t}var ur=Math.pow(2,7),br=Math.pow(2,14),hr=Math.pow(2,21),dr=Math.pow(2,28),pr=Math.pow(2,35),wr=Math.pow(2,42),gr=Math.pow(2,49),yr=Math.pow(2,56),mr=Math.pow(2,63),vr=function(r){return r<ur?1:r<br?2:r<hr?3:r<dr?4:r<pr?5:r<wr?6:r<gr?7:r<yr?8:r<mr?9:10},xr={encode:ar,decode:fr,encodingLength:vr},G=xr;const Q=(r,e=0)=>[G.decode(r,e),G.decode.bytes],Ar=r=>{const e=re(r),[t,n]=Q(e),[o,a]=Q(e.subarray(n)),i=e.subarray(n+a);if(i.byteLength!==o)throw new Error("Incorrect length");return new Sr(t,o,i,e)};class Sr{constructor(e,t,n,o){this.code=e,this.size=t,this.digest=n,this.bytes=o}}new TextEncoder;new TextDecoder;const $r={...At,...$t,..._t,...Ot,...Ct,...Vt,...Wt,...Kt,...Ht,...or};function z(r){return globalThis.Buffer!=null?new Uint8Array(r.buffer,r.byteOffset,r.byteLength):r}function C(r=0){return globalThis.Buffer?.alloc!=null?z(globalThis.Buffer.alloc(r)):new Uint8Array(r)}function R(r=0){return globalThis.Buffer?.allocUnsafe!=null?z(globalThis.Buffer.allocUnsafe(r)):new Uint8Array(r)}function X(r,e){if(globalThis.Buffer!=null)return z(globalThis.Buffer.concat(r,e));e==null&&(e=r.reduce((o,a)=>o+a.length,0));const t=R(e);let n=0;for(const o of r)t.set(o,n),n+=o.length;return z(t)}function Ur(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}const se=Symbol.for("@achingbrain/uint8arraylist");function Z(r,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const n of r){const o=t+n.byteLength;if(e<o)return{buf:n,index:e-t};t=o}throw new RangeError("index is out of bounds")}function D(r){return!!r?.[se]}class j{bufs;length;[se]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const n of e)if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.push(n);else if(D(n))t+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const n of e.reverse())if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.unshift(n);else if(D(n))t+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=Z(this.bufs,e);return t.buf[t.index]}set(e,t){const n=Z(this.bufs,e);n.buf[n.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let n=0;n<e.length;n++)this.set(t+n,e[n]);else if(D(e))for(let n=0;n<e.length;n++)this.set(t+n,e.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:n,length:o}=this._subList(e,t);return X(n,o)}subarray(e,t){const{bufs:n,length:o}=this._subList(e,t);return n.length===1?n[0]:X(n,o)}sublist(e,t){const{bufs:n,length:o}=this._subList(e,t),a=new j;return a.length=o,a.bufs=[...n],a}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};const n=[];let o=0;for(let a=0;a<this.bufs.length;a++){const i=this.bufs[a],s=o,f=s+i.byteLength;if(o=f,e>=f)continue;const u=e>=s&&e<f,b=t>s&&t<=f;if(u&&b){if(e===s&&t===f){n.push(i);break}const l=e-s;n.push(i.subarray(l,l+(t-e)));break}if(u){if(e===0){n.push(i);continue}n.push(i.subarray(e-s));continue}if(b){if(t===f){n.push(i);break}n.push(i.subarray(0,t-s));break}n.push(i)}return{bufs:n,length:t-e}}indexOf(e,t=0){if(!D(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const o=n.byteLength;if(o===0)throw new TypeError("search must be at least 1 byte long");const a=256,i=new Int32Array(a);for(let l=0;l<a;l++)i[l]=-1;for(let l=0;l<o;l++)i[n[l]]=l;const s=i,f=this.byteLength-n.byteLength,u=n.byteLength-1;let b;for(let l=t;l<=f;l+=b){b=0;for(let h=u;h>=0;h--){const x=this.get(l+h);if(n[h]!==x){b=Math.max(1,h-s[x]);break}}if(b===0)return l}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const n=R(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,t),this.write(n,e)}getInt16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,t)}setInt16(e,t,n){const o=C(2);new DataView(o.buffer,o.byteOffset,o.byteLength).setInt16(0,t,n),this.write(o,e)}getInt32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,t)}setInt32(e,t,n){const o=C(4);new DataView(o.buffer,o.byteOffset,o.byteLength).setInt32(0,t,n),this.write(o,e)}getBigInt64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,t)}setBigInt64(e,t,n){const o=C(8);new DataView(o.buffer,o.byteOffset,o.byteLength).setBigInt64(0,t,n),this.write(o,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const n=R(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,t),this.write(n,e)}getUint16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,t)}setUint16(e,t,n){const o=C(2);new DataView(o.buffer,o.byteOffset,o.byteLength).setUint16(0,t,n),this.write(o,e)}getUint32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,t)}setUint32(e,t,n){const o=C(4);new DataView(o.buffer,o.byteOffset,o.byteLength).setUint32(0,t,n),this.write(o,e)}getBigUint64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,t)}setBigUint64(e,t,n){const o=C(8);new DataView(o.buffer,o.byteOffset,o.byteLength).setBigUint64(0,t,n),this.write(o,e)}getFloat32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,t)}setFloat32(e,t,n){const o=C(4);new DataView(o.buffer,o.byteOffset,o.byteLength).setFloat32(0,t,n),this.write(o,e)}getFloat64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,t)}setFloat64(e,t,n){const o=C(8);new DataView(o.buffer,o.byteOffset,o.byteLength).setFloat64(0,t,n),this.write(o,e)}equals(e){if(e==null||!(e instanceof j)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!Ur(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const n=new j;return n.bufs=e,t==null&&(t=e.reduce((o,a)=>o+a.byteLength,0)),n.length=t,n}}const O=ie("libp2p:webtransport"),_r=Object.values($r).map(r=>r.decoder).reduce((r,e)=>r.or(e));function Er(r){return Ar(_r.decode(r))}function H(){return{source:{[Symbol.asyncIterator](){return{async next(){return await new Promise(()=>{})}}}},sink:async r=>await new Promise(()=>{})}}async function Y(r,e,t,n,o){const a=r.writable.getWriter(),i=r.readable.getReader();await a.ready;function s(){const h=n.findIndex(x=>x===l);h!==-1&&(n.splice(h,1),l.stat.timeline.close=Date.now(),o?.(l))}let f=!1,u=!1;(async function(){const h=await a.closed.catch(x=>x);if(h!=null){const x=h.message;x.includes("aborted by the remote server")||x.includes("STOP_SENDING")||O.error(`WebTransport writer closed unexpectedly: streamId=${e} err=${h.message}`)}f=!0,f&&u&&s()})().catch(()=>{O.error("WebTransport failed to cleanup closed stream")}),async function(){const h=await i.closed.catch(x=>x);h!=null&&O.error(`WebTransport reader closed unexpectedly: streamId=${e} err=${h.message}`),u=!0,f&&u&&s()}().catch(()=>{O.error("WebTransport failed to cleanup closed stream")});let b=!1;const l={id:e,abort(h){f||(a.abort(),f=!0),l.closeRead(),u=!0,s()},close(){l.closeRead(),l.closeWrite(),s()},closeRead(){u||(i.cancel().catch(h=>{h.toString().includes("RESET_STREAM")===!0&&(f=!0)}),u=!0),f&&s()},closeWrite(){f||(f=!0,a.close().catch(h=>{h.toString().includes("RESET_STREAM")===!0&&(u=!0)})),u&&s()},reset(){l.close()},stat:{direction:t,timeline:{open:Date.now()}},metadata:{},source:async function*(){for(;;){const h=await i.read();if(h.done===!0){u=!0,f&&s();return}yield new j(h.value)}}(),sink:async function(h){if(b)throw new Error("sink already called on stream");b=!0;try{for await(const x of h)if(x instanceof Uint8Array)await a.write(x);else for(const c of x)await a.write(c)}finally{l.closeWrite()}}};return l}function Or(r){const e=r.stringTuples(),{url:t,certhashes:n,remotePeer:o}=e.reduce((a,[i,s])=>{switch(i){case S("ip6").code:case S("dns6").code:s?.includes(":")===!0&&(s=`[${s}]`);case S("ip4").code:case S("dns4").code:if(a.seenHost||a.seenPort)throw new Error("Invalid multiaddr, saw host and already saw the host or port");return{...a,url:`${a.url}${s??""}`,seenHost:!0};case S("quic").code:case S("quic-v1").code:case S("webtransport").code:if(!a.seenHost||!a.seenPort)throw new Error("Invalid multiaddr, Didn't see host and port, but saw quic/webtransport");return a;case S("udp").code:if(a.seenPort)throw new Error("Invalid multiaddr, saw port but already saw the port");return{...a,url:`${a.url}:${s??""}`,seenPort:!0};case S("certhash").code:if(!a.seenHost||!a.seenPort)throw new Error("Invalid multiaddr, saw the certhash before seeing the host and port");return{...a,certhashes:a.certhashes.concat([Er(s??"")])};case S("p2p").code:return{...a,remotePeer:le(s??"")};default:throw new Error(`unexpected component in multiaddr: ${i} ${S(i).name} ${s??""} `)}},{url:"https://",seenHost:!1,seenPort:!1,certhashes:[]});return{url:t,certhashes:n,remotePeer:o}}function Tr(r,e){return e.filter(n=>!!r.find(o=>{if(n.length!==o.length)return!1;for(let a=0;a<n.length;a++)if(o[a]!==n[a])return!1;return!0})).length===e.length}class Pr{constructor(e,t={}){this.components=e,this.config={maxInboundStreams:t.maxInboundStreams??1e3}}get[Symbol.toStringTag](){return"@libp2p/webtransport"}get[ce](){return!0}async dial(e,t){O("dialing %s",e);const n=this.components.peerId;if(n===void 0)throw new Error("Need a local peerid");t=t??{};const{url:o,certhashes:a,remotePeer:i}=Or(e);if(a.length===0)throw new Error("Expected multiaddr to contain certhashes");const s=new WebTransport(`${o}/.well-known/libp2p-webtransport?type=noise`,{serverCertificateHashes:a.map(u=>({algorithm:"sha-256",value:u.digest}))});if(s.closed.catch(u=>{O.error("WebTransport transport closed due to:",u)}),await s.ready,i==null)throw new Error("Need a target peerid");if(!await this.authenticateWebTransport(s,n,i,a))throw new Error("Failed to authenticate webtransport");const f={close:async u=>{u!=null&&O("Closing webtransport with err:",u),s.close()},remoteAddr:e,timeline:{open:Date.now()},...H()};s.closed.catch(u=>{O.error("WebTransport connection closed:",u),f.timeline.close=Date.now()});try{t?.signal?.throwIfAborted()}catch(u){throw s.close(),u}return await t.upgrader.upgradeOutbound(f,{skipEncryption:!0,muxerFactory:this.webtransportMuxer(s),skipProtection:!0})}async authenticateWebTransport(e,t,n,o){const a=await e.createBidirectionalStream(),i=a.writable.getWriter(),s=a.readable.getReader();await i.ready;const f={source:async function*(){for(;;){const l=await s.read();if(l.value!=null&&(yield l.value),l.done===!0)break}}(),sink:async function(l){for await(const h of l)await i.write(h)}},u=fe()(),{remoteExtensions:b}=await u.secureOutbound(t,f,n);if(i.close().catch(l=>{O.error(`Failed to close authentication stream writer: ${l.message}`)}),s.cancel().catch(l=>{O.error(`Failed to close authentication stream reader: ${l.message}`)}),!Tr(b?.webtransportCerthashes??[],o.map(l=>l.bytes)))throw new Error("Our certhashes are not a subset of the remote's reported certhashes");return!0}webtransportMuxer(e){let t=0;const n=this.config;return{protocol:"webtransport",createStreamMuxer:o=>{typeof o=="function"&&(o={onIncomingStream:o});const a=[];(async function(){//! TODO unclear how to add backpressure here?
const s=e.incomingBidirectionalStreams.getReader();for(;;){const{done:f,value:u}=await s.read();if(f===!0)break;if(a.length>=n.maxInboundStreams)u.writable.close().catch(b=>{O.error(`Failed to close inbound stream that crossed our maxInboundStream limit: ${b.message}`)}),u.readable.cancel().catch(b=>{O.error(`Failed to close inbound stream that crossed our maxInboundStream limit: ${b.message}`)});else{const b=await Y(u,String(t++),"inbound",a,o?.onStreamEnd);a.push(b),o?.onIncomingStream?.(b)}}})().catch(()=>{O.error("WebTransport failed to receive incoming stream")});const i={protocol:"webtransport",streams:a,newStream:async s=>{const f=await e.createBidirectionalStream(),u=await Y(f,String(t++),o?.direction??"outbound",a,o?.onStreamEnd);return a.push(u),u},close:s=>{s!=null&&O("Closing webtransport muxer with err:",s),e.close()},...H()};try{o?.signal?.throwIfAborted()}catch(s){throw e.close(),s}return i}}}createListener(e){throw new Error("Webtransport servers are not supported in Node or the browser")}filter(e){return e.filter(t=>t.protoNames().includes("webtransport"))}}function zr(r={}){return e=>new Pr(e,r)}export{zr as w};
//# sourceMappingURL=index-RLK5aQjv.js.map
