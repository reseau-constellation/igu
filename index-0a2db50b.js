import{l as b,a as S,i as $,m as C,E as y,e as w,c as P,C as u,d as D,f as W,A as L,r as N,W as U,h as M,p as x,j as F}from"./index-067efd29.js";import{t as G}from"./index-2b10586a.js";const k=421,H=290,B=2e3,f=b("libp2p:webrtc-star:socket");function R(i,e){const{sink:t,source:s}=i,n={remoteAddr:e.remoteAddr,async sink(r){e.signal!=null&&(r=S(r,e.signal));try{await t(r)}catch(c){c.type!=="aborted"&&f.error(c)}},source:e.signal!=null?S(s,e.signal):s,timeline:{open:Date.now()},async close(){if(i.closed)return;const r=Date.now(),c=setTimeout(()=>{if(n.remoteAddr!=null){const{host:o,port:a}=n.remoteAddr.toOptions();f("timeout closing socket to %s:%s after %dms, destroying it manually",o,a,Date.now()-r)}i.closed||i.close().catch(o=>{f.error("could not close socket",o)})},B);try{await i.close()}finally{clearTimeout(c)}}};return i.addEventListener("close",()=>{n.timeline.close==null&&(n.timeline.close=Date.now())},{once:!0}),n}function _(i){const e=i.toString().split("/"),t=i.protos()[1].name,s=i.protos()[2].name,n=i.stringTuples()[1][1];if(t!=="tcp"||s!=="ws"&&s!=="wss")throw new Error(`invalid multiaddr: ${i.toString()}`);if(!$(i))return`http://${e[2]}:${e[4]}`;if(s==="ws")return`http://${e[2]}${n==null||n==="80"?"":`:${n}`}`;if(s==="wss")return`https://${e[2]}${n==null||n==="443"?"":`:${n}`}`;throw new Error("invalid multiaddr: "+i.toString())}function j(i){const e="/libp2p-webrtc-star";if(i.startsWith(e)){i=i.substring(e.length,i.length);let t=C(i);const s=t.stringTuples().filter(n=>n[0]===421)[0];if(s[1]==null)throw new Error("invalid multiaddr: "+i);t=t.decapsulate("p2p"),t=t.encapsulate("/p2p-webrtc-star"),t=t.encapsulate(`/p2p/${s[1]}`),i=t.toString()}return i}const l=b("libp2p:webrtc-star:listener"),K={transports:["websocket"],path:"/socket.io-next/"};class V extends y{constructor(e,t,s,n,r){super(),this.signallingAddr=t,this.socket=D(e,K),this.connections=[],this.channels=new Map,this.pendingSignals=new Map,this.upgrader=s,this.handler=n,this.channelOptions=r,this.handleWsHandshake=this.handleWsHandshake.bind(this);let c=!1;this.socket.on("connect_error",o=>{c&&o.type==="TransportError"||this.dispatchEvent(new u("error",{detail:o}))}),this.socket.on("error",o=>{this.dispatchEvent(new u("error",{detail:o}))}),this.socket.on("ws-handshake",this.handleWsHandshake),this.socket.on("ws-peer",o=>{this.dispatchEvent(new u("peer",{detail:o}))}),this.socket.on("connect",()=>{this.socket.emit("ss-join",this.signallingAddr.toString()),c&&this.dispatchEvent(new u("reconnect"))}),this.socket.once("connect",()=>{c=!0,this.dispatchEvent(new u("listening"))}),this.socket.on("disconnect",()=>{this.dispatchEvent(new u("disconnect"))})}_createChannel(e,t,s){const n={...this.channelOptions},r=new W(n),c=o=>{const a=o.detail;l.error("incoming connection errored",a)};return r.addEventListener("error",c),r.addEventListener("close",()=>{r.removeEventListener("error",c)},{once:!0}),r.addEventListener("signal",o=>{const a=o.detail;this.socket.emit("ss-handshake",{intentId:e,srcMultiaddr:t,dstMultiaddr:s,answer:!0,signal:a})}),r.addEventListener("ready",()=>{const o=R(r,{remoteAddr:this.signallingAddr});l("new inbound connection %s",o.remoteAddr);try{this.upgrader.upgradeInbound(o).then(a=>{l("inbound connection %s upgraded",o.remoteAddr),this.connections.push(o);const g=()=>{this.connections=this.connections.filter(h=>h!==o),this.channels.delete(e),this.pendingSignals.delete(e)};r.addEventListener("close",g,{once:!0}),this.dispatchEvent(new u("connection",{detail:a})),this.handler(a)}).catch(a=>{l.error("inbound connection failed to upgrade",a),o.close().catch(g=>{l.error("inbound connection failed to close after failing to upgrade",g)})})}catch(a){l.error("inbound connection failed to upgrade",a),o.close().catch(g=>{l.error("inbound connection failed to close after failing to upgrade",g)})}},{once:!0}),r}handleWsHandshake(e){if(l('incoming handshake. signal type "%s" is answer %s',e.signal.type,e.answer),e.answer===!0||e.err!=null||e.intentId==null)return;const t=e.intentId;let s=this.pendingSignals.get(t);s==null&&(s=[],this.pendingSignals.set(t,s)),s.push(e);let n=this.channels.get(t);if(n==null){if(e.signal.type!=="offer"){l("handshake is not an offer and channel does not exist, buffering until we receive an offer");return}l("creating new channel to handle offer handshake"),n=this._createChannel(e.intentId,e.srcMultiaddr,e.dstMultiaddr),this.channels.set(t,n)}else l("channel already exists, using it to handle handshake");for(;s.length>0;){const r=s.shift();r?.signal!=null&&n.handleSignal(r.signal)}}async close(){this.socket.emit("ss-leave",this.signallingAddr.toString()),this.socket.removeAllListeners(),this.socket.close(),await Promise.all([...this.connections.map(async e=>{await e.close()}),...Array.from(this.channels.values()).map(async e=>{await e.close()})]),this.dispatchEvent(new u("close"))}}class Y extends y{constructor(e,t,s,n,r){super(),this.upgrader=e,this.handler=t,this.peerId=s,this.transport=n,this.options=r}async listen(e){if(this.listeningAddr!=null)throw w(new Error("listener already in use"),"ERR_ALREADY_LISTENING");const t=P();this.listeningAddr=e;let s;e.protoCodes().includes(k)?s=e:s=e.encapsulate(`/p2p/${this.peerId.toString()}`);const n=this.signallingUrl=_(e);l("connecting to signalling server on: %s",this.signallingUrl);const r=new V(this.signallingUrl,s,this.upgrader,this.handler,this.options.channelOptions);r.addEventListener("error",c=>{const o=c.detail;l("error connecting to signalling server %o",o),r.close().catch(a=>{l.error("error closing server after error",a)}),t.reject(o)}),r.addEventListener("listening",()=>{l("connected to signalling server"),this.dispatchEvent(new u("listening")),t.resolve()}),r.addEventListener("peer",c=>{this.transport.peerDiscovered(c.detail)}),r.addEventListener("connection",c=>{const o=c.detail;if(o.remoteAddr==null)try{o.remoteAddr=e.decapsulateCode(k).encapsulate(`/p2p/${o.remotePeer.toString()}`)}catch(a){l.error("could not determine remote address",a)}this.dispatchEvent(new u("connection",{detail:o}))}),r.addEventListener("disconnect",()=>{this.transport.sigServers.delete(n)}),r.addEventListener("reconnect",()=>{this.transport.sigServers.set(n,r)}),this.transport.sigServers.set(this.signallingUrl,r),await t.promise}async close(){if(this.signallingUrl!=null){const e=this.transport.sigServers.get(this.signallingUrl);e!=null&&(await e.close(),this.transport.sigServers.delete(this.signallingUrl))}this.dispatchEvent(new u("close")),this.listeningAddr=void 0}getAddrs(){return this.listeningAddr!=null?[this.listeningAddr]:[]}}function q(i,e,t,s,n){return new Y(i,e,t,s,n)}const z=Symbol.for("@libp2p/transport");var I;(function(i){i[i.FATAL_ALL=0]="FATAL_ALL",i[i.NO_FATAL=1]="NO_FATAL"})(I||(I={}));const J="RTCPeerConnection"in globalThis,p=b("libp2p:webrtc-star"),Q=()=>{};class X extends y{constructor(){super(...arguments),this.started=!1}get[F](){return!0}get[Symbol.toStringTag](){return"@libp2p/webrtc-star-discovery"}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}dispatchEvent(e){return this.isStarted()?super.dispatchEvent(e):!1}}class Z{constructor(e){e?.wrtc!=null&&(this.wrtc=e.wrtc),this.sigServers=new Map,this._discovery=new X,this.discovery=()=>this._discovery,this.peerDiscovered=this.peerDiscovered.bind(this)}get[z](){return!0}get[Symbol.toStringTag](){return"@libp2p/webrtc-star"}async dial(e,t){const s=await this._connect(e,t),n=R(s,{remoteAddr:e,signal:t.signal});p("new outbound connection %s",n.remoteAddr);const r=await t.upgrader.upgradeOutbound(n);return p("outbound connection %s upgraded",n.remoteAddr),r}async _connect(e,t){if(t.signal?.aborted===!0)throw new L;const s={...t.channelOptions??{}};this.wrtc!=null&&(s.wrtc=this.wrtc);const n=e.toOptions(),r=G(N(36),"hex");return await new Promise((c,o)=>{const a=this.sigServers.get(_(e));if(a?.socket==null){o(w(new Error("unknown signal server to use"),"ERR_UNKNOWN_SIGNAL_SERVER"));return}let g=!1;p("dialing %s:%s",n.host,n.port);const h=new U(s),T=d=>{const v=d.detail;if(!g){const O=`connection error ${n.host}:${n.port}: ${v.message}`;p.error(O),E(v)}},A=()=>{g=!0,p("connection opened %s:%s",n.host,n.port),E()},m=()=>{p.error("connection aborted %s:%s",n.host,n.port),h.close().finally(()=>{E(new L)})},E=d=>{h.removeEventListener("ready",A),t.signal?.removeEventListener("abort",m),d==null?c(h):o(d)};h.addEventListener("ready",A,{once:!0}),h.addEventListener("close",()=>{h.removeEventListener("error",T)}),t.signal?.addEventListener("abort",m),h.addEventListener("signal",d=>{const v=d.detail;a.socket.emit("ss-handshake",{intentId:r,srcMultiaddr:a.signallingAddr.toString(),dstMultiaddr:e.toString(),signal:v})}),a.socket.on("ws-handshake",d=>{d.intentId===r&&d.err!=null&&h.close().finally(()=>{o(w(new Error(d.err),"ERR_SIGNALLING_FAILED"))}),!(d.intentId!==r||d.answer==null||h.closed)&&h.handleSignal(d.signal)})})}createListener(e){if(!J&&this.wrtc==null)throw w(new Error("no WebRTC support"),"ERR_NO_WEBRTC_SUPPORT");if(e.channelOptions=e.channelOptions??{},this.wrtc!=null&&(e.channelOptions.wrtc=this.wrtc),this.peerId==null)throw w(new Error("PeerId not set"),"ERR_MISSING_PEER_ID");return q(e.upgrader,e.handler??Q,this.peerId,this,e)}filter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>t.protoCodes().includes(H)?!1:M.matches(t))}peerDiscovered(e){p("peer discovered: %s",e),e=j(e);const t=C(e),s=t.getPeerId();if(s==null)return;const n=x(s);this._discovery.dispatchEvent(new u("peer",{detail:{id:n,multiaddrs:[t],protocols:[]}}))}}function ne(i={}){const e=new Z(i);return{transport:t=>(e.peerId=t.peerId,e),discovery:e.discovery}}export{ne as w};
//# sourceMappingURL=index-0a2db50b.js.map
