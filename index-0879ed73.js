var G=Object.defineProperty;var U=(r,e,t)=>e in r?G(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var o=(r,e,t)=>(U(r,typeof e!="symbol"?e+"":e,t),t);import{c as V,U as h,p as y,v as S,l as k,a as B,C as R,b as x,f as W,r as P,d as F,t as p,m as $,i as j,e as Q,_ as m,g as Z,h as H,j as X,n as K}from"./index-594d3a3e.js";const q=V;function z(r){const e=new globalThis.AbortController;function t(){e.abort();for(const i of r)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}for(const i of r){if(i?.aborted===!0){t();break}i?.addEventListener!=null&&i.addEventListener("abort",t)}function s(){for(const i of r)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}const n=e.signal;return n.clear=s,n}var a;(function(r){r[r.NEW_STREAM=0]="NEW_STREAM",r[r.MESSAGE_RECEIVER=1]="MESSAGE_RECEIVER",r[r.MESSAGE_INITIATOR=2]="MESSAGE_INITIATOR",r[r.CLOSE_RECEIVER=3]="CLOSE_RECEIVER",r[r.CLOSE_INITIATOR=4]="CLOSE_INITIATOR",r[r.RESET_RECEIVER=5]="RESET_RECEIVER",r[r.RESET_INITIATOR=6]="RESET_INITIATOR"})(a||(a={}));const T=Object.freeze({0:"NEW_STREAM",1:"MESSAGE_RECEIVER",2:"MESSAGE_INITIATOR",3:"CLOSE_RECEIVER",4:"CLOSE_INITIATOR",5:"RESET_RECEIVER",6:"RESET_INITIATOR"}),O=Object.freeze({NEW_STREAM:a.NEW_STREAM,MESSAGE:a.MESSAGE_INITIATOR,CLOSE:a.CLOSE_INITIATOR,RESET:a.RESET_INITIATOR}),Y=Object.freeze({MESSAGE:a.MESSAGE_RECEIVER,CLOSE:a.CLOSE_RECEIVER,RESET:a.RESET_RECEIVER}),D=1<<20,J=4<<20;class ee{constructor(e=D,t=J){o(this,"_buffer");o(this,"_headerInfo");o(this,"_maxMessageSize");o(this,"_maxUnprocessedMessageQueueSize");this._buffer=new h,this._headerInfo=null,this._maxMessageSize=e,this._maxUnprocessedMessageQueueSize=t}write(e){if(e==null||e.length===0)return[];if(this._buffer.append(e),this._buffer.byteLength>this._maxUnprocessedMessageQueueSize)throw Object.assign(new Error("unprocessed message queue size too large!"),{code:"ERR_MSG_QUEUE_TOO_BIG"});const t=[];for(;this._buffer.length!==0;){if(this._headerInfo==null)try{this._headerInfo=this._decodeHeader(this._buffer)}catch(_){if(_.code==="ERR_MSG_TOO_BIG")throw _;break}const{id:s,type:n,length:i,offset:c}=this._headerInfo;if(this._buffer.length-c<i)break;const l={id:s,type:n};(n===a.NEW_STREAM||n===a.MESSAGE_INITIATOR||n===a.MESSAGE_RECEIVER)&&(l.data=this._buffer.sublist(c,c+i)),t.push(l),this._buffer.consume(c+i),this._headerInfo=null}return t}_decodeHeader(e){const{value:t,offset:s}=M(e),{value:n,offset:i}=M(e,s),c=t&7;if(T[c]==null)throw new Error(`Invalid type received: ${c}`);if(n>this._maxMessageSize)throw Object.assign(new Error("message size too large!"),{code:"ERR_MSG_TOO_BIG"});return{id:t>>3,type:c,offset:s+i,length:n}}}const te=128,C=127;function M(r,e=0){let t=0,s=0,n=e,i;const c=r.length;do{if(n>=c||s>49)throw e=0,new RangeError("Could not decode varint");i=r.get(n++),t+=s<28?(i&C)<<s:(i&C)*Math.pow(2,s),s+=7}while(i>=te);return e=n-e,{value:t,offset:e}}function se(r){return r[Symbol.asyncIterator]!=null}const I=1024*1024,g=(r,e)=>{e.append(r)};function re(r,e){return se(r)?async function*(){let t=new h,s=!1,n=y(),i=Number(e?.size??I);if((isNaN(i)||i===0||i<0)&&(i=I),i!==Math.round(i))throw new Error("Batch size must be an integer");const c=e?.yieldAfter??0,u=e?.serialize??g;for(Promise.resolve().then(async()=>{try{let l;for await(const _ of r){if(u(_,t),t.byteLength>=i){clearTimeout(l),n.resolve();continue}l=setTimeout(()=>{n.resolve()},c)}clearTimeout(l),n.resolve()}catch(l){n.reject(l)}finally{s=!0}});!s;)if(await n.promise,n=y(),t.byteLength>0){const l=t;t=new h,yield l.subarray()}}():function*(){const t=new h;let s=Number(e?.size??I);if((isNaN(s)||s===0||s<0)&&(s=I),s!==Math.round(s))throw new Error("Batch size must be an integer");const n=e?.serialize??g;for(const i of r)n(i,t),t.byteLength>=s&&(yield t.subarray(0,s),t.consume(s));t.byteLength>0&&(yield t.subarray())}()}function N(r){return new Uint8Array(r)}const b=10*1024;class ne{constructor(){o(this,"_pool");o(this,"_poolOffset");this._pool=N(b),this._poolOffset=0}write(e,t){const s=this._pool;let n=this._poolOffset;S.encode(e.id<<3|e.type,s,n),n+=S.encode.bytes??0,(e.type===a.NEW_STREAM||e.type===a.MESSAGE_INITIATOR||e.type===a.MESSAGE_RECEIVER)&&e.data!=null?S.encode(e.data.length,s,n):S.encode(0,s,n),n+=S.encode.bytes??0;const i=s.subarray(this._poolOffset,n);b-n<100?(this._pool=N(b),this._poolOffset=0):this._poolOffset=n,t.append(i),(e.type===a.NEW_STREAM||e.type===a.MESSAGE_INITIATOR||e.type===a.MESSAGE_RECEIVER)&&e.data!=null&&t.append(e.data)}}const L=new ne;async function*ie(r,e=0){if(e==null||e===0){for await(const t of r){const s=new h;for(const n of t)L.write(n,s);yield s.subarray()}return}yield*re(r,{size:e,serialize:(t,s)=>{for(const n of t)L.write(n,s)}})}const d=k("libp2p:stream"),A="ERR_STREAM_RESET",oe="ERR_STREAM_ABORT",ae="ERR_SINK_ENDED",ce="ERR_DOUBLE_SINK";function f(r){return r!=null&&typeof r.then=="function"}class le{constructor(e){o(this,"id");o(this,"stat");o(this,"metadata");o(this,"source");o(this,"abortController");o(this,"resetController");o(this,"closeController");o(this,"sourceEnded");o(this,"sinkEnded");o(this,"sinkSunk");o(this,"endErr");o(this,"streamSource");o(this,"onEnd");o(this,"maxDataSize");this.abortController=new AbortController,this.resetController=new AbortController,this.closeController=new AbortController,this.sourceEnded=!1,this.sinkEnded=!1,this.sinkSunk=!1,this.id=e.id,this.metadata=e.metadata??{},this.stat={direction:e.direction,timeline:{open:Date.now()}},this.maxDataSize=e.maxDataSize,this.onEnd=e.onEnd,this.source=this.streamSource=B({onEnd:()=>{if(this.stat.timeline.reset!==null){const t=this.sendCloseRead();f(t)&&t.catch(s=>{d.error("error while sending close read",s)})}this.onSourceEnd()}}),this.sink=this.sink.bind(this)}onSourceEnd(e){this.sourceEnded||(this.stat.timeline.closeRead=Date.now(),this.sourceEnded=!0,d.trace("%s stream %s source end - err: %o",this.stat.direction,this.id,e),e!=null&&this.endErr==null&&(this.endErr=e),this.sinkEnded&&(this.stat.timeline.close=Date.now(),this.onEnd!=null&&this.onEnd(this.endErr)))}onSinkEnd(e){this.sinkEnded||(this.stat.timeline.closeWrite=Date.now(),this.sinkEnded=!0,d.trace("%s stream %s sink end - err: %o",this.stat.direction,this.id,e),e!=null&&this.endErr==null&&(this.endErr=e),this.sourceEnded&&(this.stat.timeline.close=Date.now(),this.onEnd!=null&&this.onEnd(this.endErr)))}close(){d.trace("%s stream %s close",this.stat.direction,this.id),this.closeRead(),this.closeWrite()}closeRead(){d.trace("%s stream %s closeRead",this.stat.direction,this.id),!this.sourceEnded&&this.streamSource.end()}closeWrite(){if(d.trace("%s stream %s closeWrite",this.stat.direction,this.id),!this.sinkEnded){this.closeController.abort();try{const e=this.sendCloseWrite();f(e)&&e.catch(t=>{d.error("error while sending close write",t)})}catch(e){d.trace("%s stream %s error sending close",this.stat.direction,this.id,e)}this.onSinkEnd()}}abort(e){d.trace("%s stream %s abort",this.stat.direction,this.id,e),this.streamSource.end(e),this.abortController.abort(),this.onSinkEnd(e)}reset(){const e=new R("stream reset",A);this.resetController.abort(),this.streamSource.end(e),this.onSinkEnd(e)}async sink(e){if(this.sinkSunk)throw new R("sink already called on stream",ce);if(this.sinkSunk=!0,this.sinkEnded)throw new R("stream closed for writing",ae);const t=z([this.abortController.signal,this.resetController.signal,this.closeController.signal]);try{if(e=x(e,t),this.stat.direction==="outbound"){const s=this.sendNewStream();f(s)&&await s}for await(let s of e)for(;s.length>0;){if(s.length<=this.maxDataSize){const i=this.sendData(s instanceof Uint8Array?new h(s):s);f(i)&&await i;break}s=s instanceof Uint8Array?new h(s):s;const n=this.sendData(s.sublist(0,this.maxDataSize));f(n)&&await n,s.consume(this.maxDataSize)}}catch(s){if(s.type==="aborted"&&s.message==="The operation was aborted"){if(this.closeController.signal.aborted)return;this.resetController.signal.aborted&&(s.message="stream reset",s.code=A),this.abortController.signal.aborted&&(s.message="stream aborted",s.code=oe)}if(s.code===A)d.trace("%s stream %s reset",this.stat.direction,this.id);else{d.trace("%s stream %s error",this.stat.direction,this.id,s);try{const n=this.sendReset();f(n)&&await n,this.stat.timeline.reset=Date.now()}catch(n){d.trace("%s stream %s error sending reset",this.stat.direction,this.id,n)}}throw this.streamSource.end(s),this.onSinkEnd(s),s}finally{t.clear()}try{const s=this.sendCloseWrite();f(s)&&await s}catch(s){d.trace("%s stream %s error sending close",this.stat.direction,this.id,s)}this.onSinkEnd()}sourcePush(e){this.streamSource.push(e)}sourceReadableLength(){return this.streamSource.readableLength}}class de extends le{constructor(t){super(t);o(this,"name");o(this,"streamId");o(this,"send");o(this,"types");this.types=t.direction==="outbound"?O:Y,this.send=t.send,this.name=t.name,this.streamId=t.streamId}sendNewStream(){this.send({id:this.streamId,type:O.NEW_STREAM,data:new h(W(this.name))})}sendData(t){this.send({id:this.streamId,type:this.types.MESSAGE,data:t})}sendReset(){this.send({id:this.streamId,type:this.types.RESET})}sendCloseWrite(){this.send({id:this.streamId,type:this.types.CLOSE})}sendCloseRead(){}}function Ee(r){const{id:e,name:t,send:s,onEnd:n,type:i="initiator",maxMsgSize:c=D}=r;return new de({id:i==="initiator"?`i${e}`:`r${e}`,streamId:e,name:`${t??e}`,direction:i==="initiator"?"outbound":"inbound",maxDataSize:c,onEnd:n,send:s})}const E=k("libp2p:mplex"),he=1024,ue=1024,_e=1024*1024*4,fe=5;function v(r){const e={...r,type:`${T[r.type]} (${r.type})`};return r.type===a.NEW_STREAM&&(e.data=p(r.data instanceof Uint8Array?r.data:r.data.subarray())),(r.type===a.MESSAGE_INITIATOR||r.type===a.MESSAGE_RECEIVER)&&(e.data=p(r.data instanceof Uint8Array?r.data:r.data.subarray(),"base16")),e}class Se{constructor(e){o(this,"protocol","/mplex/6.7.0");o(this,"sink");o(this,"source");o(this,"_streamId");o(this,"_streams");o(this,"_init");o(this,"_source");o(this,"closeController");o(this,"rateLimiter");e=e??{},this._streamId=0,this._streams={initiators:new Map,receivers:new Map},this._init=e,this.sink=this._createSink();const t=this._createSource();this._source=t,this.source=t,this.closeController=new AbortController,this.rateLimiter=new P.RateLimiterMemory({points:e.disconnectThreshold??fe,duration:1})}get streams(){const e=[];for(const t of this._streams.initiators.values())e.push(t);for(const t of this._streams.receivers.values())e.push(t);return e}newStream(e){if(this.closeController.signal.aborted)throw new Error("Muxer already closed");const t=this._streamId++;e=e==null?t.toString():e.toString();const s=this._streams.initiators;return this._newStream({id:t,name:e,type:"initiator",registry:s})}close(e){this.closeController.signal.aborted||(e!=null?this.streams.forEach(t=>{t.abort(e)}):this.streams.forEach(t=>{t.close()}),this.closeController.abort())}_newReceiverStream(e){const{id:t,name:s}=e,n=this._streams.receivers;return this._newStream({id:t,name:s,type:"receiver",registry:n})}_newStream(e){const{id:t,name:s,type:n,registry:i}=e;if(E("new %s stream %s",n,t),n==="initiator"&&this._streams.initiators.size===(this._init.maxOutboundStreams??ue))throw new R("Too many outbound streams open","ERR_TOO_MANY_OUTBOUND_STREAMS");if(i.has(t))throw new Error(`${n} stream ${t} already exists!`);const l=Ee({id:t,name:s,send:_=>{E.enabled&&E.trace("%s stream %s send",n,t,v(_)),this._source.push(_)},type:n,onEnd:()=>{E("%s stream with id %s and protocol %s ended",n,t,l.stat.protocol),i.delete(t),this._init.onStreamEnd!=null&&this._init.onStreamEnd(l)},maxMsgSize:this._init.maxMsgSize});return i.set(t,l),l}_createSink(){return async t=>{const s=z([this.closeController.signal,this._init.signal]);try{t=x(t,s);const n=new ee(this._init.maxMsgSize,this._init.maxUnprocessedMessageQueueSize);for await(const i of t)for(const c of n.write(i))await this._handleIncoming(c);this._source.end()}catch(n){E("error in sink",n),this._source.end(n)}finally{s.clear()}}}_createSource(){const t=F({objectMode:!0,onEnd:s=>{this.close(s)}});return Object.assign(ie(t,this._init.minSendBytes),{push:t.push,end:t.end,return:t.return})}async _handleIncoming(e){const{id:t,type:s}=e;if(E.enabled&&E.trace("incoming message",v(e)),e.type===a.NEW_STREAM){if(this._streams.receivers.size===(this._init.maxInboundStreams??he)){E("too many inbound streams open"),this._source.push({id:t,type:a.RESET_RECEIVER});try{await this.rateLimiter.consume("new-stream",1)}catch{E("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection"),this._source.end(new Error("Too many open streams"));return}return}const u=this._newReceiverStream({id:t,name:p(e.data instanceof Uint8Array?e.data:e.data.subarray())});this._init.onIncomingStream!=null&&this._init.onIncomingStream(u);return}const i=((s&1)===1?this._streams.initiators:this._streams.receivers).get(t);if(i==null){E("missing stream %s for message type %s",t,T[s]);return}const c=this._init.maxStreamBufferSize??_e;switch(s){case a.MESSAGE_INITIATOR:case a.MESSAGE_RECEIVER:if(i.sourceReadableLength()>c){this._source.push({id:e.id,type:s===a.MESSAGE_INITIATOR?a.RESET_RECEIVER:a.RESET_INITIATOR});const u=new R("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers","ERR_STREAM_INPUT_BUFFER_FULL");i.abort(u);return}i.sourcePush(e.data);break;case a.CLOSE_INITIATOR:case a.CLOSE_RECEIVER:i.closeRead();break;case a.RESET_INITIATOR:case a.RESET_RECEIVER:i.reset();break;default:E("unknown message type %s",s)}}}class me{constructor(e={}){o(this,"protocol","/mplex/6.7.0");o(this,"_init");this._init=e}createStreamMuxer(e={}){return new Se({...e,...this._init})}}function Re(r={}){return()=>new me(r)}var w;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(w||(w={}));const Ie=async()=>{let r;return j||Q?r=(await m(()=>import("./configNavigateur-4d735fa1.js"),["configNavigateur-4d735fa1.js","index-594d3a3e.js","index-b09ae832.css","const-0ed3a9fc.js","index-2b728ac4.js"])).default:Z?r=(await m(()=>import("./configTravailleur-47809a94.js"),["configTravailleur-47809a94.js","index-594d3a3e.js","index-b09ae832.css","index-2b728ac4.js"])).default:H?r=(await m(()=>import("./configÉlectronPrincipal-549f2452.js"),["configÉlectronPrincipal-549f2452.js","index-594d3a3e.js","index-b09ae832.css","const-0ed3a9fc.js","index-08c9afb1.js","index-2b728ac4.js","index-2c05197e.js"])).default:X?r=(await m(()=>import("./configNode-a7f44df5.js"),["configNode-a7f44df5.js","index-594d3a3e.js","index-b09ae832.css","const-0ed3a9fc.js","index-08c9afb1.js","index-2b728ac4.js"])).default:(console.warn("Plateforme non reconnue. On utilisera la configuration navigateur."),r=(await m(()=>import("./configNavigateur-4d735fa1.js"),["configNavigateur-4d735fa1.js","index-594d3a3e.js","index-b09ae832.css","const-0ed3a9fc.js","index-2b728ac4.js"])).default),r},be=()=>({libp2p:{streamMuxers:[Re()],connectionEncryption:[K()],transportManager:{faultTolerance:w.NO_FATAL}},relay:{enabled:!0,hop:{enabled:!0,active:!0}}});async function we(r="./constl/sfip"){const e=be(),t=await Ie();e.repo=r;const s=$(e,t);return await q(s)}export{we as default};
//# sourceMappingURL=index-0879ed73.js.map
