{"version":3,"file":"index-78d7a28a.js","sources":["../../../../node_modules/ipfsd-ctl/dist/src/index.js","../../../../node_modules/wrtc/lib/browser.js","../../../../node_modules/uint8arraylist/dist/src/index.js","../../../../node_modules/it-reader/dist/src/index.js","../../../../node_modules/it-pushable/dist/src/fifo.js","../../../../node_modules/it-pushable/dist/src/index.js","../../../../node_modules/p-defer/index.js","../../../../node_modules/it-handshake/dist/src/index.js","../../../../node_modules/byte-access/dist/src/index.js","../../../../node_modules/longbits/dist/src/index.js","../../../../node_modules/uint8-varint/dist/src/index.js","../../../../node_modules/it-length-prefixed/dist/src/alloc.js","../../../../node_modules/it-length-prefixed/dist/src/encode.js","../../../../node_modules/it-length-prefixed/dist/src/decode.js","../../../../node_modules/it-pb-stream/dist/src/index.js","../../../../node_modules/it-pair/dist/src/index.js","../../../../node_modules/it-pair/dist/src/duplex.js","../../../../node_modules/it-merge/dist/src/index.js","../../../../node_modules/it-pipe/dist/src/index.js","../../../../node_modules/@chainsafe/libp2p-noise/dist/src/constants.js","../../../../node_modules/@stablelib/hash/lib/hash.js","../../../../node_modules/@stablelib/hmac/lib/hmac.js","../../../../node_modules/@stablelib/hkdf/lib/hkdf.js","../../../../node_modules/@chainsafe/libp2p-noise/dist/src/crypto/stablelib.js","../../../../node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js","../../../../node_modules/@chainsafe/libp2p-noise/dist/src/crypto/streaming.js","../../../../node_modules/@libp2p/interface-connection-encrypter/dist/src/errors.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/vendor/varint.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/varint.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/bytes.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/digest.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/vendor/base-x.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base58.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base32.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/cid.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/identity.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base2.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base8.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base10.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base16.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base36.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base64.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base256emoji.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/hasher.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/sha2-browser.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/identity.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/codecs/json.js","../../../../node_modules/@libp2p/peer-id/node_modules/multiformats/src/basics.js","../../../../node_modules/@libp2p/interface-peer-id/dist/src/index.js","../../../../node_modules/@libp2p/peer-id/dist/src/index.js","../../../../node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js","../../../../node_modules/@chainsafe/libp2p-noise/dist/src/utils.js","../../../../node_modules/@chainsafe/libp2p-noise/dist/src/logger.js","../../../../node_modules/@chainsafe/libp2p-noise/dist/src/nonce.js","../../../../node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/abstract-handshake.js","../../../../node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/xx.js","../../../../node_modules/@chainsafe/libp2p-noise/dist/src/handshake-xx.js","../../../../node_modules/@chainsafe/libp2p-noise/dist/src/metrics.js","../../../../node_modules/@chainsafe/libp2p-noise/dist/src/noise.js","../../../../node_modules/@chainsafe/libp2p-noise/dist/src/index.js","../../../../node_modules/@constl/ipa/dist/sfip/index.js"],"sourcesContent":["import DefaultFactory from './factory.js';\nimport Server from './endpoint/server.js';\n/**\n * Creates a factory\n *\n * @param {ControllerOptions} [options]\n * @param {ControllerOptionsOverrides} [overrides]\n * @returns {Factory}\n */\nexport const createFactory = (options, overrides) => {\n    return new DefaultFactory(options, overrides);\n};\n/**\n * Creates a node\n */\nexport const createController = async (options) => {\n    const f = new DefaultFactory();\n    return await f.spawn(options);\n};\n/**\n * Create a Endpoint Server\n *\n * @param {number | { port: number }} [options] - Configuration options or just the port.\n * @param {ControllerOptions} [factoryOptions]\n * @param {ControllerOptionsOverrides} [factoryOverrides]\n */\nexport const createServer = (options, factoryOptions = {}, factoryOverrides = {}) => {\n    let port;\n    if (typeof options === 'number') {\n        port = options;\n    }\n    else if (options != null) {\n        port = options.port;\n    }\n    return new Server({\n        port,\n        host: '127.0.0.1'\n    }, () => {\n        return createFactory(factoryOptions, factoryOverrides);\n    });\n};\n//# sourceMappingURL=index.js.map","'use strict';\n\nexports.MediaStream = window.MediaStream;\nexports.MediaStreamTrack = window.MediaStreamTrack;\nexports.RTCDataChannel = window.RTCDataChannel;\nexports.RTCDataChannelEvent = window.RTCDataChannelEvent;\nexports.RTCDtlsTransport = window.RTCDtlsTransport;\nexports.RTCIceCandidate = window.RTCIceCandidate;\nexports.RTCIceTransport = window.RTCIceTransport;\nexports.RTCPeerConnection = window.RTCPeerConnection;\nexports.RTCPeerConnectionIceEvent = window.RTCPeerConnectionIceEvent;\nexports.RTCRtpReceiver = window.RTCRtpReceiver;\nexports.RTCRtpSender = window.RTCRtpSender;\nexports.RTCRtpTransceiver = window.RTCRtpTransceiver;\nexports.RTCSctpTransport = window.RTCSctpTransport;\nexports.RTCSessionDescription = window.RTCSessionDescription;\nexports.getUserMedia = window.getUserMedia;\nexports.mediaDevices = navigator.mediaDevices;\n","import { concat } from 'uint8arrays/concat';\nimport { equals } from 'uint8arrays/equals';\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc';\nconst symbol = Symbol.for('@achingbrain/uint8arraylist');\nfunction findBufAndOffset(bufs, index) {\n    if (index == null || index < 0) {\n        throw new RangeError('index is out of bounds');\n    }\n    let offset = 0;\n    for (const buf of bufs) {\n        const bufEnd = offset + buf.byteLength;\n        if (index < bufEnd) {\n            return {\n                buf,\n                index: index - offset\n            };\n        }\n        offset = bufEnd;\n    }\n    throw new RangeError('index is out of bounds');\n}\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList(value) {\n    return Boolean(value?.[symbol]);\n}\nexport class Uint8ArrayList {\n    constructor(...data) {\n        // Define symbol\n        Object.defineProperty(this, symbol, { value: true });\n        this.bufs = [];\n        this.length = 0;\n        if (data.length > 0) {\n            this.appendAll(data);\n        }\n    }\n    *[Symbol.iterator]() {\n        yield* this.bufs;\n    }\n    get byteLength() {\n        return this.length;\n    }\n    /**\n     * Add one or more `bufs` to the end of this Uint8ArrayList\n     */\n    append(...bufs) {\n        this.appendAll(bufs);\n    }\n    /**\n     * Add all `bufs` to the end of this Uint8ArrayList\n     */\n    appendAll(bufs) {\n        let length = 0;\n        for (const buf of bufs) {\n            if (buf instanceof Uint8Array) {\n                length += buf.byteLength;\n                this.bufs.push(buf);\n            }\n            else if (isUint8ArrayList(buf)) {\n                length += buf.byteLength;\n                this.bufs.push(...buf.bufs);\n            }\n            else {\n                throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList');\n            }\n        }\n        this.length += length;\n    }\n    /**\n     * Add one or more `bufs` to the start of this Uint8ArrayList\n     */\n    prepend(...bufs) {\n        this.prependAll(bufs);\n    }\n    /**\n     * Add all `bufs` to the start of this Uint8ArrayList\n     */\n    prependAll(bufs) {\n        let length = 0;\n        for (const buf of bufs.reverse()) {\n            if (buf instanceof Uint8Array) {\n                length += buf.byteLength;\n                this.bufs.unshift(buf);\n            }\n            else if (isUint8ArrayList(buf)) {\n                length += buf.byteLength;\n                this.bufs.unshift(...buf.bufs);\n            }\n            else {\n                throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList');\n            }\n        }\n        this.length += length;\n    }\n    /**\n     * Read the value at `index`\n     */\n    get(index) {\n        const res = findBufAndOffset(this.bufs, index);\n        return res.buf[res.index];\n    }\n    /**\n     * Set the value at `index` to `value`\n     */\n    set(index, value) {\n        const res = findBufAndOffset(this.bufs, index);\n        res.buf[res.index] = value;\n    }\n    /**\n     * Copy bytes from `buf` to the index specified by `offset`\n     */\n    write(buf, offset = 0) {\n        if (buf instanceof Uint8Array) {\n            for (let i = 0; i < buf.length; i++) {\n                this.set(offset + i, buf[i]);\n            }\n        }\n        else if (isUint8ArrayList(buf)) {\n            for (let i = 0; i < buf.length; i++) {\n                this.set(offset + i, buf.get(i));\n            }\n        }\n        else {\n            throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList');\n        }\n    }\n    /**\n     * Remove bytes from the front of the pool\n     */\n    consume(bytes) {\n        // first, normalize the argument, in accordance with how Buffer does it\n        bytes = Math.trunc(bytes);\n        // do nothing if not a positive number\n        if (Number.isNaN(bytes) || bytes <= 0) {\n            return;\n        }\n        // if consuming all bytes, skip iterating\n        if (bytes === this.byteLength) {\n            this.bufs = [];\n            this.length = 0;\n            return;\n        }\n        while (this.bufs.length > 0) {\n            if (bytes >= this.bufs[0].byteLength) {\n                bytes -= this.bufs[0].byteLength;\n                this.length -= this.bufs[0].byteLength;\n                this.bufs.shift();\n            }\n            else {\n                this.bufs[0] = this.bufs[0].subarray(bytes);\n                this.length -= bytes;\n                break;\n            }\n        }\n    }\n    /**\n     * Extracts a section of an array and returns a new array.\n     *\n     * This is a copy operation as it is with Uint8Arrays and Arrays\n     * - note this is different to the behaviour of Node Buffers.\n     */\n    slice(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        return concat(bufs, length);\n    }\n    /**\n     * Returns a alloc from the given start and end element index.\n     *\n     * In the best case where the data extracted comes from a single Uint8Array\n     * internally this is a no-copy operation otherwise it is a copy operation.\n     */\n    subarray(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        if (bufs.length === 1) {\n            return bufs[0];\n        }\n        return concat(bufs, length);\n    }\n    /**\n     * Returns a allocList from the given start and end element index.\n     *\n     * This is a no-copy operation.\n     */\n    sublist(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        const list = new Uint8ArrayList();\n        list.length = length;\n        // don't loop, just set the bufs\n        list.bufs = bufs;\n        return list;\n    }\n    _subList(beginInclusive, endExclusive) {\n        beginInclusive = beginInclusive ?? 0;\n        endExclusive = endExclusive ?? this.length;\n        if (beginInclusive < 0) {\n            beginInclusive = this.length + beginInclusive;\n        }\n        if (endExclusive < 0) {\n            endExclusive = this.length + endExclusive;\n        }\n        if (beginInclusive < 0 || endExclusive > this.length) {\n            throw new RangeError('index is out of bounds');\n        }\n        if (beginInclusive === endExclusive) {\n            return { bufs: [], length: 0 };\n        }\n        if (beginInclusive === 0 && endExclusive === this.length) {\n            return { bufs: [...this.bufs], length: this.length };\n        }\n        const bufs = [];\n        let offset = 0;\n        for (let i = 0; i < this.bufs.length; i++) {\n            const buf = this.bufs[i];\n            const bufStart = offset;\n            const bufEnd = bufStart + buf.byteLength;\n            // for next loop\n            offset = bufEnd;\n            if (beginInclusive >= bufEnd) {\n                // start after this buf\n                continue;\n            }\n            const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;\n            const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;\n            if (sliceStartInBuf && sliceEndsInBuf) {\n                // slice is wholly contained within this buffer\n                if (beginInclusive === bufStart && endExclusive === bufEnd) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    break;\n                }\n                // requested part of buffer\n                const start = beginInclusive - bufStart;\n                bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)));\n                break;\n            }\n            if (sliceStartInBuf) {\n                // slice starts in this buffer\n                if (beginInclusive === 0) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    continue;\n                }\n                // requested part of buffer\n                bufs.push(buf.subarray(beginInclusive - bufStart));\n                continue;\n            }\n            if (sliceEndsInBuf) {\n                if (endExclusive === bufEnd) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    break;\n                }\n                // requested part of buffer\n                bufs.push(buf.subarray(0, endExclusive - bufStart));\n                break;\n            }\n            // slice started before this buffer and ends after it\n            bufs.push(buf);\n        }\n        return { bufs, length: endExclusive - beginInclusive };\n    }\n    indexOf(search, offset = 0) {\n        if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n            throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array');\n        }\n        const needle = search instanceof Uint8Array ? search : search.subarray();\n        offset = Number(offset ?? 0);\n        if (isNaN(offset)) {\n            offset = 0;\n        }\n        if (offset < 0) {\n            offset = this.length + offset;\n        }\n        if (offset < 0) {\n            offset = 0;\n        }\n        if (search.length === 0) {\n            return offset > this.length ? this.length : offset;\n        }\n        // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n        const M = needle.byteLength;\n        if (M === 0) {\n            throw new TypeError('search must be at least 1 byte long');\n        }\n        // radix\n        const radix = 256;\n        const rightmostPositions = new Int32Array(radix);\n        // position of the rightmost occurrence of the byte c in the pattern\n        for (let c = 0; c < radix; c++) {\n            // -1 for bytes not in pattern\n            rightmostPositions[c] = -1;\n        }\n        for (let j = 0; j < M; j++) {\n            // rightmost position for bytes in pattern\n            rightmostPositions[needle[j]] = j;\n        }\n        // Return offset of first match, -1 if no match\n        const right = rightmostPositions;\n        const lastIndex = this.byteLength - needle.byteLength;\n        const lastPatIndex = needle.byteLength - 1;\n        let skip;\n        for (let i = offset; i <= lastIndex; i += skip) {\n            skip = 0;\n            for (let j = lastPatIndex; j >= 0; j--) {\n                const char = this.get(i + j);\n                if (needle[j] !== char) {\n                    skip = Math.max(1, j - right[char]);\n                    break;\n                }\n            }\n            if (skip === 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    getInt8(byteOffset) {\n        const buf = this.subarray(byteOffset, byteOffset + 1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt8(0);\n    }\n    setInt8(byteOffset, value) {\n        const buf = allocUnsafe(1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt8(0, value);\n        this.write(buf, byteOffset);\n    }\n    getInt16(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt16(0, littleEndian);\n    }\n    setInt16(byteOffset, value, littleEndian) {\n        const buf = alloc(2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt16(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getInt32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt32(0, littleEndian);\n    }\n    setInt32(byteOffset, value, littleEndian) {\n        const buf = alloc(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getBigInt64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getBigInt64(0, littleEndian);\n    }\n    setBigInt64(byteOffset, value, littleEndian) {\n        const buf = alloc(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setBigInt64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getUint8(byteOffset) {\n        const buf = this.subarray(byteOffset, byteOffset + 1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint8(0);\n    }\n    setUint8(byteOffset, value) {\n        const buf = allocUnsafe(1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint8(0, value);\n        this.write(buf, byteOffset);\n    }\n    getUint16(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint16(0, littleEndian);\n    }\n    setUint16(byteOffset, value, littleEndian) {\n        const buf = alloc(2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint16(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getUint32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint32(0, littleEndian);\n    }\n    setUint32(byteOffset, value, littleEndian) {\n        const buf = alloc(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getBigUint64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getBigUint64(0, littleEndian);\n    }\n    setBigUint64(byteOffset, value, littleEndian) {\n        const buf = alloc(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setBigUint64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getFloat32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getFloat32(0, littleEndian);\n    }\n    setFloat32(byteOffset, value, littleEndian) {\n        const buf = alloc(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setFloat32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getFloat64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getFloat64(0, littleEndian);\n    }\n    setFloat64(byteOffset, value, littleEndian) {\n        const buf = alloc(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setFloat64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    equals(other) {\n        if (other == null) {\n            return false;\n        }\n        if (!(other instanceof Uint8ArrayList)) {\n            return false;\n        }\n        if (other.bufs.length !== this.bufs.length) {\n            return false;\n        }\n        for (let i = 0; i < this.bufs.length; i++) {\n            if (!equals(this.bufs[i], other.bufs[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n     * method if you know the total size of all the Uint8Arrays ahead of time.\n     */\n    static fromUint8Arrays(bufs, length) {\n        const list = new Uint8ArrayList();\n        list.bufs = bufs;\n        if (length == null) {\n            length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);\n        }\n        list.length = length;\n        return list;\n    }\n}\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n//# sourceMappingURL=index.js.map","import { Uint8ArrayList } from 'uint8arraylist';\n/**\n * Returns an `AsyncGenerator` that allows reading a set number of bytes from the passed source.\n *\n * @example\n *\n * ```javascript\n * import { reader } from 'it-reader'\n *\n * const stream = reader(source)\n *\n * // read 10 bytes from the stream\n * const { done, value } = await stream.next(10)\n *\n * if (done === true) {\n *   // stream finished\n * }\n *\n * if (value != null) {\n *   // do something with value\n * }\n * ```\n */\nexport function reader(source) {\n    const reader = (async function* () {\n        // @ts-expect-error first yield in stream is ignored\n        let bytes = yield; // Allows us to receive 8 when reader.next(8) is called\n        let bl = new Uint8ArrayList();\n        for await (const chunk of source) {\n            if (bytes == null) {\n                bl.append(chunk);\n                bytes = yield bl;\n                bl = new Uint8ArrayList();\n                continue;\n            }\n            bl.append(chunk);\n            while (bl.length >= bytes) {\n                const data = bl.sublist(0, bytes);\n                bl.consume(bytes);\n                bytes = yield data;\n                // If we no longer want a specific byte length, we yield the rest now\n                if (bytes == null) {\n                    if (bl.length > 0) {\n                        bytes = yield bl;\n                        bl = new Uint8ArrayList();\n                    }\n                    break; // bytes is null and/or no more buffer to yield\n                }\n            }\n        }\n        // Consumer wants more bytes but the source has ended and our buffer\n        // is not big enough to satisfy.\n        if (bytes != null) {\n            throw Object.assign(new Error(`stream ended before ${bytes} bytes became available`), { code: 'ERR_UNDER_READ', buffer: bl });\n        }\n    })();\n    void reader.next();\n    return reader;\n}\n//# sourceMappingURL=index.js.map","// ported from https://www.npmjs.com/package/fast-fifo\nclass FixedFIFO {\n    constructor(hwm) {\n        if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n            throw new Error('Max size for a FixedFIFO should be a power of two');\n        }\n        this.buffer = new Array(hwm);\n        this.mask = hwm - 1;\n        this.top = 0;\n        this.btm = 0;\n        this.next = null;\n    }\n    push(data) {\n        if (this.buffer[this.top] !== undefined) {\n            return false;\n        }\n        this.buffer[this.top] = data;\n        this.top = (this.top + 1) & this.mask;\n        return true;\n    }\n    shift() {\n        const last = this.buffer[this.btm];\n        if (last === undefined) {\n            return undefined;\n        }\n        this.buffer[this.btm] = undefined;\n        this.btm = (this.btm + 1) & this.mask;\n        return last;\n    }\n    isEmpty() {\n        return this.buffer[this.btm] === undefined;\n    }\n}\nexport class FIFO {\n    constructor(options = {}) {\n        this.hwm = options.splitLimit ?? 16;\n        this.head = new FixedFIFO(this.hwm);\n        this.tail = this.head;\n        this.size = 0;\n    }\n    calculateSize(obj) {\n        if (obj?.byteLength != null) {\n            return obj.byteLength;\n        }\n        return 1;\n    }\n    push(val) {\n        if (val?.value != null) {\n            this.size += this.calculateSize(val.value);\n        }\n        if (!this.head.push(val)) {\n            const prev = this.head;\n            this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);\n            this.head.push(val);\n        }\n    }\n    shift() {\n        let val = this.tail.shift();\n        if (val === undefined && (this.tail.next != null)) {\n            const next = this.tail.next;\n            this.tail.next = null;\n            this.tail = next;\n            val = this.tail.shift();\n        }\n        if (val?.value != null) {\n            this.size -= this.calculateSize(val.value);\n        }\n        return val;\n    }\n    isEmpty() {\n        return this.head.isEmpty();\n    }\n}\n//# sourceMappingURL=fifo.js.map","/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\nimport { FIFO } from './fifo.js';\nexport function pushable(options = {}) {\n    const getNext = (buffer) => {\n        const next = buffer.shift();\n        if (next == null) {\n            return { done: true };\n        }\n        if (next.error != null) {\n            throw next.error;\n        }\n        return {\n            done: next.done === true,\n            // @ts-expect-error\n            value: next.value\n        };\n    };\n    return _pushable(getNext, options);\n}\nexport function pushableV(options = {}) {\n    const getNext = (buffer) => {\n        let next;\n        const values = [];\n        while (!buffer.isEmpty()) {\n            next = buffer.shift();\n            if (next == null) {\n                break;\n            }\n            if (next.error != null) {\n                throw next.error;\n            }\n            if (next.done === false) {\n                // @ts-expect-error\n                values.push(next.value);\n            }\n        }\n        if (next == null) {\n            return { done: true };\n        }\n        return {\n            done: next.done === true,\n            value: values\n        };\n    };\n    return _pushable(getNext, options);\n}\nfunction _pushable(getNext, options) {\n    options = options ?? {};\n    let onEnd = options.onEnd;\n    let buffer = new FIFO();\n    let pushable;\n    let onNext;\n    let ended;\n    const waitNext = async () => {\n        if (!buffer.isEmpty()) {\n            return getNext(buffer);\n        }\n        if (ended) {\n            return { done: true };\n        }\n        return await new Promise((resolve, reject) => {\n            onNext = (next) => {\n                onNext = null;\n                buffer.push(next);\n                try {\n                    resolve(getNext(buffer));\n                }\n                catch (err) {\n                    reject(err);\n                }\n                return pushable;\n            };\n        });\n    };\n    const bufferNext = (next) => {\n        if (onNext != null) {\n            return onNext(next);\n        }\n        buffer.push(next);\n        return pushable;\n    };\n    const bufferError = (err) => {\n        buffer = new FIFO();\n        if (onNext != null) {\n            return onNext({ error: err });\n        }\n        buffer.push({ error: err });\n        return pushable;\n    };\n    const push = (value) => {\n        if (ended) {\n            return pushable;\n        }\n        // @ts-expect-error `byteLength` is not declared on PushType\n        if (options?.objectMode !== true && value?.byteLength == null) {\n            throw new Error('objectMode was not true but tried to push non-Uint8Array value');\n        }\n        return bufferNext({ done: false, value });\n    };\n    const end = (err) => {\n        if (ended)\n            return pushable;\n        ended = true;\n        return (err != null) ? bufferError(err) : bufferNext({ done: true });\n    };\n    const _return = () => {\n        buffer = new FIFO();\n        end();\n        return { done: true };\n    };\n    const _throw = (err) => {\n        end(err);\n        return { done: true };\n    };\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next: waitNext,\n        return: _return,\n        throw: _throw,\n        push,\n        end,\n        get readableLength() {\n            return buffer.size;\n        }\n    };\n    if (onEnd == null) {\n        return pushable;\n    }\n    const _pushable = pushable;\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next() {\n            return _pushable.next();\n        },\n        throw(err) {\n            _pushable.throw(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        return() {\n            _pushable.return();\n            if (onEnd != null) {\n                onEnd();\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        push,\n        end(err) {\n            _pushable.end(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return pushable;\n        },\n        get readableLength() {\n            return _pushable.readableLength;\n        }\n    };\n    return pushable;\n}\n//# sourceMappingURL=index.js.map","export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n","import { reader } from 'it-reader';\nimport { pushable } from 'it-pushable';\nimport defer from 'p-defer';\n// Convert a duplex stream into a reader and writer and rest stream\nexport function handshake(stream) {\n    const writer = pushable(); // Write bytes on demand to the sink\n    const source = reader(stream.source); // Read bytes on demand from the source\n    // Waits for a source to be passed to the rest stream's sink\n    const sourcePromise = defer();\n    let sinkErr;\n    const sinkPromise = stream.sink((async function* () {\n        yield* writer;\n        const source = await sourcePromise.promise;\n        yield* source;\n    })());\n    sinkPromise.catch(err => {\n        sinkErr = err;\n    });\n    const rest = {\n        sink: async (source) => {\n            if (sinkErr != null) {\n                return await Promise.reject(sinkErr);\n            }\n            sourcePromise.resolve(source);\n            return await sinkPromise;\n        },\n        source\n    };\n    return {\n        reader: source,\n        writer,\n        stream: rest,\n        rest: () => writer.end(),\n        write: writer.push,\n        read: async () => {\n            const res = await source.next();\n            if (res.value != null) {\n                return res.value;\n            }\n        }\n    };\n}\n//# sourceMappingURL=index.js.map","export default function accessor(buf) {\n    if (buf instanceof Uint8Array) {\n        return {\n            get(index) {\n                return buf[index];\n            },\n            set(index, value) {\n                buf[index] = value;\n            }\n        };\n    }\n    return {\n        get(index) {\n            return buf.get(index);\n        },\n        set(index, value) {\n            buf.set(index, value);\n        }\n    };\n}\n//# sourceMappingURL=index.js.map","import accessor from 'byte-access';\nconst TWO_32 = 4294967296;\nexport class LongBits {\n    constructor(hi = 0, lo = 0) {\n        this.hi = hi;\n        this.lo = lo;\n    }\n    /**\n     * Returns these hi/lo bits as a BigInt\n     */\n    toBigInt(unsigned) {\n        if (unsigned === true) {\n            return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);\n        }\n        if ((this.hi >>> 31) !== 0) {\n            const lo = ~this.lo + 1 >>> 0;\n            let hi = ~this.hi >>> 0;\n            if (lo === 0) {\n                hi = hi + 1 >>> 0;\n            }\n            return -(BigInt(lo) + (BigInt(hi) << 32n));\n        }\n        return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);\n    }\n    /**\n     * Returns these hi/lo bits as a Number - this may overflow, toBigInt\n     * should be preferred\n     */\n    toNumber(unsigned) {\n        return Number(this.toBigInt(unsigned));\n    }\n    /**\n     * ZigZag decode a LongBits object\n     */\n    zzDecode() {\n        const mask = -(this.lo & 1);\n        const lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n        const hi = (this.hi >>> 1 ^ mask) >>> 0;\n        return new LongBits(hi, lo);\n    }\n    /**\n     * ZigZag encode a LongBits object\n     */\n    zzEncode() {\n        const mask = this.hi >> 31;\n        const hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n        const lo = (this.lo << 1 ^ mask) >>> 0;\n        return new LongBits(hi, lo);\n    }\n    /**\n     * Encode a LongBits object as a varint byte array\n     */\n    toBytes(buf, offset = 0) {\n        const access = accessor(buf);\n        while (this.hi > 0) {\n            access.set(offset++, this.lo & 127 | 128);\n            this.lo = (this.lo >>> 7 | this.hi << 25) >>> 0;\n            this.hi >>>= 7;\n        }\n        while (this.lo > 127) {\n            access.set(offset++, this.lo & 127 | 128);\n            this.lo = this.lo >>> 7;\n        }\n        access.set(offset++, this.lo);\n    }\n    /**\n     * Parse a LongBits object from a BigInt\n     */\n    static fromBigInt(value) {\n        if (value === 0n) {\n            return new LongBits();\n        }\n        const negative = value < 0;\n        if (negative) {\n            value = -value;\n        }\n        let hi = Number(value >> 32n) | 0;\n        let lo = Number(value - (BigInt(hi) << 32n)) | 0;\n        if (negative) {\n            hi = ~hi >>> 0;\n            lo = ~lo >>> 0;\n            if (++lo > TWO_32) {\n                lo = 0;\n                if (++hi > TWO_32) {\n                    hi = 0;\n                }\n            }\n        }\n        return new LongBits(hi, lo);\n    }\n    /**\n     * Parse a LongBits object from a Number\n     */\n    static fromNumber(value) {\n        if (value === 0) {\n            return new LongBits();\n        }\n        const sign = value < 0;\n        if (sign) {\n            value = -value;\n        }\n        let lo = value >>> 0;\n        let hi = (value - lo) / 4294967296 >>> 0;\n        if (sign) {\n            hi = ~hi >>> 0;\n            lo = ~lo >>> 0;\n            if (++lo > 4294967295) {\n                lo = 0;\n                if (++hi > 4294967295) {\n                    hi = 0;\n                }\n            }\n        }\n        return new LongBits(hi, lo);\n    }\n    /**\n     * Parse a LongBits object from a varint byte array\n     */\n    static fromBytes(buf, offset = 0) {\n        const access = accessor(buf);\n        // tends to deopt with local vars for octet etc.\n        const bits = new LongBits();\n        let i = 0;\n        if (buf.length - offset > 4) { // fast route (lo)\n            for (; i < 4; ++i) {\n                // 1st..4th\n                bits.lo = (bits.lo | (access.get(offset) & 127) << i * 7) >>> 0;\n                if (access.get(offset++) < 128) {\n                    return bits;\n                }\n            }\n            // 5th\n            bits.lo = (bits.lo | (access.get(offset) & 127) << 28) >>> 0;\n            bits.hi = (bits.hi | (access.get(offset) & 127) >> 4) >>> 0;\n            if (access.get(offset++) < 128) {\n                return bits;\n            }\n            i = 0;\n        }\n        else {\n            for (; i < 4; ++i) {\n                /* istanbul ignore if */\n                if (offset >= buf.length) {\n                    throw RangeError(`index out of range: ${offset} > ${buf.length}`);\n                }\n                // 1st..4th\n                bits.lo = (bits.lo | (access.get(offset) & 127) << i * 7) >>> 0;\n                if (access.get(offset++) < 128) {\n                    return bits;\n                }\n            }\n        }\n        if (buf.length - offset > 4) { // fast route (hi)\n            for (; i < 5; ++i) {\n                // 6th..10th\n                bits.hi = (bits.hi | (access.get(offset) & 127) << i * 7 + 3) >>> 0;\n                if (access.get(offset++) < 128) {\n                    return bits;\n                }\n            }\n        }\n        else if (offset < buf.byteLength) {\n            for (; i < 5; ++i) {\n                /* istanbul ignore if */\n                if (offset >= buf.length) {\n                    throw RangeError(`index out of range: ${offset} > ${buf.length}`);\n                }\n                // 6th..10th\n                bits.hi = (bits.hi | (access.get(offset) & 127) << i * 7 + 3) >>> 0;\n                if (access.get(offset++) < 128) {\n                    return bits;\n                }\n            }\n        }\n        /* istanbul ignore next */\n        throw RangeError('invalid varint encoding');\n    }\n}\n//# sourceMappingURL=index.js.map","import { LongBits } from 'longbits';\nimport { allocUnsafe } from 'uint8arrays/alloc';\nconst N1 = Math.pow(2, 7);\nconst N2 = Math.pow(2, 14);\nconst N3 = Math.pow(2, 21);\nconst N4 = Math.pow(2, 28);\nconst N5 = Math.pow(2, 35);\nconst N6 = Math.pow(2, 42);\nconst N7 = Math.pow(2, 49);\nconst N8 = Math.pow(2, 56);\nconst N9 = Math.pow(2, 63);\nexport const unsigned = {\n    encodingLength(value) {\n        if (value < N1) {\n            return 1;\n        }\n        if (value < N2) {\n            return 2;\n        }\n        if (value < N3) {\n            return 3;\n        }\n        if (value < N4) {\n            return 4;\n        }\n        if (value < N5) {\n            return 5;\n        }\n        if (value < N6) {\n            return 6;\n        }\n        if (value < N7) {\n            return 7;\n        }\n        if (value < N8) {\n            return 8;\n        }\n        if (value < N9) {\n            return 9;\n        }\n        return 10;\n    },\n    encode(value, buf, offset = 0) {\n        if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {\n            throw new RangeError('Could not encode varint');\n        }\n        if (buf == null) {\n            buf = allocUnsafe(unsigned.encodingLength(value));\n        }\n        LongBits.fromNumber(value).toBytes(buf, offset);\n        return buf;\n    },\n    decode(buf, offset = 0) {\n        return LongBits.fromBytes(buf, offset).toNumber(true);\n    }\n};\nexport const signed = {\n    encodingLength(value) {\n        if (value < 0) {\n            return 10; // 10 bytes per spec - https://developers.google.com/protocol-buffers/docs/encoding#signed-ints\n        }\n        return unsigned.encodingLength(value);\n    },\n    encode(value, buf, offset) {\n        if (buf == null) {\n            buf = allocUnsafe(signed.encodingLength(value));\n        }\n        if (value < 0) {\n            LongBits.fromNumber(value).toBytes(buf, offset);\n            return buf;\n        }\n        return unsigned.encode(value, buf, offset);\n    },\n    decode(buf, offset = 0) {\n        return LongBits.fromBytes(buf, offset).toNumber(false);\n    }\n};\nexport const zigzag = {\n    encodingLength(value) {\n        return unsigned.encodingLength(value >= 0 ? value * 2 : value * -2 - 1);\n    },\n    // @ts-expect-error\n    encode(value, buf, offset) {\n        value = value >= 0 ? value * 2 : (value * -2) - 1;\n        return unsigned.encode(value, buf, offset);\n    },\n    decode(buf, offset = 0) {\n        const value = unsigned.decode(buf, offset);\n        return (value & 1) !== 0 ? (value + 1) / -2 : value / 2;\n    }\n};\n//# sourceMappingURL=index.js.map","export function alloc(len) {\n    return new Uint8Array(len);\n}\nexport function allocUnsafe(len) {\n    if (globalThis?.Buffer?.allocUnsafe != null) {\n        return globalThis.Buffer.allocUnsafe(len);\n    }\n    return new Uint8Array(len);\n}\n//# sourceMappingURL=alloc.js.map","import { Uint8ArrayList } from 'uint8arraylist';\nimport { unsigned } from 'uint8-varint';\nimport { allocUnsafe } from './alloc.js';\nconst defaultEncoder = (length) => {\n    const lengthLength = unsigned.encodingLength(length);\n    const lengthBuf = allocUnsafe(lengthLength);\n    unsigned.encode(length, lengthBuf);\n    defaultEncoder.bytes = lengthLength;\n    return lengthBuf;\n};\ndefaultEncoder.bytes = 0;\nexport function encode(options) {\n    options = options ?? {};\n    const encodeLength = options.lengthEncoder ?? defaultEncoder;\n    const encoder = async function* (source) {\n        for await (const chunk of source) {\n            // length + data\n            const length = encodeLength(chunk.byteLength);\n            // yield only Uint8Arrays\n            if (length instanceof Uint8Array) {\n                yield length;\n            }\n            else {\n                yield* length;\n            }\n            // yield only Uint8Arrays\n            if (chunk instanceof Uint8Array) {\n                yield chunk;\n            }\n            else {\n                yield* chunk;\n            }\n        }\n    };\n    return encoder;\n}\nencode.single = (chunk, options) => {\n    options = options ?? {};\n    const encodeLength = options.lengthEncoder ?? defaultEncoder;\n    return new Uint8ArrayList(encodeLength(chunk.byteLength), chunk);\n};\n//# sourceMappingURL=encode.js.map","/* eslint max-depth: [\"error\", 6] */\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { unsigned } from 'uint8-varint';\nimport errCode from 'err-code';\n// Maximum length of the length section of the message\nexport const MAX_LENGTH_LENGTH = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nexport const MAX_DATA_LENGTH = 1024 * 1024 * 4;\nvar ReadMode;\n(function (ReadMode) {\n    ReadMode[ReadMode[\"LENGTH\"] = 0] = \"LENGTH\";\n    ReadMode[ReadMode[\"DATA\"] = 1] = \"DATA\";\n})(ReadMode || (ReadMode = {}));\nconst defaultDecoder = (buf) => {\n    const length = unsigned.decode(buf);\n    defaultDecoder.bytes = unsigned.encodingLength(length);\n    return length;\n};\ndefaultDecoder.bytes = 0;\nexport function decode(options) {\n    const decoder = async function* (source) {\n        const buffer = new Uint8ArrayList();\n        let mode = ReadMode.LENGTH;\n        let dataLength = -1;\n        const lengthDecoder = options?.lengthDecoder ?? defaultDecoder;\n        const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH;\n        const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;\n        for await (const buf of source) {\n            buffer.append(buf);\n            while (buffer.byteLength > 0) {\n                if (mode === ReadMode.LENGTH) {\n                    // read length, ignore errors for short reads\n                    try {\n                        dataLength = lengthDecoder(buffer);\n                        if (dataLength < 0) {\n                            throw errCode(new Error('invalid message length'), 'ERR_INVALID_MSG_LENGTH');\n                        }\n                        if (dataLength > maxDataLength) {\n                            throw errCode(new Error('message length too long'), 'ERR_MSG_DATA_TOO_LONG');\n                        }\n                        const dataLengthLength = lengthDecoder.bytes;\n                        buffer.consume(dataLengthLength);\n                        if (options?.onLength != null) {\n                            options.onLength(dataLength);\n                        }\n                        mode = ReadMode.DATA;\n                    }\n                    catch (err) {\n                        if (err instanceof RangeError) {\n                            if (buffer.byteLength > maxLengthLength) {\n                                throw errCode(new Error('message length length too long'), 'ERR_MSG_LENGTH_TOO_LONG');\n                            }\n                            break;\n                        }\n                        throw err;\n                    }\n                }\n                if (mode === ReadMode.DATA) {\n                    if (buffer.byteLength < dataLength) {\n                        // not enough data, wait for more\n                        break;\n                    }\n                    const data = buffer.sublist(0, dataLength);\n                    buffer.consume(dataLength);\n                    if (options?.onData != null) {\n                        options.onData(data);\n                    }\n                    yield data;\n                    mode = ReadMode.LENGTH;\n                }\n            }\n        }\n        if (buffer.byteLength > 0) {\n            throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF');\n        }\n    };\n    return decoder;\n}\n/**\n * @param {*} reader\n * @param {import('./types').DecoderOptions} [options]\n * @returns\n */\ndecode.fromReader = (reader, options) => {\n    let byteLength = 1; // Read single byte chunks until the length is known\n    const varByteSource = (async function* () {\n        while (true) {\n            try {\n                const { done, value } = await reader.next(byteLength);\n                if (done === true) {\n                    return;\n                }\n                if (value != null) {\n                    yield value;\n                }\n            }\n            catch (err) {\n                if (err.code === 'ERR_UNDER_READ') {\n                    return { done: true, value: null };\n                }\n                throw err;\n            }\n            finally {\n                // Reset the byteLength so we continue to check for varints\n                byteLength = 1;\n            }\n        }\n    }());\n    /**\n     * Once the length has been parsed, read chunk for that length\n     */\n    const onLength = (l) => { byteLength = l; };\n    return decode({\n        ...(options ?? {}),\n        onLength\n    })(varByteSource);\n};\n//# sourceMappingURL=decode.js.map","/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive Protobuf encoded messages over\n * streams.\n *\n * @example\n *\n * ```typescript\n * import { pbStream } from 'it-pb-stream'\n * import { MessageType } from './src/my-message-type.js'\n *\n * // RequestType and ResponseType have been generate from `.proto` files and have\n * // `.encode` and `.decode` methods for serialization/deserialization\n *\n * const stream = pbStream(duplex)\n * stream.writePB({\n *   foo: 'bar'\n * }, MessageType)\n * const res = await stream.readPB(MessageType)\n * ```\n */\nimport { handshake } from 'it-handshake';\nimport * as lp from 'it-length-prefixed';\nexport function pbStream(duplex, opts = {}) {\n    const shake = handshake(duplex);\n    const lpReader = lp.decode.fromReader(shake.reader, opts);\n    const W = {\n        read: async (bytes) => {\n            // just read\n            const { value } = await shake.reader.next(bytes);\n            if (value == null) {\n                throw new Error('Value is null');\n            }\n            return value;\n        },\n        readLP: async () => {\n            // read, decode\n            // @ts-expect-error .next is part of the generator interface\n            const { value } = await lpReader.next();\n            if (value == null) {\n                throw new Error('Value is null');\n            }\n            return value;\n        },\n        readPB: async (proto) => {\n            // readLP, decode\n            const value = await W.readLP();\n            if (value == null) {\n                throw new Error('Value is null');\n            }\n            // Is this a buffer?\n            const buf = value instanceof Uint8Array ? value : value.subarray();\n            return proto.decode(buf);\n        },\n        write: (data) => {\n            // just write\n            if (data instanceof Uint8Array) {\n                shake.writer.push(data);\n            }\n            else {\n                shake.writer.push(data.subarray());\n            }\n        },\n        writeLP: (data) => {\n            // encode, write\n            W.write(lp.encode.single(data, opts));\n        },\n        writePB: (data, proto) => {\n            // encode, writeLP\n            W.writeLP(proto.encode(data));\n        },\n        pb: (proto) => {\n            return {\n                read: async () => await W.readPB(proto),\n                write: (d) => W.writePB(d, proto)\n            };\n        },\n        unwrap: () => {\n            // returns vanilla duplex again, terminates all reads/writes from this object\n            shake.rest();\n            return shake.stream;\n        }\n    };\n    return W;\n}\n//# sourceMappingURL=index.js.map","import defer from 'p-defer';\n/**\n * A pair of streams where one drains from the other\n */\nexport function pair() {\n    const deferred = defer();\n    let piped = false;\n    return {\n        sink: async (source) => {\n            if (piped) {\n                throw new Error('already piped');\n            }\n            piped = true;\n            deferred.resolve(source);\n        },\n        source: (async function* () {\n            const source = await deferred.promise;\n            yield* source;\n        }())\n    };\n}\n//# sourceMappingURL=index.js.map","import { pair } from './index.js';\n/**\n * Two duplex streams that are attached to each other\n */\nexport function duplexPair() {\n    const a = pair();\n    const b = pair();\n    return [\n        {\n            source: a.source,\n            sink: b.sink\n        },\n        {\n            source: b.source,\n            sink: a.sink\n        }\n    ];\n}\n//# sourceMappingURL=duplex.js.map","import { pushable } from 'it-pushable';\n/**\n * Treat one or more iterables as a single iterable.\n *\n * Nb. sources are iterated over in parallel so the\n * order of emitted items is not guaranteed.\n */\nexport default async function* merge(...sources) {\n    const output = pushable({\n        objectMode: true\n    });\n    void Promise.resolve().then(async () => {\n        try {\n            await Promise.all(sources.map(async (source) => {\n                for await (const item of source) {\n                    output.push(item);\n                }\n            }));\n            output.end();\n        }\n        catch (err) {\n            output.end(err);\n        }\n    });\n    yield* output;\n}\n//# sourceMappingURL=index.js.map","import { pushable } from 'it-pushable';\nimport merge from 'it-merge';\nexport const rawPipe = (...fns) => {\n    let res;\n    while (fns.length > 0) {\n        res = fns.shift()(res);\n    }\n    return res;\n};\nexport const isIterable = (obj) => {\n    return obj != null && (typeof obj[Symbol.asyncIterator] === 'function' ||\n        typeof obj[Symbol.iterator] === 'function' ||\n        typeof obj.next === 'function' // Probably, right?\n    );\n};\nexport const isDuplex = (obj) => {\n    return obj != null && typeof obj.sink === 'function' && isIterable(obj.source);\n};\nconst duplexPipelineFn = (duplex) => {\n    return (source) => {\n        const p = duplex.sink(source);\n        if (p.then != null) {\n            const stream = pushable({\n                objectMode: true\n            });\n            p.then(() => {\n                stream.end();\n            }, (err) => {\n                stream.end(err);\n            });\n            const sourceWrap = async function* () {\n                yield* duplex.source;\n                stream.end();\n            };\n            return merge(stream, sourceWrap());\n        }\n        return duplex.source;\n    };\n};\nexport function pipe(first, ...rest) {\n    // Duplex at start: wrap in function and return duplex source\n    if (isDuplex(first)) {\n        const duplex = first;\n        first = () => duplex.source;\n        // Iterable at start: wrap in function\n    }\n    else if (isIterable(first)) {\n        const source = first;\n        first = () => source;\n    }\n    const fns = [first, ...rest];\n    if (fns.length > 1) {\n        // Duplex at end: use duplex sink\n        if (isDuplex(fns[fns.length - 1])) {\n            fns[fns.length - 1] = fns[fns.length - 1].sink;\n        }\n    }\n    if (fns.length > 2) {\n        // Duplex in the middle, consume source with duplex sink and return duplex source\n        for (let i = 1; i < fns.length - 1; i++) {\n            if (isDuplex(fns[i])) {\n                fns[i] = duplexPipelineFn(fns[i]);\n            }\n        }\n    }\n    return rawPipe(...fns);\n}\n//# sourceMappingURL=index.js.map","export const NOISE_MSG_MAX_LENGTH_BYTES = 65535;\nexport const NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;\nexport const DUMP_SESSION_KEYS = Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS);\n//# sourceMappingURL=constants.js.map","\"use strict\";\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isSerializableHash(h) {\n    return (typeof h.saveState !== \"undefined\" &&\n        typeof h.restoreState !== \"undefined\" &&\n        typeof h.cleanSavedState !== \"undefined\");\n}\nexports.isSerializableHash = isSerializableHash;\n// TODO(dchest): figure out the standardized interface for XOF such as\n// SHAKE and BLAKE2X.\n//# sourceMappingURL=hash.js.map","\"use strict\";\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Package hmac implements HMAC algorithm.\n */\nvar hash_1 = require(\"@stablelib/hash\");\nvar constant_time_1 = require(\"@stablelib/constant-time\");\nvar wipe_1 = require(\"@stablelib/wipe\");\n/**\n *  HMAC implements hash-based message authentication algorithm.\n */\nvar HMAC = /** @class */ (function () {\n    /**\n     * Constructs a new HMAC with the given Hash and secret key.\n     */\n    function HMAC(hash, key) {\n        this._finished = false; // true if HMAC was finalized\n        // Initialize inner and outer hashes.\n        this._inner = new hash();\n        this._outer = new hash();\n        // Set block and digest sizes for this HMAC\n        // instance to values from the hash.\n        this.blockSize = this._outer.blockSize;\n        this.digestLength = this._outer.digestLength;\n        // Pad temporary stores a key (or its hash) padded with zeroes.\n        var pad = new Uint8Array(this.blockSize);\n        if (key.length > this.blockSize) {\n            // If key is bigger than hash block size, it must be\n            // hashed and this hash is used as a key instead.\n            this._inner.update(key).finish(pad).clean();\n        }\n        else {\n            // Otherwise, copy the key into pad.\n            pad.set(key);\n        }\n        // Now two different keys are derived from padded key\n        // by xoring a different byte value to each.\n        // To make inner hash key, xor byte 0x36 into pad.\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36;\n        }\n        // Update inner hash with the result.\n        this._inner.update(pad);\n        // To make outer hash key, xor byte 0x5c into pad.\n        // But since we already xored 0x36 there, we must\n        // first undo this by xoring it again.\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36 ^ 0x5c;\n        }\n        // Update outer hash with the result.\n        this._outer.update(pad);\n        // Save states of both hashes, so that we can quickly restore\n        // them later in reset() without the need to remember the actual\n        // key and perform this initialization again.\n        if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {\n            this._innerKeyedState = this._inner.saveState();\n            this._outerKeyedState = this._outer.saveState();\n        }\n        // Clean pad.\n        wipe_1.wipe(pad);\n    }\n    /**\n     * Returns HMAC state to the state initialized with key\n     * to make it possible to run HMAC over the other data with the same\n     * key without creating a new instance.\n     */\n    HMAC.prototype.reset = function () {\n        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n            throw new Error(\"hmac: can't reset() because hash doesn't implement restoreState()\");\n        }\n        // Restore keyed states of inner and outer hashes.\n        this._inner.restoreState(this._innerKeyedState);\n        this._outer.restoreState(this._outerKeyedState);\n        this._finished = false;\n        return this;\n    };\n    /**\n     * Cleans HMAC state.\n     */\n    HMAC.prototype.clean = function () {\n        if (hash_1.isSerializableHash(this._inner)) {\n            this._inner.cleanSavedState(this._innerKeyedState);\n        }\n        if (hash_1.isSerializableHash(this._outer)) {\n            this._outer.cleanSavedState(this._outerKeyedState);\n        }\n        this._inner.clean();\n        this._outer.clean();\n    };\n    /**\n     * Updates state with provided data.\n     */\n    HMAC.prototype.update = function (data) {\n        this._inner.update(data);\n        return this;\n    };\n    /**\n     * Finalizes HMAC and puts the result in out.\n     */\n    HMAC.prototype.finish = function (out) {\n        if (this._finished) {\n            // If HMAC was finalized, outer hash is also finalized,\n            // so it produces the same digest it produced when it\n            // was finalized.\n            this._outer.finish(out);\n            return this;\n        }\n        // Finalize inner hash and store the result temporarily.\n        this._inner.finish(out);\n        // Update outer hash with digest of inner hash and and finalize it.\n        this._outer.update(out.subarray(0, this.digestLength)).finish(out);\n        this._finished = true;\n        return this;\n    };\n    /**\n     * Returns the computed message authentication code.\n     */\n    HMAC.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    /**\n     * Saves HMAC state.\n     * This function is needed for PBKDF2 optimization.\n     */\n    HMAC.prototype.saveState = function () {\n        if (!hash_1.isSerializableHash(this._inner)) {\n            throw new Error(\"hmac: can't saveState() because hash doesn't implement it\");\n        }\n        return this._inner.saveState();\n    };\n    HMAC.prototype.restoreState = function (savedState) {\n        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n            throw new Error(\"hmac: can't restoreState() because hash doesn't implement it\");\n        }\n        this._inner.restoreState(savedState);\n        this._outer.restoreState(this._outerKeyedState);\n        this._finished = false;\n        return this;\n    };\n    HMAC.prototype.cleanSavedState = function (savedState) {\n        if (!hash_1.isSerializableHash(this._inner)) {\n            throw new Error(\"hmac: can't cleanSavedState() because hash doesn't implement it\");\n        }\n        this._inner.cleanSavedState(savedState);\n    };\n    return HMAC;\n}());\nexports.HMAC = HMAC;\n/**\n * Returns HMAC using the given hash constructor for the key over data.\n */\nfunction hmac(hash, key, data) {\n    var h = new HMAC(hash, key);\n    h.update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hmac = hmac;\n/**\n * Returns true if two HMAC digests are equal.\n * Uses constant-time comparison to avoid leaking timing information.\n *\n * Example:\n *\n *    const receivedDigest = ...\n *    const realDigest = hmac(SHA256, key, data);\n *    if (!equal(receivedDigest, realDigest)) {\n *        throw new Error(\"Authentication error\");\n *    }\n */\nexports.equal = constant_time_1.equal;\n//# sourceMappingURL=hmac.js.map","\"use strict\";\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar hmac_1 = require(\"@stablelib/hmac\");\nvar wipe_1 = require(\"@stablelib/wipe\");\n/**\n * HMAC-based Extract-and-Expand Key Derivation Function.\n *\n * Implements HKDF from RFC5869.\n *\n * Expands the given master key with salt and info into\n * a limited stream of key material.\n */\nvar HKDF = /** @class */ (function () {\n    /**\n     * Create a new HKDF instance for the given hash function\n     * with the master key, optional salt, and info.\n     *\n     * - Master key is a high-entropy secret key (not a password).\n     * - Salt is a non-secret random value.\n     * - Info is application- and/or context-specific information.\n     */\n    function HKDF(hash, key, salt, info) {\n        if (salt === void 0) { salt = new Uint8Array(0); }\n        this._counter = new Uint8Array(1); // starts with zero\n        this._hash = hash;\n        this._info = info;\n        // HKDF-Extract uses salt as HMAC key, and key as data.\n        var okm = hmac_1.hmac(this._hash, salt, key);\n        // Initialize HMAC for expanding with extracted key.\n        this._hmac = new hmac_1.HMAC(hash, okm);\n        // Allocate buffer.\n        this._buffer = new Uint8Array(this._hmac.digestLength);\n        this._bufpos = this._buffer.length;\n    }\n    // Fill buffer with new block of HKDF-Extract output.\n    HKDF.prototype._fillBuffer = function () {\n        // Increment counter.\n        this._counter[0]++;\n        var ctr = this._counter[0];\n        // Check if counter overflowed.\n        if (ctr === 0) {\n            throw new Error(\"hkdf: cannot expand more\");\n        }\n        // Prepare HMAC instance for new data with old key.\n        this._hmac.reset();\n        // Hash in previous output if it was generated\n        // (i.e. counter is greater than 1).\n        if (ctr > 1) {\n            this._hmac.update(this._buffer);\n        }\n        // Hash in info if it exists.\n        if (this._info) {\n            this._hmac.update(this._info);\n        }\n        // Hash in the counter.\n        this._hmac.update(this._counter);\n        // Output result to buffer and clean HMAC instance.\n        this._hmac.finish(this._buffer);\n        // Reset buffer position.\n        this._bufpos = 0;\n    };\n    /**\n     * Expand returns next key material of the given length.\n     *\n     * It throws if expansion limit is reached (which is\n     * 254 digests of the underlying HMAC function).\n     */\n    HKDF.prototype.expand = function (length) {\n        var out = new Uint8Array(length);\n        for (var i = 0; i < out.length; i++) {\n            if (this._bufpos === this._buffer.length) {\n                this._fillBuffer();\n            }\n            out[i] = this._buffer[this._bufpos++];\n        }\n        return out;\n    };\n    HKDF.prototype.clean = function () {\n        this._hmac.clean();\n        wipe_1.wipe(this._buffer);\n        wipe_1.wipe(this._counter);\n        this._bufpos = 0;\n    };\n    return HKDF;\n}());\nexports.HKDF = HKDF;\n// TODO(dchest): maybe implement deriveKey?\n//# sourceMappingURL=hkdf.js.map","import { HKDF } from '@stablelib/hkdf';\nimport * as x25519 from '@stablelib/x25519';\nimport { SHA256, hash } from '@stablelib/sha256';\nimport { ChaCha20Poly1305 } from '@stablelib/chacha20poly1305';\nexport const stablelib = {\n    hashSHA256(data) {\n        return hash(data);\n    },\n    getHKDF(ck, ikm) {\n        const hkdf = new HKDF(SHA256, ikm, ck);\n        const okmU8Array = hkdf.expand(96);\n        const okm = okmU8Array;\n        const k1 = okm.subarray(0, 32);\n        const k2 = okm.subarray(32, 64);\n        const k3 = okm.subarray(64, 96);\n        return [k1, k2, k3];\n    },\n    generateX25519KeyPair() {\n        const keypair = x25519.generateKeyPair();\n        return {\n            publicKey: keypair.publicKey,\n            privateKey: keypair.secretKey\n        };\n    },\n    generateX25519KeyPairFromSeed(seed) {\n        const keypair = x25519.generateKeyPairFromSeed(seed);\n        return {\n            publicKey: keypair.publicKey,\n            privateKey: keypair.secretKey\n        };\n    },\n    generateX25519SharedKey(privateKey, publicKey) {\n        return x25519.sharedKey(privateKey, publicKey);\n    },\n    chaCha20Poly1305Encrypt(plaintext, nonce, ad, k) {\n        const ctx = new ChaCha20Poly1305(k);\n        return ctx.seal(nonce, plaintext, ad);\n    },\n    chaCha20Poly1305Decrypt(ciphertext, nonce, ad, k, dst) {\n        const ctx = new ChaCha20Poly1305(k);\n        return ctx.open(nonce, ciphertext, ad, dst);\n    }\n};\n//# sourceMappingURL=stablelib.js.map","import { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nconst allocUnsafe = (len) => {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.allocUnsafe(len);\n    }\n    return new Uint8Array(len);\n};\nexport const uint16BEEncode = (value) => {\n    const target = allocUnsafe(2);\n    new DataView(target.buffer, target.byteOffset, target.byteLength).setUint16(0, value, false);\n    return target;\n};\nuint16BEEncode.bytes = 2;\nexport const uint16BEDecode = (data) => {\n    if (data.length < 2)\n        throw RangeError('Could not decode int16BE');\n    if (data instanceof Uint8Array) {\n        return new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0, false);\n    }\n    return data.getUint16(0);\n};\nuint16BEDecode.bytes = 2;\n// Note: IK and XX encoder usage is opposite (XX uses in stages encode0 where IK uses encode1)\nexport function encode0(message) {\n    return uint8ArrayConcat([message.ne, message.ciphertext], message.ne.length + message.ciphertext.length);\n}\nexport function encode1(message) {\n    return uint8ArrayConcat([message.ne, message.ns, message.ciphertext], message.ne.length + message.ns.length + message.ciphertext.length);\n}\nexport function encode2(message) {\n    return uint8ArrayConcat([message.ns, message.ciphertext], message.ns.length + message.ciphertext.length);\n}\nexport function decode0(input) {\n    if (input.length < 32) {\n        throw new Error('Cannot decode stage 0 MessageBuffer: length less than 32 bytes.');\n    }\n    return {\n        ne: input.subarray(0, 32),\n        ciphertext: input.subarray(32, input.length),\n        ns: new Uint8Array(0)\n    };\n}\nexport function decode1(input) {\n    if (input.length < 80) {\n        throw new Error('Cannot decode stage 1 MessageBuffer: length less than 80 bytes.');\n    }\n    return {\n        ne: input.subarray(0, 32),\n        ns: input.subarray(32, 80),\n        ciphertext: input.subarray(80, input.length)\n    };\n}\nexport function decode2(input) {\n    if (input.length < 48) {\n        throw new Error('Cannot decode stage 2 MessageBuffer: length less than 48 bytes.');\n    }\n    return {\n        ne: new Uint8Array(0),\n        ns: input.subarray(0, 48),\n        ciphertext: input.subarray(48, input.length)\n    };\n}\n//# sourceMappingURL=encoder.js.map","import { TAG_LENGTH } from '@stablelib/chacha20poly1305';\nimport { NOISE_MSG_MAX_LENGTH_BYTES, NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG } from '../constants.js';\nimport { uint16BEEncode } from '../encoder.js';\n// Returns generator that encrypts payload from the user\nexport function encryptStream(handshake, metrics) {\n    return async function* (source) {\n        for await (const chunk of source) {\n            for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n                let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n                if (end > chunk.length) {\n                    end = chunk.length;\n                }\n                const data = handshake.encrypt(chunk.subarray(i, end), handshake.session);\n                metrics?.encryptedPackets.increment();\n                yield uint16BEEncode(data.byteLength);\n                yield data;\n            }\n        }\n    };\n}\n// Decrypt received payload to the user\nexport function decryptStream(handshake, metrics) {\n    return async function* (source) {\n        for await (const chunk of source) {\n            for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {\n                let end = i + NOISE_MSG_MAX_LENGTH_BYTES;\n                if (end > chunk.length) {\n                    end = chunk.length;\n                }\n                if (end - TAG_LENGTH < i) {\n                    throw new Error('Invalid chunk');\n                }\n                const encrypted = chunk.subarray(i, end);\n                // memory allocation is not cheap so reuse the encrypted Uint8Array\n                // see https://github.com/ChainSafe/js-libp2p-noise/pull/242#issue-1422126164\n                // this is ok because chacha20 reads bytes one by one and don't reread after that\n                // it's also tested in https://github.com/ChainSafe/as-chacha20poly1305/pull/1/files#diff-25252846b58979dcaf4e41d47b3eadd7e4f335e7fb98da6c049b1f9cd011f381R48\n                const dst = chunk.subarray(i, end - TAG_LENGTH);\n                const { plaintext: decrypted, valid } = handshake.decrypt(encrypted, handshake.session, dst);\n                if (!valid) {\n                    metrics?.decryptErrors.increment();\n                    throw new Error('Failed to validate decrypted chunk');\n                }\n                metrics?.decryptedPackets.increment();\n                yield decrypted;\n            }\n        }\n    };\n}\n//# sourceMappingURL=streaming.js.map","export class UnexpectedPeerError extends Error {\n    constructor(message = 'Unexpected Peer') {\n        super(message);\n        this.code = UnexpectedPeerError.code;\n    }\n    static get code() {\n        return 'ERR_UNEXPECTED_PEER';\n    }\n}\nexport class InvalidCryptoExchangeError extends Error {\n    constructor(message = 'Invalid crypto exchange') {\n        super(message);\n        this.code = InvalidCryptoExchangeError.code;\n    }\n    static get code() {\n        return 'ERR_INVALID_CRYPTO_EXCHANGE';\n    }\n}\nexport class InvalidCryptoTransmissionError extends Error {\n    constructor(message = 'Invalid crypto transmission') {\n        super(message);\n        this.code = InvalidCryptoTransmissionError.code;\n    }\n    static get code() {\n        return 'ERR_INVALID_CRYPTO_TRANSMISSION';\n    }\n}\n//# sourceMappingURL=errors.js.map","var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing alogrithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n","// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n","import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import * as varint from './varint.js'\nimport * as Digest from './hashes/digest.js'\nimport { base58btc } from './bases/base58.js'\nimport { base32 } from './bases/base32.js'\nimport { coerce } from './bytes.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   *\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  toJSON () {\n    return {\n      code: this.code,\n      version: this.version,\n      hash: this.multihash.bytes\n    }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returs null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n","// @ts-check\n\nimport { from } from './base.js'\nimport { fromString, toString } from '../bytes.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n","// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n","// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n","import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n","// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n","import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n","// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n","import { from } from './base.js'\n\nconst alphabet = Array.from('🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂')\nconst alphabetBytesToChars = /** @type {string[]} */ (alphabet.reduce((p, c, i) => { p[i] = c; return p }, /** @type {string[]} */([])))\nconst alphabetCharsToBytes = /** @type {number[]} */ (alphabet.reduce((p, c, i) => { p[/** @type {number} */ (c.codePointAt(0))] = i; return p }, /** @type {number[]} */([])))\n\n/**\n * @param {Uint8Array} data\n * @returns {string}\n */\nfunction encode (data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nfunction decode (str) {\n  const byts = []\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[/** @type {number} */ (char.codePointAt(0))]\n    if (byt === undefined) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: '🚀',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n","import * as Digest from './digest.js'\n\n/**\n * @template {string} Name\n * @template {number} Code\n * @param {object} options\n * @param {Name} options.name\n * @param {Code} options.code\n * @param {(input: Uint8Array) => Await<Uint8Array>} options.encode\n */\nexport const from = ({ name, code, encode }) => new Hasher(name, code, encode)\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n *\n * @template {string} Name\n * @template {number} Code\n * @class\n * @implements {MultihashHasher<Code>}\n */\nexport class Hasher {\n  /**\n   *\n   * @param {Name} name\n   * @param {Code} code\n   * @param {(input: Uint8Array) => Await<Uint8Array>} encode\n   */\n  constructor (name, code, encode) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  /**\n   * @param {Uint8Array} input\n   * @returns {Await<Digest.Digest<Code, number>>}\n   */\n  digest (input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * @template {number} Alg\n * @typedef {import('./interface.js').MultihashHasher} MultihashHasher\n */\n\n/**\n * @template T\n * @typedef {Promise<T>|T} Await\n */\n","/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n","import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n","// @ts-check\n\n/**\n * @template T\n * @typedef {import('./interface.js').ByteView<T>} ByteView\n */\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => textEncoder.encode(JSON.stringify(node))\n\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => JSON.parse(textDecoder.decode(data))\n","// @ts-check\n\nimport * as identityBase from './bases/identity.js'\nimport * as base2 from './bases/base2.js'\nimport * as base8 from './bases/base8.js'\nimport * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as sha2 from './hashes/sha2.js'\nimport * as identity from './hashes/identity.js'\n\nimport * as raw from './codecs/raw.js'\nimport * as json from './codecs/json.js'\n\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nconst bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nconst hashes = { ...sha2, ...identity }\nconst codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes, hashes, bases, codecs }\n","export const symbol = Symbol.for('@libp2p/peer-id');\nexport function isPeerId(other) {\n    return other != null && Boolean(other[symbol]);\n}\n//# sourceMappingURL=index.js.map","import { CID } from 'multiformats/cid';\nimport { bases } from 'multiformats/basics';\nimport { base58btc } from 'multiformats/bases/base58';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport errcode from 'err-code';\nimport { symbol } from '@libp2p/interface-peer-id';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object\n    .values(bases)\n    .map(codec => codec.decoder)\n    // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n    .reduce((acc, curr) => acc.or(curr), bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nclass PeerIdImpl {\n    constructor(init) {\n        this.type = init.type;\n        this.multihash = init.multihash;\n        this.privateKey = init.privateKey;\n        // mark string cache as non-enumerable\n        Object.defineProperty(this, 'string', {\n            enumerable: false,\n            writable: true\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return `PeerId(${this.toString()})`;\n    }\n    get [symbol]() {\n        return true;\n    }\n    toString() {\n        if (this.string == null) {\n            this.string = base58btc.encode(this.multihash.bytes).slice(1);\n        }\n        return this.string;\n    }\n    // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n    toCID() {\n        return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n    }\n    toBytes() {\n        return this.multihash.bytes;\n    }\n    /**\n     * Returns Multiaddr as a JSON encoded object\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId\n     */\n    equals(id) {\n        if (id instanceof Uint8Array) {\n            return uint8ArrayEquals(this.multihash.bytes, id);\n        }\n        else if (typeof id === 'string') {\n            return peerIdFromString(id).equals(this);\n        }\n        else if (id?.multihash?.bytes != null) {\n            return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n        }\n        else {\n            throw new Error('not valid Id');\n        }\n    }\n    /**\n     * Returns PeerId as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { peerIdFromString } from '@libp2p/peer-id'\n     *\n     * console.info(peerIdFromString('QmFoo'))\n     * // 'PeerId(QmFoo)'\n     * ```\n     */\n    [inspect]() {\n        return `PeerId(${this.toString()})`;\n    }\n}\nclass RSAPeerIdImpl extends PeerIdImpl {\n    constructor(init) {\n        super({ ...init, type: 'RSA' });\n        this.type = 'RSA';\n        this.publicKey = init.publicKey;\n    }\n}\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n    constructor(init) {\n        super({ ...init, type: 'Ed25519' });\n        this.type = 'Ed25519';\n        this.publicKey = init.multihash.digest;\n    }\n}\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n    constructor(init) {\n        super({ ...init, type: 'secp256k1' });\n        this.type = 'secp256k1';\n        this.publicKey = init.multihash.digest;\n    }\n}\nexport function createPeerId(init) {\n    if (init.type === 'RSA') {\n        return new RSAPeerIdImpl(init);\n    }\n    if (init.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(init);\n    }\n    if (init.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(init);\n    }\n    throw errcode(new Error('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"'), 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromPeerId(other) {\n    if (other.type === 'RSA') {\n        return new RSAPeerIdImpl(other);\n    }\n    if (other.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(other);\n    }\n    if (other.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(other);\n    }\n    throw errcode(new Error('Not a PeerId'), 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n    decoder = decoder ?? baseDecoder;\n    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n        // identity hash ed25519/secp256k1 key or sha2-256 hash of\n        // rsa public key - base58btc encoded either way\n        const multihash = Digest.decode(base58btc.decode(`z${str}`));\n        if (str.startsWith('12D')) {\n            return new Ed25519PeerIdImpl({ multihash });\n        }\n        else if (str.startsWith('16U')) {\n            return new Secp256k1PeerIdImpl({ multihash });\n        }\n        else {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n    try {\n        const multihash = Digest.decode(buf);\n        if (multihash.code === identity.code) {\n            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n                return new Ed25519PeerIdImpl({ multihash });\n            }\n            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n                return new Secp256k1PeerIdImpl({ multihash });\n            }\n        }\n        if (multihash.code === sha256.code) {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    catch {\n        return peerIdFromCID(CID.decode(buf));\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n    if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n        throw new Error('Supplied PeerID CID is invalid');\n    }\n    const multihash = cid.multihash;\n    if (multihash.code === sha256.code) {\n        return new RSAPeerIdImpl({ multihash: cid.multihash });\n    }\n    else if (multihash.code === identity.code) {\n        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n            return new Ed25519PeerIdImpl({ multihash: cid.multihash });\n        }\n        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n            return new Secp256k1PeerIdImpl({ multihash: cid.multihash });\n        }\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys(publicKey, privateKey) {\n    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey });\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var NoiseExtensions;\n(function (NoiseExtensions) {\n    let _codec;\n    NoiseExtensions.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.webtransportCerthashes != null) {\n                    for (const value of obj.webtransportCerthashes) {\n                        w.uint32(10);\n                        w.bytes(value);\n                    }\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    webtransportCerthashes: []\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.webtransportCerthashes.push(reader.bytes());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    NoiseExtensions.encode = (obj) => {\n        return encodeMessage(obj, NoiseExtensions.codec());\n    };\n    NoiseExtensions.decode = (buf) => {\n        return decodeMessage(buf, NoiseExtensions.codec());\n    };\n})(NoiseExtensions || (NoiseExtensions = {}));\nexport var NoiseHandshakePayload;\n(function (NoiseHandshakePayload) {\n    let _codec;\n    NoiseHandshakePayload.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (opts.writeDefaults === true || (obj.identityKey != null && obj.identityKey.byteLength > 0)) {\n                    w.uint32(10);\n                    w.bytes(obj.identityKey);\n                }\n                if (opts.writeDefaults === true || (obj.identitySig != null && obj.identitySig.byteLength > 0)) {\n                    w.uint32(18);\n                    w.bytes(obj.identitySig);\n                }\n                if (obj.extensions != null) {\n                    w.uint32(34);\n                    NoiseExtensions.codec().encode(obj.extensions, w, {\n                        writeDefaults: false\n                    });\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    identityKey: new Uint8Array(0),\n                    identitySig: new Uint8Array(0)\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.identityKey = reader.bytes();\n                            break;\n                        case 2:\n                            obj.identitySig = reader.bytes();\n                            break;\n                        case 4:\n                            obj.extensions = NoiseExtensions.codec().decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    NoiseHandshakePayload.encode = (obj) => {\n        return encodeMessage(obj, NoiseHandshakePayload.codec());\n    };\n    NoiseHandshakePayload.decode = (buf) => {\n        return decodeMessage(buf, NoiseHandshakePayload.codec());\n    };\n})(NoiseHandshakePayload || (NoiseHandshakePayload = {}));\n//# sourceMappingURL=payload.js.map","import { unmarshalPublicKey, unmarshalPrivateKey } from '@libp2p/crypto/keys';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { NoiseHandshakePayload } from './proto/payload.js';\nexport async function getPayload(localPeer, staticPublicKey, extensions) {\n    const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));\n    if (localPeer.publicKey == null) {\n        throw new Error('PublicKey was missing from local PeerId');\n    }\n    return createHandshakePayload(localPeer.publicKey, signedPayload, extensions);\n}\nexport function createHandshakePayload(libp2pPublicKey, signedPayload, extensions) {\n    return NoiseHandshakePayload.encode({\n        identityKey: libp2pPublicKey,\n        identitySig: signedPayload,\n        extensions: extensions ?? { webtransportCerthashes: [] }\n    }).subarray();\n}\nexport async function signPayload(peerId, payload) {\n    if (peerId.privateKey == null) {\n        throw new Error('PrivateKey was missing from PeerId');\n    }\n    const privateKey = await unmarshalPrivateKey(peerId.privateKey);\n    return await privateKey.sign(payload);\n}\nexport async function getPeerIdFromPayload(payload) {\n    return await peerIdFromKeys(payload.identityKey);\n}\nexport function decodePayload(payload) {\n    return NoiseHandshakePayload.decode(payload);\n}\nexport function getHandshakePayload(publicKey) {\n    const prefix = uint8ArrayFromString('noise-libp2p-static-key:');\n    return uint8ArrayConcat([prefix, publicKey], prefix.length + publicKey.length);\n}\n/**\n * Verifies signed payload, throws on any irregularities.\n *\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\nexport async function verifySignedPayload(noiseStaticKey, payload, remotePeer) {\n    // Unmarshaling from PublicKey protobuf\n    const payloadPeerId = await peerIdFromKeys(payload.identityKey);\n    if (!payloadPeerId.equals(remotePeer)) {\n        throw new Error(\"Peer ID doesn't match libp2p public key.\");\n    }\n    const generatedPayload = getHandshakePayload(noiseStaticKey);\n    if (payloadPeerId.publicKey == null) {\n        throw new Error('PublicKey was missing from PeerId');\n    }\n    if (payload.identitySig == null) {\n        throw new Error('Signature was missing from message');\n    }\n    const publicKey = unmarshalPublicKey(payloadPeerId.publicKey);\n    const valid = await publicKey.verify(generatedPayload, payload.identitySig);\n    if (!valid) {\n        throw new Error(\"Static key doesn't match to peer that signed payload!\");\n    }\n    return payloadPeerId;\n}\nexport function isValidPublicKey(pk) {\n    if (!(pk instanceof Uint8Array)) {\n        return false;\n    }\n    if (pk.length !== 32) {\n        return false;\n    }\n    return true;\n}\n//# sourceMappingURL=utils.js.map","import { logger } from '@libp2p/logger';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { DUMP_SESSION_KEYS } from './constants.js';\nconst log = logger('libp2p:noise');\nexport { log as logger };\nlet keyLogger;\nif (DUMP_SESSION_KEYS) {\n    keyLogger = log;\n}\nelse {\n    keyLogger = Object.assign(() => { }, {\n        enabled: false,\n        trace: () => { },\n        error: () => { }\n    });\n}\nexport function logLocalStaticKeys(s) {\n    keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${uint8ArrayToString(s.publicKey, 'hex')}`);\n    keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${uint8ArrayToString(s.privateKey, 'hex')}`);\n}\nexport function logLocalEphemeralKeys(e) {\n    if (e) {\n        keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${uint8ArrayToString(e.publicKey, 'hex')}`);\n        keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${uint8ArrayToString(e.privateKey, 'hex')}`);\n    }\n    else {\n        keyLogger('Missing local ephemeral keys.');\n    }\n}\nexport function logRemoteStaticKey(rs) {\n    keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${uint8ArrayToString(rs, 'hex')}`);\n}\nexport function logRemoteEphemeralKey(re) {\n    keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${uint8ArrayToString(re, 'hex')}`);\n}\nexport function logCipherState(session) {\n    if (session.cs1 && session.cs2) {\n        keyLogger(`CIPHER_STATE_1 ${session.cs1.n.getUint64()} ${uint8ArrayToString(session.cs1.k, 'hex')}`);\n        keyLogger(`CIPHER_STATE_2 ${session.cs2.n.getUint64()} ${uint8ArrayToString(session.cs2.k, 'hex')}`);\n    }\n    else {\n        keyLogger('Missing cipher state.');\n    }\n}\n//# sourceMappingURL=logger.js.map","export const MIN_NONCE = 0;\n// For performance reasons, the nonce is represented as a JS `number`\n// Although JS `number` can safely represent integers up to 2 ** 53 - 1, we choose to only use\n// 4 bytes to store the data for performance reason.\n// This is a slight deviation from the noise spec, which describes the max nonce as 2 ** 64 - 2\n// The effect is that this implementation will need a new handshake to be performed after fewer messages are exchanged than other implementations with full uint64 nonces.\n// this MAX_NONCE is still a large number of messages, so the practical effect of this is negligible.\nexport const MAX_NONCE = 0xffffffff;\nconst ERR_MAX_NONCE = 'Cipherstate has reached maximum n, a new handshake must be performed';\n/**\n * The nonce is an uint that's increased over time.\n * Maintaining different representations help improve performance.\n */\nexport class Nonce {\n    constructor(n = MIN_NONCE) {\n        this.n = n;\n        this.bytes = new Uint8Array(12);\n        this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);\n        this.view.setUint32(4, n, true);\n    }\n    increment() {\n        this.n++;\n        // Even though we're treating the nonce as 8 bytes, RFC7539 specifies 12 bytes for a nonce.\n        this.view.setUint32(4, this.n, true);\n    }\n    getBytes() {\n        return this.bytes;\n    }\n    getUint64() {\n        return this.n;\n    }\n    assertValue() {\n        if (this.n > MAX_NONCE) {\n            throw new Error(ERR_MAX_NONCE);\n        }\n    }\n}\n//# sourceMappingURL=nonce.js.map","import { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays';\nimport { logger } from '../logger.js';\nimport { Nonce } from '../nonce.js';\nexport class AbstractHandshake {\n    constructor(crypto) {\n        this.crypto = crypto;\n    }\n    encryptWithAd(cs, ad, plaintext) {\n        const e = this.encrypt(cs.k, cs.n, ad, plaintext);\n        cs.n.increment();\n        return e;\n    }\n    decryptWithAd(cs, ad, ciphertext, dst) {\n        const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext, dst);\n        if (valid)\n            cs.n.increment();\n        return { plaintext, valid };\n    }\n    // Cipher state related\n    hasKey(cs) {\n        return !this.isEmptyKey(cs.k);\n    }\n    createEmptyKey() {\n        return new Uint8Array(32);\n    }\n    isEmptyKey(k) {\n        const emptyKey = this.createEmptyKey();\n        return uint8ArrayEquals(emptyKey, k);\n    }\n    encrypt(k, n, ad, plaintext) {\n        n.assertValue();\n        return this.crypto.chaCha20Poly1305Encrypt(plaintext, n.getBytes(), ad, k);\n    }\n    encryptAndHash(ss, plaintext) {\n        let ciphertext;\n        if (this.hasKey(ss.cs)) {\n            ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);\n        }\n        else {\n            ciphertext = plaintext;\n        }\n        this.mixHash(ss, ciphertext);\n        return ciphertext;\n    }\n    decrypt(k, n, ad, ciphertext, dst) {\n        n.assertValue();\n        const encryptedMessage = this.crypto.chaCha20Poly1305Decrypt(ciphertext, n.getBytes(), ad, k, dst);\n        if (encryptedMessage) {\n            return {\n                plaintext: encryptedMessage,\n                valid: true\n            };\n        }\n        else {\n            return {\n                plaintext: new Uint8Array(0),\n                valid: false\n            };\n        }\n    }\n    decryptAndHash(ss, ciphertext) {\n        let plaintext;\n        let valid = true;\n        if (this.hasKey(ss.cs)) {\n            ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext));\n        }\n        else {\n            plaintext = ciphertext;\n        }\n        this.mixHash(ss, ciphertext);\n        return { plaintext, valid };\n    }\n    dh(privateKey, publicKey) {\n        try {\n            const derivedU8 = this.crypto.generateX25519SharedKey(privateKey, publicKey);\n            if (derivedU8.length === 32) {\n                return derivedU8;\n            }\n            return derivedU8.subarray(0, 32);\n        }\n        catch (e) {\n            const err = e;\n            logger(err.message);\n            return new Uint8Array(32);\n        }\n    }\n    mixHash(ss, data) {\n        ss.h = this.getHash(ss.h, data);\n    }\n    getHash(a, b) {\n        const u = this.crypto.hashSHA256(uint8ArrayConcat([a, b], a.length + b.length));\n        return u;\n    }\n    mixKey(ss, ikm) {\n        const [ck, tempK] = this.crypto.getHKDF(ss.ck, ikm);\n        ss.cs = this.initializeKey(tempK);\n        ss.ck = ck;\n    }\n    initializeKey(k) {\n        return { k, n: new Nonce() };\n    }\n    // Symmetric state related\n    initializeSymmetric(protocolName) {\n        const protocolNameBytes = uint8ArrayFromString(protocolName, 'utf-8');\n        const h = this.hashProtocolName(protocolNameBytes);\n        const ck = h;\n        const key = this.createEmptyKey();\n        const cs = this.initializeKey(key);\n        return { cs, ck, h };\n    }\n    hashProtocolName(protocolName) {\n        if (protocolName.length <= 32) {\n            const h = new Uint8Array(32);\n            h.set(protocolName);\n            return h;\n        }\n        else {\n            return this.getHash(protocolName, new Uint8Array(0));\n        }\n    }\n    split(ss) {\n        const [tempk1, tempk2] = this.crypto.getHKDF(ss.ck, new Uint8Array(0));\n        const cs1 = this.initializeKey(tempk1);\n        const cs2 = this.initializeKey(tempk2);\n        return { cs1, cs2 };\n    }\n    writeMessageRegular(cs, payload) {\n        const ciphertext = this.encryptWithAd(cs, new Uint8Array(0), payload);\n        const ne = this.createEmptyKey();\n        const ns = new Uint8Array(0);\n        return { ne, ns, ciphertext };\n    }\n    readMessageRegular(cs, message) {\n        return this.decryptWithAd(cs, new Uint8Array(0), message.ciphertext);\n    }\n}\n//# sourceMappingURL=abstract-handshake.js.map","import { isValidPublicKey } from '../utils.js';\nimport { AbstractHandshake } from './abstract-handshake.js';\nexport class XX extends AbstractHandshake {\n    initializeInitiator(prologue, s, rs, psk) {\n        const name = 'Noise_XX_25519_ChaChaPoly_SHA256';\n        const ss = this.initializeSymmetric(name);\n        this.mixHash(ss, prologue);\n        const re = new Uint8Array(32);\n        return { ss, s, rs, psk, re };\n    }\n    initializeResponder(prologue, s, rs, psk) {\n        const name = 'Noise_XX_25519_ChaChaPoly_SHA256';\n        const ss = this.initializeSymmetric(name);\n        this.mixHash(ss, prologue);\n        const re = new Uint8Array(32);\n        return { ss, s, rs, psk, re };\n    }\n    writeMessageA(hs, payload, e) {\n        const ns = new Uint8Array(0);\n        if (e !== undefined) {\n            hs.e = e;\n        }\n        else {\n            hs.e = this.crypto.generateX25519KeyPair();\n        }\n        const ne = hs.e.publicKey;\n        this.mixHash(hs.ss, ne);\n        const ciphertext = this.encryptAndHash(hs.ss, payload);\n        return { ne, ns, ciphertext };\n    }\n    writeMessageB(hs, payload) {\n        hs.e = this.crypto.generateX25519KeyPair();\n        const ne = hs.e.publicKey;\n        this.mixHash(hs.ss, ne);\n        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n        const spk = hs.s.publicKey;\n        const ns = this.encryptAndHash(hs.ss, spk);\n        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n        const ciphertext = this.encryptAndHash(hs.ss, payload);\n        return { ne, ns, ciphertext };\n    }\n    writeMessageC(hs, payload) {\n        const spk = hs.s.publicKey;\n        const ns = this.encryptAndHash(hs.ss, spk);\n        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n        const ciphertext = this.encryptAndHash(hs.ss, payload);\n        const ne = this.createEmptyKey();\n        const messageBuffer = { ne, ns, ciphertext };\n        const { cs1, cs2 } = this.split(hs.ss);\n        return { h: hs.ss.h, messageBuffer, cs1, cs2 };\n    }\n    readMessageA(hs, message) {\n        if (isValidPublicKey(message.ne)) {\n            hs.re = message.ne;\n        }\n        this.mixHash(hs.ss, hs.re);\n        return this.decryptAndHash(hs.ss, message.ciphertext);\n    }\n    readMessageB(hs, message) {\n        if (isValidPublicKey(message.ne)) {\n            hs.re = message.ne;\n        }\n        this.mixHash(hs.ss, hs.re);\n        if (!hs.e) {\n            throw new Error('Handshake state `e` param is missing.');\n        }\n        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n        const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message.ns);\n        if (valid1 && isValidPublicKey(ns)) {\n            hs.rs = ns;\n        }\n        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n        const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message.ciphertext);\n        return { plaintext, valid: (valid1 && valid2) };\n    }\n    readMessageC(hs, message) {\n        const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message.ns);\n        if (valid1 && isValidPublicKey(ns)) {\n            hs.rs = ns;\n        }\n        if (!hs.e) {\n            throw new Error('Handshake state `e` param is missing.');\n        }\n        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n        const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message.ciphertext);\n        const { cs1, cs2 } = this.split(hs.ss);\n        return { h: hs.ss.h, plaintext, valid: (valid1 && valid2), cs1, cs2 };\n    }\n    initSession(initiator, prologue, s) {\n        const psk = this.createEmptyKey();\n        const rs = new Uint8Array(32); // no static key yet\n        let hs;\n        if (initiator) {\n            hs = this.initializeInitiator(prologue, s, rs, psk);\n        }\n        else {\n            hs = this.initializeResponder(prologue, s, rs, psk);\n        }\n        return {\n            hs,\n            i: initiator,\n            mc: 0\n        };\n    }\n    sendMessage(session, message, ephemeral) {\n        let messageBuffer;\n        if (session.mc === 0) {\n            messageBuffer = this.writeMessageA(session.hs, message, ephemeral);\n        }\n        else if (session.mc === 1) {\n            messageBuffer = this.writeMessageB(session.hs, message);\n        }\n        else if (session.mc === 2) {\n            const { h, messageBuffer: resultingBuffer, cs1, cs2 } = this.writeMessageC(session.hs, message);\n            messageBuffer = resultingBuffer;\n            session.h = h;\n            session.cs1 = cs1;\n            session.cs2 = cs2;\n        }\n        else if (session.mc > 2) {\n            if (session.i) {\n                if (!session.cs1) {\n                    throw new Error('CS1 (cipher state) is not defined');\n                }\n                messageBuffer = this.writeMessageRegular(session.cs1, message);\n            }\n            else {\n                if (!session.cs2) {\n                    throw new Error('CS2 (cipher state) is not defined');\n                }\n                messageBuffer = this.writeMessageRegular(session.cs2, message);\n            }\n        }\n        else {\n            throw new Error('Session invalid.');\n        }\n        session.mc++;\n        return messageBuffer;\n    }\n    recvMessage(session, message) {\n        let plaintext = new Uint8Array(0);\n        let valid = false;\n        if (session.mc === 0) {\n            ({ plaintext, valid } = this.readMessageA(session.hs, message));\n        }\n        else if (session.mc === 1) {\n            ({ plaintext, valid } = this.readMessageB(session.hs, message));\n        }\n        else if (session.mc === 2) {\n            const { h, plaintext: resultingPlaintext, valid: resultingValid, cs1, cs2 } = this.readMessageC(session.hs, message);\n            plaintext = resultingPlaintext;\n            valid = resultingValid;\n            session.h = h;\n            session.cs1 = cs1;\n            session.cs2 = cs2;\n        }\n        session.mc++;\n        return { plaintext, valid };\n    }\n}\n//# sourceMappingURL=xx.js.map","import { InvalidCryptoExchangeError, UnexpectedPeerError } from '@libp2p/interface-connection-encrypter/errors';\nimport { decode0, decode1, decode2, encode0, encode1, encode2 } from './encoder.js';\nimport { XX } from './handshakes/xx.js';\nimport { logger, logLocalStaticKeys, logLocalEphemeralKeys, logRemoteEphemeralKey, logRemoteStaticKey, logCipherState } from './logger.js';\nimport { decodePayload, getPeerIdFromPayload, verifySignedPayload } from './utils.js';\nexport class XXHandshake {\n    constructor(isInitiator, payload, prologue, crypto, staticKeypair, connection, remotePeer, handshake) {\n        this.remoteExtensions = { webtransportCerthashes: [] };\n        this.isInitiator = isInitiator;\n        this.payload = payload;\n        this.prologue = prologue;\n        this.staticKeypair = staticKeypair;\n        this.connection = connection;\n        if (remotePeer) {\n            this.remotePeer = remotePeer;\n        }\n        this.xx = handshake ?? new XX(crypto);\n        this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);\n    }\n    // stage 0\n    async propose() {\n        logLocalStaticKeys(this.session.hs.s);\n        if (this.isInitiator) {\n            logger('Stage 0 - Initiator starting to send first message.');\n            const messageBuffer = this.xx.sendMessage(this.session, new Uint8Array(0));\n            this.connection.writeLP(encode0(messageBuffer));\n            logger('Stage 0 - Initiator finished sending first message.');\n            logLocalEphemeralKeys(this.session.hs.e);\n        }\n        else {\n            logger('Stage 0 - Responder waiting to receive first message...');\n            const receivedMessageBuffer = decode0((await this.connection.readLP()).subarray());\n            const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n            if (!valid) {\n                throw new InvalidCryptoExchangeError('xx handshake stage 0 validation fail');\n            }\n            logger('Stage 0 - Responder received first message.');\n            logRemoteEphemeralKey(this.session.hs.re);\n        }\n    }\n    // stage 1\n    async exchange() {\n        if (this.isInitiator) {\n            logger('Stage 1 - Initiator waiting to receive first message from responder...');\n            const receivedMessageBuffer = decode1((await this.connection.readLP()).subarray());\n            const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n            if (!valid) {\n                throw new InvalidCryptoExchangeError('xx handshake stage 1 validation fail');\n            }\n            logger('Stage 1 - Initiator received the message.');\n            logRemoteEphemeralKey(this.session.hs.re);\n            logRemoteStaticKey(this.session.hs.rs);\n            logger(\"Initiator going to check remote's signature...\");\n            try {\n                const decodedPayload = decodePayload(plaintext);\n                this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);\n                await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n                this.setRemoteNoiseExtension(decodedPayload.extensions);\n            }\n            catch (e) {\n                const err = e;\n                throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err.message}`);\n            }\n            logger('All good with the signature!');\n        }\n        else {\n            logger('Stage 1 - Responder sending out first message with signed payload and static key.');\n            const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n            this.connection.writeLP(encode1(messageBuffer));\n            logger('Stage 1 - Responder sent the second handshake message with signed payload.');\n            logLocalEphemeralKeys(this.session.hs.e);\n        }\n    }\n    // stage 2\n    async finish() {\n        if (this.isInitiator) {\n            logger('Stage 2 - Initiator sending third handshake message.');\n            const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n            this.connection.writeLP(encode2(messageBuffer));\n            logger('Stage 2 - Initiator sent message with signed payload.');\n        }\n        else {\n            logger('Stage 2 - Responder waiting for third handshake message...');\n            const receivedMessageBuffer = decode2((await this.connection.readLP()).subarray());\n            const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n            if (!valid) {\n                throw new InvalidCryptoExchangeError('xx handshake stage 2 validation fail');\n            }\n            logger('Stage 2 - Responder received the message, finished handshake.');\n            try {\n                const decodedPayload = decodePayload(plaintext);\n                this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);\n                await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n                this.setRemoteNoiseExtension(decodedPayload.extensions);\n            }\n            catch (e) {\n                const err = e;\n                throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err.message}`);\n            }\n        }\n        logCipherState(this.session);\n    }\n    encrypt(plaintext, session) {\n        const cs = this.getCS(session);\n        return this.xx.encryptWithAd(cs, new Uint8Array(0), plaintext);\n    }\n    decrypt(ciphertext, session, dst) {\n        const cs = this.getCS(session, false);\n        return this.xx.decryptWithAd(cs, new Uint8Array(0), ciphertext, dst);\n    }\n    getRemoteStaticKey() {\n        return this.session.hs.rs;\n    }\n    getCS(session, encryption = true) {\n        if (!session.cs1 || !session.cs2) {\n            throw new InvalidCryptoExchangeError('Handshake not completed properly, cipher state does not exist.');\n        }\n        if (this.isInitiator) {\n            return encryption ? session.cs1 : session.cs2;\n        }\n        else {\n            return encryption ? session.cs2 : session.cs1;\n        }\n    }\n    setRemoteNoiseExtension(e) {\n        if (e) {\n            this.remoteExtensions = e;\n        }\n    }\n}\n//# sourceMappingURL=handshake-xx.js.map","export function registerMetrics(metrics) {\n    return {\n        xxHandshakeSuccesses: metrics.registerCounter('libp2p_noise_xxhandshake_successes_total', {\n            help: 'Total count of noise xxHandshakes successes_'\n        }),\n        xxHandshakeErrors: metrics.registerCounter('libp2p_noise_xxhandshake_error_total', {\n            help: 'Total count of noise xxHandshakes errors'\n        }),\n        encryptedPackets: metrics.registerCounter('libp2p_noise_encrypted_packets_total', {\n            help: 'Total count of noise encrypted packets successfully'\n        }),\n        decryptedPackets: metrics.registerCounter('libp2p_noise_decrypted_packets_total', {\n            help: 'Total count of noise decrypted packets'\n        }),\n        decryptErrors: metrics.registerCounter('libp2p_noise_decrypt_errors_total', {\n            help: 'Total count of noise decrypt errors'\n        })\n    };\n}\n//# sourceMappingURL=metrics.js.map","import { pbStream } from 'it-pb-stream';\nimport { duplexPair } from 'it-pair/duplex';\nimport { pipe } from 'it-pipe';\nimport { decode } from 'it-length-prefixed';\nimport { NOISE_MSG_MAX_LENGTH_BYTES } from './constants.js';\nimport { stablelib } from './crypto/stablelib.js';\nimport { decryptStream, encryptStream } from './crypto/streaming.js';\nimport { uint16BEDecode, uint16BEEncode } from './encoder.js';\nimport { XXHandshake } from './handshake-xx.js';\nimport { getPayload } from './utils.js';\nimport { registerMetrics } from './metrics.js';\nexport class Noise {\n    constructor(init = {}) {\n        this.protocol = '/noise';\n        const { staticNoiseKey, extensions, crypto, prologueBytes, metrics } = init;\n        this.crypto = crypto ?? stablelib;\n        this.extensions = extensions;\n        this.metrics = metrics ? registerMetrics(metrics) : undefined;\n        if (staticNoiseKey) {\n            // accepts x25519 private key of length 32\n            this.staticKeys = this.crypto.generateX25519KeyPairFromSeed(staticNoiseKey);\n        }\n        else {\n            this.staticKeys = this.crypto.generateX25519KeyPair();\n        }\n        this.prologue = prologueBytes ?? new Uint8Array(0);\n    }\n    /**\n     * Encrypt outgoing data to the remote party (handshake as initiator)\n     *\n     * @param {PeerId} localPeer - PeerId of the receiving peer\n     * @param {Duplex<Uint8Array>} connection - streaming iterable duplex that will be encrypted\n     * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n     * @returns {Promise<SecuredConnection>}\n     */\n    async secureOutbound(localPeer, connection, remotePeer) {\n        const wrappedConnection = pbStream(connection, {\n            lengthEncoder: uint16BEEncode,\n            lengthDecoder: uint16BEDecode,\n            maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n        });\n        const handshake = await this.performHandshake({\n            connection: wrappedConnection,\n            isInitiator: true,\n            localPeer,\n            remotePeer\n        });\n        const conn = await this.createSecureConnection(wrappedConnection, handshake);\n        return {\n            conn,\n            remoteExtensions: handshake.remoteExtensions,\n            remotePeer: handshake.remotePeer\n        };\n    }\n    /**\n     * Decrypt incoming data (handshake as responder).\n     *\n     * @param {PeerId} localPeer - PeerId of the receiving peer.\n     * @param {Duplex<Uint8Array>} connection - streaming iterable duplex that will be encryption.\n     * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n     * @returns {Promise<SecuredConnection>}\n     */\n    async secureInbound(localPeer, connection, remotePeer) {\n        const wrappedConnection = pbStream(connection, {\n            lengthEncoder: uint16BEEncode,\n            lengthDecoder: uint16BEDecode,\n            maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n        });\n        const handshake = await this.performHandshake({\n            connection: wrappedConnection,\n            isInitiator: false,\n            localPeer,\n            remotePeer\n        });\n        const conn = await this.createSecureConnection(wrappedConnection, handshake);\n        return {\n            conn,\n            remotePeer: handshake.remotePeer,\n            remoteExtensions: handshake.remoteExtensions\n        };\n    }\n    /**\n     * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n     * If noise pipes disabled or remote peer static key is unknown, use XX.\n     *\n     * @param {HandshakeParams} params\n     */\n    async performHandshake(params) {\n        const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.extensions);\n        // run XX handshake\n        return await this.performXXHandshake(params, payload);\n    }\n    async performXXHandshake(params, payload) {\n        const { isInitiator, remotePeer, connection } = params;\n        const handshake = new XXHandshake(isInitiator, payload, this.prologue, this.crypto, this.staticKeys, connection, remotePeer);\n        try {\n            await handshake.propose();\n            await handshake.exchange();\n            await handshake.finish();\n            this.metrics?.xxHandshakeSuccesses.increment();\n        }\n        catch (e) {\n            this.metrics?.xxHandshakeErrors.increment();\n            if (e instanceof Error) {\n                e.message = `Error occurred during XX handshake: ${e.message}`;\n                throw e;\n            }\n        }\n        return handshake;\n    }\n    async createSecureConnection(connection, handshake) {\n        // Create encryption box/unbox wrapper\n        const [secure, user] = duplexPair();\n        const network = connection.unwrap();\n        await pipe(secure, // write to wrapper\n        encryptStream(handshake, this.metrics), // encrypt data + prefix with message length\n        network, // send to the remote peer\n        decode({ lengthDecoder: uint16BEDecode }), // read message length prefix\n        decryptStream(handshake, this.metrics), // decrypt the incoming data\n        secure // pipe to the wrapper\n        );\n        return user;\n    }\n}\n//# sourceMappingURL=noise.js.map","import { Noise } from './noise.js';\nexport * from './crypto.js';\nexport * from './crypto/stablelib.js';\nexport function noise(init = {}) {\n    return () => new Noise(init);\n}\n//# sourceMappingURL=index.js.map","import { isBrowser, isElectronRenderer, isElectronMain, isNode, } from \"wherearewe\";\nimport { createController } from \"ipfsd-ctl\";\nimport wrtc from \"wrtc\";\nimport { noise } from \"@chainsafe/libp2p-noise\";\nconst configNavigateur = import(\"./configNavigateur.js\");\n// const configÉlectron = import(\"./configÉlectron.js\");\nconst configNode = import(\"./configNode.js\");\nconst obtConfigPlateforme = async () => {\n    if (isBrowser || isElectronRenderer) {\n        return (await configNavigateur).default;\n    }\n    else if (isElectronMain) {\n        return {}; // await (await configÉlectron).default();\n    }\n    else if (isNode) {\n        return (await configNode).default();\n    }\n    else {\n        throw new Error(\"Environnement non supporté\");\n    }\n};\n// https://github.com/libp2p/js-libp2p-webrtc-direct/issues/98\nconst obtConfigCommun = () => {\n    return {\n        libp2p: {\n            modules: {},\n            connectionManager: {\n                autoDial: false,\n            },\n            config: {\n                peerDiscovery: {\n                    webRTCStar: {\n                        // <- note the lower-case w - see https://github.com/libp2p/js-libp2p/issues/576\n                        enabled: true,\n                    },\n                },\n                transport: {\n                    WebRTCStar: {\n                        // <- note the upper-case w- see https://github.com/libp2p/js-libp2p/issues/576\n                        wrtc,\n                        connEncryption: [noise],\n                    },\n                },\n            },\n            transportManager: { faultTolerance: 1 },\n        },\n        relay: { enabled: true, hop: { enabled: true, active: true } },\n        config: {\n            Addresses: {\n                Swarm: [\n                    // https://suda.pl/free-webrtc-star-heroku/\n                    \"/dns4/arcane-springs-02799.herokuapp.com/tcp/443/wss/p2p-webrtc-star/\",\n                    // https://github.com/LucaPanofsky/ipfs-wss-heroku-node\n                    \"/dns4/p2p-circuit-constellation.herokuapp.com/tcp/443/wss/p2p/QmY8XpuX6VnaUVDz4uA14vpjv3CZYLif3wLPqCkgU2KLSB\",\n                ],\n            },\n        },\n    };\n};\nexport default async function initSFIP(dir = \"./constl/sfip\") {\n    const controllerConfig = {\n        type: \"proc\",\n        disposable: false,\n        test: false,\n        ipfsModule: await import(\"ipfs\"),\n    };\n    const config = obtConfigCommun();\n    const configPlateforme = await obtConfigPlateforme();\n    config.libp2p.modules = configPlateforme;\n    config.repo = dir;\n    controllerConfig.ipfsOptions = config;\n    // Spawn an IPFS daemon (type defined in)\n    const ipfsd = await createController(controllerConfig);\n    await ipfsd.init();\n    await ipfsd.start();\n    return ipfsd.api;\n}\n//# sourceMappingURL=index.js.map"],"names":["createController","options","DefaultFactory","browser","symbol","findBufAndOffset","bufs","index","offset","buf","bufEnd","isUint8ArrayList","value","Uint8ArrayList","data","length","res","i","bytes","beginInclusive","endExclusive","concat","list","bufStart","sliceStartInBuf","sliceEndsInBuf","start","search","needle","M","radix","rightmostPositions","c","j","right","lastIndex","lastPatIndex","skip","char","byteOffset","allocUnsafe","littleEndian","alloc","other","equals","acc","curr","reader","source","bl","chunk","FixedFIFO","hwm","last","FIFO","obj","val","prev","next","pushable","_pushable","buffer","pushableV","values","getNext","onEnd","onNext","ended","waitNext","resolve","reject","err","bufferNext","bufferError","push","end","_return","_throw","pDefer","deferred","handshake","stream","writer","sourcePromise","defer","sinkErr","sinkPromise","accessor","TWO_32","LongBits","hi","lo","unsigned","mask","access","negative","sign","bits","N1","N2","N3","N4","N5","N6","N7","N8","N9","len","defaultEncoder","lengthLength","lengthBuf","encode","encodeLength","MAX_LENGTH_LENGTH","MAX_DATA_LENGTH","ReadMode","defaultDecoder","decode","mode","dataLength","lengthDecoder","maxLengthLength","maxDataLength","errCode","dataLengthLength","byteLength","varByteSource","done","l","pbStream","duplex","opts","shake","lpReader","lp.decode","W","proto","lp.encode","d","pair","piped","duplexPair","a","b","merge","sources","output","item","rawPipe","fns","isIterable","isDuplex","duplexPipelineFn","p","pipe","first","rest","NOISE_MSG_MAX_LENGTH_BYTES","NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG","DUMP_SESSION_KEYS","hash","isSerializableHash","h","hmac_1","hash_1","require$$0","constant_time_1","require$$1","wipe_1","require$$2","HMAC","key","pad","out","savedState","hmac","digest","hkdf","HKDF","salt","info","okm","ctr","HKDF_1","stablelib","ck","ikm","SHA256","k1","k2","k3","keypair","x25519.generateKeyPair","seed","x25519.generateKeyPairFromSeed","privateKey","publicKey","x25519.sharedKey","plaintext","nonce","ad","k","ChaCha20Poly1305","ciphertext","dst","uint16BEEncode","target","uint16BEDecode","encode0","message","uint8ArrayConcat","encode1","encode2","decode0","input","decode1","decode2","encryptStream","metrics","decryptStream","TAG_LENGTH","encrypted","decrypted","valid","UnexpectedPeerError","InvalidCryptoExchangeError","encode_1","MSB","REST","MSBALL","INT","num","oldOffset","read","MSB$1","REST$1","shift","counter","varint","_brrp_varint","encodeTo","int","encodingLength","aa","bb","ii","coerce","o","fromString","str","toString","create","code","size","sizeOffset","varint.encodingLength","digestOffset","varint.encodeTo","Digest","multihash","varint.decode","equalBytes","base","ALPHABET","name","BASE_MAP","x","xc","BASE","LEADER","FACTOR","iFACTOR","zeroes","pbegin","pend","b58","carry","it1","it2","decodeUnsafe","psz","b256","it3","it4","vch","string","src","_brrp__multiformats_scope_baseX","Encoder","prefix","baseEncode","Decoder","baseDecode","text","decoder","or","ComposedDecoder","decoders","left","Codec","from","baseX","alphabet","basex","bitsPerChar","codes","written","rfc4648","base58btc","base58flickr","base32","base32upper","base32pad","base32padupper","base32hex","base32hexupper","base32hexpad","base32hexpadupper","base32z","format","link","version","toStringV0","baseCache","toStringV1","cache","cid","CID","DAG_PB_CODE","SHA_256_CODE","Digest.create","self","unknown","Digest.equals","encodeCID","cidSymbol","Digest.decode","remainder","specs","prefixSize","multihashBytes","digestBytes","Digest.Digest","initialBytes","codec","multihashCode","digestSize","multihashSize","parseCIDtoBytes","codeOffset","hashOffset","identity","base2","base8","base10","base16","base16upper","base36","base36upper","base64","base64pad","base64url","base64urlpad","alphabetBytesToChars","alphabetCharsToBytes","byts","byt","base256emoji","Hasher","result","sha","sha256","bases","identityBase","base58","isPeerId","inspect","baseDecoder","LIBP2P_KEY_CODE","MARSHALLED_ED225519_PUBLIC_KEY_LENGTH","MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH","PeerIdImpl","init","id","uint8ArrayEquals","peerIdFromString","RSAPeerIdImpl","Ed25519PeerIdImpl","Secp256k1PeerIdImpl","peerIdFromPeerId","errcode","peerIdFromBytes","peerIdFromCID","peerIdFromKeys","NoiseExtensions","_codec","w","tag","encodeMessage","decodeMessage","NoiseHandshakePayload","getPayload","localPeer","staticPublicKey","extensions","signedPayload","signPayload","getHandshakePayload","createHandshakePayload","libp2pPublicKey","peerId","payload","unmarshalPrivateKey","getPeerIdFromPayload","decodePayload","uint8ArrayFromString","verifySignedPayload","noiseStaticKey","remotePeer","payloadPeerId","generatedPayload","unmarshalPublicKey","isValidPublicKey","pk","log","logger","keyLogger","logLocalStaticKeys","s","uint8ArrayToString","logLocalEphemeralKeys","e","logRemoteStaticKey","rs","logRemoteEphemeralKey","re","logCipherState","session","MIN_NONCE","MAX_NONCE","ERR_MAX_NONCE","Nonce","n","AbstractHandshake","crypto","cs","emptyKey","ss","encryptedMessage","derivedU8","tempK","protocolName","protocolNameBytes","tempk1","tempk2","cs1","cs2","ne","ns","XX","prologue","psk","hs","spk","messageBuffer","valid1","valid2","initiator","ephemeral","resultingBuffer","resultingPlaintext","resultingValid","XXHandshake","isInitiator","staticKeypair","connection","receivedMessageBuffer","decodedPayload","encryption","registerMetrics","Noise","staticNoiseKey","prologueBytes","wrappedConnection","params","secure","user","network","noise","configNavigateur","__vitePreload","configNode","obtConfigPlateforme","isBrowser","isElectronRenderer","isElectronMain","isNode","obtConfigCommun","wrtc","initSFIP","dir","controllerConfig","config","configPlateforme","ipfsd"],"mappings":"6NAeO,MAAMA,GAAmB,MAAOC,GAE5B,MADG,IAAIC,KACC,MAAMD,CAAO,WCfhCE,EAAA,YAAsB,OAAO,YAC7BA,EAAA,iBAA2B,OAAO,iBAClCA,EAAA,eAAyB,OAAO,eAChCA,EAAA,oBAA8B,OAAO,oBACrCA,EAAA,iBAA2B,OAAO,iBAClCA,EAAA,gBAA0B,OAAO,gBACjCA,EAAA,gBAA0B,OAAO,gBACjCA,EAAA,kBAA4B,OAAO,kBACnCA,EAAA,0BAAoC,OAAO,0BAC3CA,EAAA,eAAyB,OAAO,eAChCA,EAAA,aAAuB,OAAO,aAC9BA,EAAA,kBAA4B,OAAO,kBACnCA,EAAA,iBAA2B,OAAO,iBAClCA,EAAA,sBAAgC,OAAO,sBACvCA,EAAA,aAAuB,OAAO,aACVA,EAAA,aAAG,UAAU,aCdjC,MAAMC,GAAS,OAAO,IAAI,6BAA6B,EACvD,SAASC,GAAiBC,EAAMC,EAAO,CACnC,GAAIA,GAAS,MAAQA,EAAQ,EACzB,MAAM,IAAI,WAAW,wBAAwB,EAEjD,IAAIC,EAAS,EACb,UAAWC,KAAOH,EAAM,CACpB,MAAMI,EAASF,EAASC,EAAI,WAC5B,GAAIF,EAAQG,EACR,MAAO,CACH,IAAAD,EACA,MAAOF,EAAQC,CAC/B,EAEQA,EAASE,CACZ,CACD,MAAM,IAAI,WAAW,wBAAwB,CACjD,CAcO,SAASC,EAAiBC,EAAO,CACpC,OAAO,QAAQA,IAAQR,EAAM,CAAC,CAClC,CACO,MAAMS,CAAe,CACxB,eAAeC,EAAM,CAEjB,OAAO,eAAe,KAAMV,GAAQ,CAAE,MAAO,EAAI,CAAE,EACnD,KAAK,KAAO,GACZ,KAAK,OAAS,EACVU,EAAK,OAAS,GACd,KAAK,UAAUA,CAAI,CAE1B,CACD,EAAE,OAAO,QAAQ,GAAI,CACjB,MAAO,KAAK,IACf,CACD,IAAI,YAAa,CACb,OAAO,KAAK,MACf,CAID,UAAUR,EAAM,CACZ,KAAK,UAAUA,CAAI,CACtB,CAID,UAAUA,EAAM,CACZ,IAAIS,EAAS,EACb,UAAWN,KAAOH,EACd,GAAIG,aAAe,WACfM,GAAUN,EAAI,WACd,KAAK,KAAK,KAAKA,CAAG,UAEbE,EAAiBF,CAAG,EACzBM,GAAUN,EAAI,WACd,KAAK,KAAK,KAAK,GAAGA,EAAI,IAAI,MAG1B,OAAM,IAAI,MAAM,mEAAmE,EAG3F,KAAK,QAAUM,CAClB,CAID,WAAWT,EAAM,CACb,KAAK,WAAWA,CAAI,CACvB,CAID,WAAWA,EAAM,CACb,IAAIS,EAAS,EACb,UAAWN,KAAOH,EAAK,UACnB,GAAIG,aAAe,WACfM,GAAUN,EAAI,WACd,KAAK,KAAK,QAAQA,CAAG,UAEhBE,EAAiBF,CAAG,EACzBM,GAAUN,EAAI,WACd,KAAK,KAAK,QAAQ,GAAGA,EAAI,IAAI,MAG7B,OAAM,IAAI,MAAM,oEAAoE,EAG5F,KAAK,QAAUM,CAClB,CAID,IAAIR,EAAO,CACP,MAAMS,EAAMX,GAAiB,KAAK,KAAME,CAAK,EAC7C,OAAOS,EAAI,IAAIA,EAAI,KAAK,CAC3B,CAID,IAAIT,EAAOK,EAAO,CACd,MAAMI,EAAMX,GAAiB,KAAK,KAAME,CAAK,EAC7CS,EAAI,IAAIA,EAAI,KAAK,EAAIJ,CACxB,CAID,MAAMH,EAAKD,EAAS,EAAG,CACnB,GAAIC,aAAe,WACf,QAASQ,EAAI,EAAGA,EAAIR,EAAI,OAAQQ,IAC5B,KAAK,IAAIT,EAASS,EAAGR,EAAIQ,CAAC,CAAC,UAG1BN,EAAiBF,CAAG,EACzB,QAASQ,EAAI,EAAGA,EAAIR,EAAI,OAAQQ,IAC5B,KAAK,IAAIT,EAASS,EAAGR,EAAI,IAAIQ,CAAC,CAAC,MAInC,OAAM,IAAI,MAAM,kEAAkE,CAEzF,CAID,QAAQC,EAAO,CAIX,GAFAA,EAAQ,KAAK,MAAMA,CAAK,EAEpB,SAAO,MAAMA,CAAK,GAAKA,GAAS,GAIpC,IAAIA,IAAU,KAAK,WAAY,CAC3B,KAAK,KAAO,GACZ,KAAK,OAAS,EACd,MACH,CACD,KAAO,KAAK,KAAK,OAAS,GACtB,GAAIA,GAAS,KAAK,KAAK,CAAC,EAAE,WACtBA,GAAS,KAAK,KAAK,CAAC,EAAE,WACtB,KAAK,QAAU,KAAK,KAAK,CAAC,EAAE,WAC5B,KAAK,KAAK,YAET,CACD,KAAK,KAAK,CAAC,EAAI,KAAK,KAAK,CAAC,EAAE,SAASA,CAAK,EAC1C,KAAK,QAAUA,EACf,KACH,EAER,CAOD,MAAMC,EAAgBC,EAAc,CAChC,KAAM,CAAE,KAAAd,EAAM,OAAAS,CAAQ,EAAG,KAAK,SAASI,EAAgBC,CAAY,EACnE,OAAOC,EAAOf,EAAMS,CAAM,CAC7B,CAOD,SAASI,EAAgBC,EAAc,CACnC,KAAM,CAAE,KAAAd,EAAM,OAAAS,CAAQ,EAAG,KAAK,SAASI,EAAgBC,CAAY,EACnE,OAAId,EAAK,SAAW,EACTA,EAAK,CAAC,EAEVe,EAAOf,EAAMS,CAAM,CAC7B,CAMD,QAAQI,EAAgBC,EAAc,CAClC,KAAM,CAAE,KAAAd,EAAM,OAAAS,CAAQ,EAAG,KAAK,SAASI,EAAgBC,CAAY,EAC7DE,EAAO,IAAIT,EACjB,OAAAS,EAAK,OAASP,EAEdO,EAAK,KAAOhB,EACLgB,CACV,CACD,SAASH,EAAgBC,EAAc,CASnC,GARAD,EAAiBA,GAAkB,EACnCC,EAAeA,GAAgB,KAAK,OAChCD,EAAiB,IACjBA,EAAiB,KAAK,OAASA,GAE/BC,EAAe,IACfA,EAAe,KAAK,OAASA,GAE7BD,EAAiB,GAAKC,EAAe,KAAK,OAC1C,MAAM,IAAI,WAAW,wBAAwB,EAEjD,GAAID,IAAmBC,EACnB,MAAO,CAAE,KAAM,CAAA,EAAI,OAAQ,CAAC,EAEhC,GAAID,IAAmB,GAAKC,IAAiB,KAAK,OAC9C,MAAO,CAAE,KAAM,CAAC,GAAG,KAAK,IAAI,EAAG,OAAQ,KAAK,QAEhD,MAAMd,EAAO,CAAA,EACb,IAAIE,EAAS,EACb,QAAS,EAAI,EAAG,EAAI,KAAK,KAAK,OAAQ,IAAK,CACvC,MAAMC,EAAM,KAAK,KAAK,CAAC,EACjBc,EAAWf,EACXE,EAASa,EAAWd,EAAI,WAG9B,GADAD,EAASE,EACLS,GAAkBT,EAElB,SAEJ,MAAMc,EAAkBL,GAAkBI,GAAYJ,EAAiBT,EACjEe,EAAiBL,EAAeG,GAAYH,GAAgBV,EAClE,GAAIc,GAAmBC,EAAgB,CAEnC,GAAIN,IAAmBI,GAAYH,IAAiBV,EAAQ,CAExDJ,EAAK,KAAKG,CAAG,EACb,KACH,CAED,MAAMiB,EAAQP,EAAiBI,EAC/BjB,EAAK,KAAKG,EAAI,SAASiB,EAAOA,GAASN,EAAeD,EAAe,CAAC,EACtE,KACH,CACD,GAAIK,EAAiB,CAEjB,GAAIL,IAAmB,EAAG,CAEtBb,EAAK,KAAKG,CAAG,EACb,QACH,CAEDH,EAAK,KAAKG,EAAI,SAASU,EAAiBI,CAAQ,CAAC,EACjD,QACH,CACD,GAAIE,EAAgB,CAChB,GAAIL,IAAiBV,EAAQ,CAEzBJ,EAAK,KAAKG,CAAG,EACb,KACH,CAEDH,EAAK,KAAKG,EAAI,SAAS,EAAGW,EAAeG,CAAQ,CAAC,EAClD,KACH,CAEDjB,EAAK,KAAKG,CAAG,CAChB,CACD,MAAO,CAAE,KAAAH,EAAM,OAAQc,EAAeD,CAAc,CACvD,CACD,QAAQQ,EAAQnB,EAAS,EAAG,CACxB,GAAI,CAACG,EAAiBgB,CAAM,GAAK,EAAEA,aAAkB,YACjD,MAAM,IAAI,UAAU,6DAA6D,EAErF,MAAMC,EAASD,aAAkB,WAAaA,EAASA,EAAO,WAW9D,GAVAnB,EAAS,OAAOA,GAAU,CAAC,EACvB,MAAMA,CAAM,IACZA,EAAS,GAETA,EAAS,IACTA,EAAS,KAAK,OAASA,GAEvBA,EAAS,IACTA,EAAS,GAETmB,EAAO,SAAW,EAClB,OAAOnB,EAAS,KAAK,OAAS,KAAK,OAASA,EAGhD,MAAMqB,EAAID,EAAO,WACjB,GAAIC,IAAM,EACN,MAAM,IAAI,UAAU,qCAAqC,EAG7D,MAAMC,EAAQ,IACRC,EAAqB,IAAI,WAAWD,CAAK,EAE/C,QAASE,EAAI,EAAGA,EAAIF,EAAOE,IAEvBD,EAAmBC,CAAC,EAAI,GAE5B,QAASC,EAAI,EAAGA,EAAIJ,EAAGI,IAEnBF,EAAmBH,EAAOK,CAAC,CAAC,EAAIA,EAGpC,MAAMC,EAAQH,EACRI,EAAY,KAAK,WAAaP,EAAO,WACrCQ,EAAeR,EAAO,WAAa,EACzC,IAAIS,EACJ,QAASpB,EAAIT,EAAQS,GAAKkB,EAAWlB,GAAKoB,EAAM,CAC5CA,EAAO,EACP,QAASJ,EAAIG,EAAcH,GAAK,EAAGA,IAAK,CACpC,MAAMK,EAAO,KAAK,IAAIrB,EAAIgB,CAAC,EAC3B,GAAIL,EAAOK,CAAC,IAAMK,EAAM,CACpBD,EAAO,KAAK,IAAI,EAAGJ,EAAIC,EAAMI,CAAI,CAAC,EAClC,KACH,CACJ,CACD,GAAID,IAAS,EACT,OAAOpB,CAEd,CACD,MAAO,EACV,CACD,QAAQsB,EAAY,CAChB,MAAM9B,EAAM,KAAK,SAAS8B,EAAYA,EAAa,CAAC,EAEpD,OADa,IAAI,SAAS9B,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EACxD,QAAQ,CAAC,CACxB,CACD,QAAQ8B,EAAY3B,EAAO,CACvB,MAAMH,EAAM+B,GAAY,CAAC,EACZ,IAAI,SAAS/B,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EAC/D,QAAQ,EAAGG,CAAK,EACrB,KAAK,MAAMH,EAAK8B,CAAU,CAC7B,CACD,SAASA,EAAYE,EAAc,CAC/B,MAAMhC,EAAM,KAAK,SAAS8B,EAAYA,EAAa,CAAC,EAEpD,OADa,IAAI,SAAS9B,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EACxD,SAAS,EAAGgC,CAAY,CACvC,CACD,SAASF,EAAY3B,EAAO6B,EAAc,CACtC,MAAMhC,EAAMiC,EAAM,CAAC,EACN,IAAI,SAASjC,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EAC/D,SAAS,EAAGG,EAAO6B,CAAY,EACpC,KAAK,MAAMhC,EAAK8B,CAAU,CAC7B,CACD,SAASA,EAAYE,EAAc,CAC/B,MAAMhC,EAAM,KAAK,SAAS8B,EAAYA,EAAa,CAAC,EAEpD,OADa,IAAI,SAAS9B,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EACxD,SAAS,EAAGgC,CAAY,CACvC,CACD,SAASF,EAAY3B,EAAO6B,EAAc,CACtC,MAAMhC,EAAMiC,EAAM,CAAC,EACN,IAAI,SAASjC,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EAC/D,SAAS,EAAGG,EAAO6B,CAAY,EACpC,KAAK,MAAMhC,EAAK8B,CAAU,CAC7B,CACD,YAAYA,EAAYE,EAAc,CAClC,MAAMhC,EAAM,KAAK,SAAS8B,EAAYA,EAAa,CAAC,EAEpD,OADa,IAAI,SAAS9B,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EACxD,YAAY,EAAGgC,CAAY,CAC1C,CACD,YAAYF,EAAY3B,EAAO6B,EAAc,CACzC,MAAMhC,EAAMiC,EAAM,CAAC,EACN,IAAI,SAASjC,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EAC/D,YAAY,EAAGG,EAAO6B,CAAY,EACvC,KAAK,MAAMhC,EAAK8B,CAAU,CAC7B,CACD,SAASA,EAAY,CACjB,MAAM9B,EAAM,KAAK,SAAS8B,EAAYA,EAAa,CAAC,EAEpD,OADa,IAAI,SAAS9B,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EACxD,SAAS,CAAC,CACzB,CACD,SAAS8B,EAAY3B,EAAO,CACxB,MAAMH,EAAM+B,GAAY,CAAC,EACZ,IAAI,SAAS/B,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EAC/D,SAAS,EAAGG,CAAK,EACtB,KAAK,MAAMH,EAAK8B,CAAU,CAC7B,CACD,UAAUA,EAAYE,EAAc,CAChC,MAAMhC,EAAM,KAAK,SAAS8B,EAAYA,EAAa,CAAC,EAEpD,OADa,IAAI,SAAS9B,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EACxD,UAAU,EAAGgC,CAAY,CACxC,CACD,UAAUF,EAAY3B,EAAO6B,EAAc,CACvC,MAAMhC,EAAMiC,EAAM,CAAC,EACN,IAAI,SAASjC,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EAC/D,UAAU,EAAGG,EAAO6B,CAAY,EACrC,KAAK,MAAMhC,EAAK8B,CAAU,CAC7B,CACD,UAAUA,EAAYE,EAAc,CAChC,MAAMhC,EAAM,KAAK,SAAS8B,EAAYA,EAAa,CAAC,EAEpD,OADa,IAAI,SAAS9B,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EACxD,UAAU,EAAGgC,CAAY,CACxC,CACD,UAAUF,EAAY3B,EAAO6B,EAAc,CACvC,MAAMhC,EAAMiC,EAAM,CAAC,EACN,IAAI,SAASjC,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EAC/D,UAAU,EAAGG,EAAO6B,CAAY,EACrC,KAAK,MAAMhC,EAAK8B,CAAU,CAC7B,CACD,aAAaA,EAAYE,EAAc,CACnC,MAAMhC,EAAM,KAAK,SAAS8B,EAAYA,EAAa,CAAC,EAEpD,OADa,IAAI,SAAS9B,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EACxD,aAAa,EAAGgC,CAAY,CAC3C,CACD,aAAaF,EAAY3B,EAAO6B,EAAc,CAC1C,MAAMhC,EAAMiC,EAAM,CAAC,EACN,IAAI,SAASjC,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EAC/D,aAAa,EAAGG,EAAO6B,CAAY,EACxC,KAAK,MAAMhC,EAAK8B,CAAU,CAC7B,CACD,WAAWA,EAAYE,EAAc,CACjC,MAAMhC,EAAM,KAAK,SAAS8B,EAAYA,EAAa,CAAC,EAEpD,OADa,IAAI,SAAS9B,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EACxD,WAAW,EAAGgC,CAAY,CACzC,CACD,WAAWF,EAAY3B,EAAO6B,EAAc,CACxC,MAAMhC,EAAMiC,EAAM,CAAC,EACN,IAAI,SAASjC,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EAC/D,WAAW,EAAGG,EAAO6B,CAAY,EACtC,KAAK,MAAMhC,EAAK8B,CAAU,CAC7B,CACD,WAAWA,EAAYE,EAAc,CACjC,MAAMhC,EAAM,KAAK,SAAS8B,EAAYA,EAAa,CAAC,EAEpD,OADa,IAAI,SAAS9B,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EACxD,WAAW,EAAGgC,CAAY,CACzC,CACD,WAAWF,EAAY3B,EAAO6B,EAAc,CACxC,MAAMhC,EAAMiC,EAAM,CAAC,EACN,IAAI,SAASjC,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,EAC/D,WAAW,EAAGG,EAAO6B,CAAY,EACtC,KAAK,MAAMhC,EAAK8B,CAAU,CAC7B,CACD,OAAOI,EAAO,CAOV,GANIA,GAAS,MAGT,EAAEA,aAAiB9B,IAGnB8B,EAAM,KAAK,SAAW,KAAK,KAAK,OAChC,MAAO,GAEX,QAAS1B,EAAI,EAAGA,EAAI,KAAK,KAAK,OAAQA,IAClC,GAAI,CAAC2B,GAAO,KAAK,KAAK3B,CAAC,EAAG0B,EAAM,KAAK1B,CAAC,CAAC,EACnC,MAAO,GAGf,MAAO,EACV,CAKD,OAAO,gBAAgBX,EAAMS,EAAQ,CACjC,MAAMO,EAAO,IAAIT,EACjB,OAAAS,EAAK,KAAOhB,EACRS,GAAU,OACVA,EAAST,EAAK,OAAO,CAACuC,EAAKC,IAASD,EAAMC,EAAK,WAAY,CAAC,GAEhExB,EAAK,OAASP,EACPO,CACV,CACL,CC5bO,SAASyB,GAAOC,EAAQ,CAC3B,MAAMD,EAAU,iBAAmB,CAE/B,IAAI7B,EAAQ,MACR+B,EAAK,IAAIpC,EACb,gBAAiBqC,KAASF,EAAQ,CAC9B,GAAI9B,GAAS,KAAM,CACf+B,EAAG,OAAOC,CAAK,EACfhC,EAAQ,MAAM+B,EACdA,EAAK,IAAIpC,EACT,QACH,CAED,IADAoC,EAAG,OAAOC,CAAK,EACRD,EAAG,QAAU/B,GAAO,CACvB,MAAMJ,EAAOmC,EAAG,QAAQ,EAAG/B,CAAK,EAIhC,GAHA+B,EAAG,QAAQ/B,CAAK,EAChBA,EAAQ,MAAMJ,EAEVI,GAAS,KAAM,CACX+B,EAAG,OAAS,IACZ/B,EAAQ,MAAM+B,EACdA,EAAK,IAAIpC,GAEb,KACH,CACJ,CACJ,CAGD,GAAIK,GAAS,KACT,MAAM,OAAO,OAAO,IAAI,MAAM,uBAAuBA,0BAA8B,EAAG,CAAE,KAAM,iBAAkB,OAAQ+B,CAAI,CAAA,CAExI,IACI,OAAKF,EAAO,OACLA,CACX,CCzDA,MAAMI,EAAU,CACZ,YAAYC,EAAK,CACb,GAAI,EAAEA,EAAM,IAAQA,EAAM,EAAKA,EAC3B,MAAM,IAAI,MAAM,mDAAmD,EAEvE,KAAK,OAAS,IAAI,MAAMA,CAAG,EAC3B,KAAK,KAAOA,EAAM,EAClB,KAAK,IAAM,EACX,KAAK,IAAM,EACX,KAAK,KAAO,IACf,CACD,KAAKtC,EAAM,CACP,OAAI,KAAK,OAAO,KAAK,GAAG,IAAM,OACnB,IAEX,KAAK,OAAO,KAAK,GAAG,EAAIA,EACxB,KAAK,IAAO,KAAK,IAAM,EAAK,KAAK,KAC1B,GACV,CACD,OAAQ,CACJ,MAAMuC,EAAO,KAAK,OAAO,KAAK,GAAG,EACjC,GAAIA,IAAS,OAGb,YAAK,OAAO,KAAK,GAAG,EAAI,OACxB,KAAK,IAAO,KAAK,IAAM,EAAK,KAAK,KAC1BA,CACV,CACD,SAAU,CACN,OAAO,KAAK,OAAO,KAAK,GAAG,IAAM,MACpC,CACL,CACO,MAAMC,EAAK,CACd,YAAYrD,EAAU,GAAI,CACtB,KAAK,IAAMA,EAAQ,YAAc,GACjC,KAAK,KAAO,IAAIkD,GAAU,KAAK,GAAG,EAClC,KAAK,KAAO,KAAK,KACjB,KAAK,KAAO,CACf,CACD,cAAcI,EAAK,CACf,OAAIA,GAAK,YAAc,KACZA,EAAI,WAER,CACV,CACD,KAAKC,EAAK,CAIN,GAHIA,GAAK,OAAS,OACd,KAAK,MAAQ,KAAK,cAAcA,EAAI,KAAK,GAEzC,CAAC,KAAK,KAAK,KAAKA,CAAG,EAAG,CACtB,MAAMC,EAAO,KAAK,KAClB,KAAK,KAAOA,EAAK,KAAO,IAAIN,GAAU,EAAI,KAAK,KAAK,OAAO,MAAM,EACjE,KAAK,KAAK,KAAKK,CAAG,CACrB,CACJ,CACD,OAAQ,CACJ,IAAIA,EAAM,KAAK,KAAK,MAAK,EACzB,GAAIA,IAAQ,QAAc,KAAK,KAAK,MAAQ,KAAO,CAC/C,MAAME,EAAO,KAAK,KAAK,KACvB,KAAK,KAAK,KAAO,KACjB,KAAK,KAAOA,EACZF,EAAM,KAAK,KAAK,OACnB,CACD,OAAIA,GAAK,OAAS,OACd,KAAK,MAAQ,KAAK,cAAcA,EAAI,KAAK,GAEtCA,CACV,CACD,SAAU,CACN,OAAO,KAAK,KAAK,SACpB,CACL,CCvBO,SAASG,GAAS1D,EAAU,GAAI,CAenC,OAAO2D,GAdUC,GAAW,CACxB,MAAMH,EAAOG,EAAO,QACpB,GAAIH,GAAQ,KACR,MAAO,CAAE,KAAM,IAEnB,GAAIA,EAAK,OAAS,KACd,MAAMA,EAAK,MAEf,MAAO,CACH,KAAMA,EAAK,OAAS,GAEpB,MAAOA,EAAK,KACxB,CACA,EAC8BzD,CAAO,CACrC,CACO,SAAS6D,GAAU7D,EAAU,GAAI,CAyBpC,OAAO2D,GAxBUC,GAAW,CACxB,IAAIH,EACJ,MAAMK,EAAS,CAAA,EACf,KAAO,CAACF,EAAO,YACXH,EAAOG,EAAO,QACVH,GAAQ,OAFU,CAKtB,GAAIA,EAAK,OAAS,KACd,MAAMA,EAAK,MAEXA,EAAK,OAAS,IAEdK,EAAO,KAAKL,EAAK,KAAK,CAE7B,CACD,OAAIA,GAAQ,KACD,CAAE,KAAM,IAEZ,CACH,KAAMA,EAAK,OAAS,GACpB,MAAOK,CACnB,CACA,EAC8B9D,CAAO,CACrC,CACA,SAAS2D,GAAUI,EAAS/D,EAAS,CACjCA,EAAUA,GAAW,GACrB,IAAIgE,EAAQhE,EAAQ,MAChB4D,EAAS,IAAIP,GACbK,EACAO,EACAC,EACJ,MAAMC,EAAW,SACRP,EAAO,UAGRM,EACO,CAAE,KAAM,IAEZ,MAAM,IAAI,QAAQ,CAACE,EAASC,IAAW,CAC1CJ,EAAUR,GAAS,CACfQ,EAAS,KACTL,EAAO,KAAKH,CAAI,EAChB,GAAI,CACAW,EAAQL,EAAQH,CAAM,CAAC,CAC1B,OACMU,EAAP,CACID,EAAOC,CAAG,CACb,CACD,OAAOZ,CACvB,CACA,CAAS,EAjBUK,EAAQH,CAAM,EAmBvBW,EAAcd,GACZQ,GAAU,KACHA,EAAOR,CAAI,GAEtBG,EAAO,KAAKH,CAAI,EACTC,GAELc,EAAeF,IACjBV,EAAS,IAAIP,GACTY,GAAU,KACHA,EAAO,CAAE,MAAOK,CAAK,CAAA,GAEhCV,EAAO,KAAK,CAAE,MAAOU,CAAK,CAAA,EACnBZ,IAELe,EAAQ9D,GAAU,CACpB,GAAIuD,EACA,OAAOR,EAGX,GAAI1D,GAAS,aAAe,IAAQW,GAAO,YAAc,KACrD,MAAM,IAAI,MAAM,gEAAgE,EAEpF,OAAO4D,EAAW,CAAE,KAAM,GAAO,MAAA5D,CAAO,CAAA,CAChD,EACU+D,EAAOJ,GACLJ,EACOR,GACXQ,EAAQ,GACAI,GAAO,KAAQE,EAAYF,CAAG,EAAIC,EAAW,CAAE,KAAM,EAAI,CAAE,GAEjEI,EAAU,KACZf,EAAS,IAAIP,GACbqB,IACO,CAAE,KAAM,KAEbE,EAAUN,IACZI,EAAIJ,CAAG,EACA,CAAE,KAAM,KAanB,GAXAZ,EAAW,CACP,CAAC,OAAO,aAAa,GAAI,CAAE,OAAO,IAAO,EACzC,KAAMS,EACN,OAAQQ,EACR,MAAOC,EACP,KAAAH,EACA,IAAAC,EACA,IAAI,gBAAiB,CACjB,OAAOd,EAAO,IACjB,CACT,EACQI,GAAS,KACT,OAAON,EAEX,MAAMC,EAAYD,EAClB,OAAAA,EAAW,CACP,CAAC,OAAO,aAAa,GAAI,CAAE,OAAO,IAAO,EACzC,MAAO,CACH,OAAOC,EAAU,MACpB,EACD,MAAMW,EAAK,CACP,OAAAX,EAAU,MAAMW,CAAG,EACfN,GAAS,OACTA,EAAMM,CAAG,EACTN,EAAQ,QAEL,CAAE,KAAM,GAClB,EACD,QAAS,CACL,OAAAL,EAAU,OAAM,EACZK,GAAS,OACTA,IACAA,EAAQ,QAEL,CAAE,KAAM,GAClB,EACD,KAAAS,EACA,IAAIH,EAAK,CACL,OAAAX,EAAU,IAAIW,CAAG,EACbN,GAAS,OACTA,EAAMM,CAAG,EACTN,EAAQ,QAELN,CACV,EACD,IAAI,gBAAiB,CACjB,OAAOC,EAAU,cACpB,CACT,EACWD,CACX,CCnNe,SAASmB,IAAS,CAChC,MAAMC,EAAW,CAAA,EAEjB,OAAAA,EAAS,QAAU,IAAI,QAAQ,CAACV,EAASC,IAAW,CACnDS,EAAS,QAAUV,EACnBU,EAAS,OAAST,CACpB,CAAE,EAEMS,CACR,CCLO,SAASC,GAAUC,EAAQ,CAC9B,MAAMC,EAASvB,KACTX,EAASD,GAAOkC,EAAO,MAAM,EAE7BE,EAAgBC,KACtB,IAAIC,EACJ,MAAMC,EAAcL,EAAO,KAAM,iBAAmB,CAChD,MAAOC,EAEP,MADe,MAAMC,EAAc,OAEtC,EAAA,CAAG,EACJ,OAAAG,EAAY,MAAMf,GAAO,CACrBc,EAAUd,CAClB,CAAK,EAWM,CACH,OAAQvB,EACR,OAAAkC,EACA,OAbS,CACT,KAAM,MAAOlC,GACLqC,GAAW,KACJ,MAAM,QAAQ,OAAOA,CAAO,GAEvCF,EAAc,QAAQnC,CAAM,EACrB,MAAMsC,GAEjB,OAAAtC,CACR,EAKQ,KAAM,IAAMkC,EAAO,IAAK,EACxB,MAAOA,EAAO,KACd,KAAM,SAAY,CACd,MAAMlE,EAAM,MAAMgC,EAAO,OACzB,GAAIhC,EAAI,OAAS,KACb,OAAOA,EAAI,KAElB,CACT,CACA,CCzCe,SAASuE,GAAS9E,EAAK,CAClC,OAAIA,aAAe,WACR,CACH,IAAIF,EAAO,CACP,OAAOE,EAAIF,CAAK,CACnB,EACD,IAAIA,EAAOK,EAAO,CACdH,EAAIF,CAAK,EAAIK,CAChB,CACb,EAEW,CACH,IAAIL,EAAO,CACP,OAAOE,EAAI,IAAIF,CAAK,CACvB,EACD,IAAIA,EAAOK,EAAO,CACdH,EAAI,IAAIF,EAAOK,CAAK,CACvB,CACT,CACA,CClBA,MAAM4E,GAAS,WACR,MAAMC,CAAS,CAClB,YAAYC,EAAK,EAAGC,EAAK,EAAG,CACxB,KAAK,GAAKD,EACV,KAAK,GAAKC,CACb,CAID,SAASC,EAAU,CACf,GAAIA,IAAa,GACb,OAAO,OAAO,KAAK,KAAO,CAAC,GAAK,OAAO,KAAK,KAAO,CAAC,GAAK,KAE7D,GAAK,KAAK,KAAO,GAAW,CACxB,MAAMD,EAAK,CAAC,KAAK,GAAK,IAAM,EAC5B,IAAID,EAAK,CAAC,KAAK,KAAO,EACtB,OAAIC,IAAO,IACPD,EAAKA,EAAK,IAAM,GAEb,EAAE,OAAOC,CAAE,GAAK,OAAOD,CAAE,GAAK,KACxC,CACD,OAAO,OAAO,KAAK,KAAO,CAAC,GAAK,OAAO,KAAK,KAAO,CAAC,GAAK,IAC5D,CAKD,SAASE,EAAU,CACf,OAAO,OAAO,KAAK,SAASA,CAAQ,CAAC,CACxC,CAID,UAAW,CACP,MAAMC,EAAO,EAAE,KAAK,GAAK,GACnBF,IAAO,KAAK,KAAO,EAAI,KAAK,IAAM,IAAME,KAAU,EAClDH,GAAM,KAAK,KAAO,EAAIG,KAAU,EACtC,OAAO,IAAIJ,EAASC,EAAIC,CAAE,CAC7B,CAID,UAAW,CACP,MAAME,EAAO,KAAK,IAAM,GAClBH,IAAO,KAAK,IAAM,EAAI,KAAK,KAAO,IAAMG,KAAU,EAClDF,GAAM,KAAK,IAAM,EAAIE,KAAU,EACrC,OAAO,IAAIJ,EAASC,EAAIC,CAAE,CAC7B,CAID,QAAQlF,EAAKD,EAAS,EAAG,CACrB,MAAMsF,EAASP,GAAS9E,CAAG,EAC3B,KAAO,KAAK,GAAK,GACbqF,EAAO,IAAItF,IAAU,KAAK,GAAK,IAAM,GAAG,EACxC,KAAK,IAAM,KAAK,KAAO,EAAI,KAAK,IAAM,MAAQ,EAC9C,KAAK,MAAQ,EAEjB,KAAO,KAAK,GAAK,KACbsF,EAAO,IAAItF,IAAU,KAAK,GAAK,IAAM,GAAG,EACxC,KAAK,GAAK,KAAK,KAAO,EAE1BsF,EAAO,IAAItF,IAAU,KAAK,EAAE,CAC/B,CAID,OAAO,WAAWI,EAAO,CACrB,GAAIA,IAAU,GACV,OAAO,IAAI6E,EAEf,MAAMM,EAAWnF,EAAQ,EACrBmF,IACAnF,EAAQ,CAACA,GAEb,IAAI8E,EAAK,OAAO9E,GAAS,GAAG,EAAI,EAC5B+E,EAAK,OAAO/E,GAAS,OAAO8E,CAAE,GAAK,IAAI,EAAI,EAC/C,OAAIK,IACAL,EAAK,CAACA,IAAO,EACbC,EAAK,CAACA,IAAO,EACT,EAAEA,EAAKH,KACPG,EAAK,EACD,EAAED,EAAKF,KACPE,EAAK,KAIV,IAAID,EAASC,EAAIC,CAAE,CAC7B,CAID,OAAO,WAAW/E,EAAO,CACrB,GAAIA,IAAU,EACV,OAAO,IAAI6E,EAEf,MAAMO,EAAOpF,EAAQ,EACjBoF,IACApF,EAAQ,CAACA,GAEb,IAAI+E,EAAK/E,IAAU,EACf8E,GAAM9E,EAAQ+E,GAAM,aAAe,EACvC,OAAIK,IACAN,EAAK,CAACA,IAAO,EACbC,EAAK,CAACA,IAAO,EACT,EAAEA,EAAK,aACPA,EAAK,EACD,EAAED,EAAK,aACPA,EAAK,KAIV,IAAID,EAASC,EAAIC,CAAE,CAC7B,CAID,OAAO,UAAUlF,EAAKD,EAAS,EAAG,CAC9B,MAAMsF,EAASP,GAAS9E,CAAG,EAErBwF,EAAO,IAAIR,EACjB,IAAI,EAAI,EACR,GAAIhF,EAAI,OAASD,EAAS,EAAG,CACzB,KAAO,EAAI,EAAG,EAAE,EAGZ,GADAyF,EAAK,IAAMA,EAAK,IAAMH,EAAO,IAAItF,CAAM,EAAI,MAAQ,EAAI,KAAO,EAC1DsF,EAAO,IAAItF,GAAQ,EAAI,IACvB,OAAOyF,EAMf,GAFAA,EAAK,IAAMA,EAAK,IAAMH,EAAO,IAAItF,CAAM,EAAI,MAAQ,MAAQ,EAC3DyF,EAAK,IAAMA,EAAK,IAAMH,EAAO,IAAItF,CAAM,EAAI,MAAQ,KAAO,EACtDsF,EAAO,IAAItF,GAAQ,EAAI,IACvB,OAAOyF,EAEX,EAAI,CACP,KAEG,MAAO,EAAI,EAAG,EAAE,EAAG,CAEf,GAAIzF,GAAUC,EAAI,OACd,MAAM,WAAW,uBAAuBD,OAAYC,EAAI,QAAQ,EAIpE,GADAwF,EAAK,IAAMA,EAAK,IAAMH,EAAO,IAAItF,CAAM,EAAI,MAAQ,EAAI,KAAO,EAC1DsF,EAAO,IAAItF,GAAQ,EAAI,IACvB,OAAOyF,CAEd,CAEL,GAAIxF,EAAI,OAASD,EAAS,GACtB,KAAO,EAAI,EAAG,EAAE,EAGZ,GADAyF,EAAK,IAAMA,EAAK,IAAMH,EAAO,IAAItF,CAAM,EAAI,MAAQ,EAAI,EAAI,KAAO,EAC9DsF,EAAO,IAAItF,GAAQ,EAAI,IACvB,OAAOyF,UAIVzF,EAASC,EAAI,WAClB,KAAO,EAAI,EAAG,EAAE,EAAG,CAEf,GAAID,GAAUC,EAAI,OACd,MAAM,WAAW,uBAAuBD,OAAYC,EAAI,QAAQ,EAIpE,GADAwF,EAAK,IAAMA,EAAK,IAAMH,EAAO,IAAItF,CAAM,EAAI,MAAQ,EAAI,EAAI,KAAO,EAC9DsF,EAAO,IAAItF,GAAQ,EAAI,IACvB,OAAOyF,CAEd,CAGL,MAAM,WAAW,yBAAyB,CAC7C,CACL,CC/KA,MAAMC,GAAK,KAAK,IAAI,EAAG,CAAC,EAClBC,GAAK,KAAK,IAAI,EAAG,EAAE,EACnBC,GAAK,KAAK,IAAI,EAAG,EAAE,EACnBC,GAAK,KAAK,IAAI,EAAG,EAAE,EACnBC,GAAK,KAAK,IAAI,EAAG,EAAE,EACnBC,GAAK,KAAK,IAAI,EAAG,EAAE,EACnBC,GAAK,KAAK,IAAI,EAAG,EAAE,EACnBC,GAAK,KAAK,IAAI,EAAG,EAAE,EACnBC,GAAK,KAAK,IAAI,EAAG,EAAE,EACZd,EAAW,CACpB,eAAehF,EAAO,CAClB,OAAIA,EAAQsF,GACD,EAEPtF,EAAQuF,GACD,EAEPvF,EAAQwF,GACD,EAEPxF,EAAQyF,GACD,EAEPzF,EAAQ0F,GACD,EAEP1F,EAAQ2F,GACD,EAEP3F,EAAQ4F,GACD,EAEP5F,EAAQ6F,GACD,EAEP7F,EAAQ8F,GACD,EAEJ,EACV,EACD,OAAO9F,EAAOH,EAAKD,EAAS,EAAG,CAC3B,GAAI,OAAO,kBAAoB,MAAQI,EAAQ,OAAO,iBAClD,MAAM,IAAI,WAAW,yBAAyB,EAElD,OAAIH,GAAO,OACPA,EAAM+B,GAAYoD,EAAS,eAAehF,CAAK,CAAC,GAEpD6E,EAAS,WAAW7E,CAAK,EAAE,QAAQH,EAAKD,CAAM,EACvCC,CACV,EACD,OAAOA,EAAKD,EAAS,EAAG,CACpB,OAAOiF,EAAS,UAAUhF,EAAKD,CAAM,EAAE,SAAS,EAAI,CACvD,CACL,ECpDO,SAASgC,GAAYmE,EAAK,CAC7B,OAAI,YAAY,QAAQ,aAAe,KAC5B,WAAW,OAAO,YAAYA,CAAG,EAErC,IAAI,WAAWA,CAAG,CAC7B,CCLA,MAAMC,GAAkB7F,GAAW,CAC/B,MAAM8F,EAAejB,EAAS,eAAe7E,CAAM,EAC7C+F,EAAYtE,GAAYqE,CAAY,EAC1C,OAAAjB,EAAS,OAAO7E,EAAQ+F,CAAS,EACjCF,GAAe,MAAQC,EAChBC,CACX,EACAF,GAAe,MAAQ,EAChB,SAASG,GAAO9G,EAAS,CAC5BA,EAAUA,GAAW,GACrB,MAAM+G,EAAe/G,EAAQ,eAAiB2G,GAqB9C,OApBgB,gBAAiB5D,EAAQ,CACrC,gBAAiBE,KAASF,EAAQ,CAE9B,MAAMjC,EAASiG,EAAa9D,EAAM,UAAU,EAExCnC,aAAkB,WAClB,MAAMA,EAGN,MAAOA,EAGPmC,aAAiB,WACjB,MAAMA,EAGN,MAAOA,CAEd,CACT,CAEA,CACA6D,GAAO,OAAS,CAAC7D,EAAOjD,IAAY,CAChCA,EAAUA,GAAW,GACrB,MAAM+G,EAAe/G,EAAQ,eAAiB2G,GAC9C,OAAO,IAAI/F,EAAemG,EAAa9D,EAAM,UAAU,EAAGA,CAAK,CACnE,ECnCO,MAAM+D,GAAoB,EAEpBC,GAAkB,KAAO,KAAO,EAC7C,IAAIC,GACH,SAAUA,EAAU,CACjBA,EAASA,EAAS,OAAY,CAAC,EAAI,SACnCA,EAASA,EAAS,KAAU,CAAC,EAAI,MACrC,GAAGA,IAAaA,EAAW,CAAE,EAAC,EAC9B,MAAMC,GAAkB3G,GAAQ,CAC5B,MAAMM,EAAS6E,EAAS,OAAOnF,CAAG,EAClC,OAAA2G,GAAe,MAAQxB,EAAS,eAAe7E,CAAM,EAC9CA,CACX,EACAqG,GAAe,MAAQ,EAChB,SAASC,GAAOpH,EAAS,CAyD5B,OAxDgB,gBAAiB+C,EAAQ,CACrC,MAAMa,EAAS,IAAIhD,EACnB,IAAIyG,EAAOH,EAAS,OAChBI,EAAa,GACjB,MAAMC,EAAgBvH,GAAS,eAAiBmH,GAC1CK,EAAkBxH,GAAS,iBAAmBgH,GAC9CS,EAAgBzH,GAAS,eAAiBiH,GAChD,gBAAiBzG,KAAOuC,EAEpB,IADAa,EAAO,OAAOpD,CAAG,EACVoD,EAAO,WAAa,GAAG,CAC1B,GAAIyD,IAASH,EAAS,OAElB,GAAI,CAEA,GADAI,EAAaC,EAAc3D,CAAM,EAC7B0D,EAAa,EACb,MAAMI,EAAQ,IAAI,MAAM,wBAAwB,EAAG,wBAAwB,EAE/E,GAAIJ,EAAaG,EACb,MAAMC,EAAQ,IAAI,MAAM,yBAAyB,EAAG,uBAAuB,EAE/E,MAAMC,EAAmBJ,EAAc,MACvC3D,EAAO,QAAQ+D,CAAgB,EAC3B3H,GAAS,UAAY,MACrBA,EAAQ,SAASsH,CAAU,EAE/BD,EAAOH,EAAS,IACnB,OACM5C,EAAP,CACI,GAAIA,aAAe,WAAY,CAC3B,GAAIV,EAAO,WAAa4D,EACpB,MAAME,EAAQ,IAAI,MAAM,gCAAgC,EAAG,yBAAyB,EAExF,KACH,CACD,MAAMpD,CACT,CAEL,GAAI+C,IAASH,EAAS,KAAM,CACxB,GAAItD,EAAO,WAAa0D,EAEpB,MAEJ,MAAMzG,EAAO+C,EAAO,QAAQ,EAAG0D,CAAU,EACzC1D,EAAO,QAAQ0D,CAAU,EACrBtH,GAAS,QAAU,MACnBA,EAAQ,OAAOa,CAAI,EAEvB,MAAMA,EACNwG,EAAOH,EAAS,MACnB,CACJ,CAEL,GAAItD,EAAO,WAAa,EACpB,MAAM8D,EAAQ,IAAI,MAAM,yBAAyB,EAAG,oBAAoB,CAEpF,CAEA,CAMAN,GAAO,WAAa,CAACtE,EAAQ9C,IAAY,CACrC,IAAI4H,EAAa,EACjB,MAAMC,EAAiB,iBAAmB,CACtC,OACI,GAAI,CACA,KAAM,CAAE,KAAAC,EAAM,MAAAnH,CAAO,EAAG,MAAMmC,EAAO,KAAK8E,CAAU,EACpD,GAAIE,IAAS,GACT,OAEAnH,GAAS,OACT,MAAMA,EAEb,OACM2D,EAAP,CACI,GAAIA,EAAI,OAAS,iBACb,MAAO,CAAE,KAAM,GAAM,MAAO,IAAI,EAEpC,MAAMA,CACT,QACO,CAEJsD,EAAa,CAChB,CAER,EAAA,EAKD,OAAOR,GAAO,CACV,GAAIpH,GAAW,CAAA,EACf,SAHc+H,GAAM,CAAEH,EAAaG,CAAE,CAI7C,CAAK,EAAEF,CAAa,CACpB,EC5FO,SAASG,GAASC,EAAQC,EAAO,GAAI,CACxC,MAAMC,EAAQpD,GAAUkD,CAAM,EACxBG,EAAWC,GAAU,WAAWF,EAAM,OAAQD,CAAI,EAClDI,EAAI,CACN,KAAM,MAAOrH,GAAU,CAEnB,KAAM,CAAE,MAAAN,CAAK,EAAK,MAAMwH,EAAM,OAAO,KAAKlH,CAAK,EAC/C,GAAIN,GAAS,KACT,MAAM,IAAI,MAAM,eAAe,EAEnC,OAAOA,CACV,EACD,OAAQ,SAAY,CAGhB,KAAM,CAAE,MAAAA,CAAO,EAAG,MAAMyH,EAAS,KAAI,EACrC,GAAIzH,GAAS,KACT,MAAM,IAAI,MAAM,eAAe,EAEnC,OAAOA,CACV,EACD,OAAQ,MAAO4H,GAAU,CAErB,MAAM5H,EAAQ,MAAM2H,EAAE,SACtB,GAAI3H,GAAS,KACT,MAAM,IAAI,MAAM,eAAe,EAGnC,MAAMH,EAAMG,aAAiB,WAAaA,EAAQA,EAAM,WACxD,OAAO4H,EAAM,OAAO/H,CAAG,CAC1B,EACD,MAAQK,GAAS,CAETA,aAAgB,WAChBsH,EAAM,OAAO,KAAKtH,CAAI,EAGtBsH,EAAM,OAAO,KAAKtH,EAAK,SAAU,CAAA,CAExC,EACD,QAAUA,GAAS,CAEfyH,EAAE,MAAME,GAAU,OAAO3H,EAAMqH,CAAI,CAAC,CACvC,EACD,QAAS,CAACrH,EAAM0H,IAAU,CAEtBD,EAAE,QAAQC,EAAM,OAAO1H,CAAI,CAAC,CAC/B,EACD,GAAK0H,IACM,CACH,KAAM,SAAY,MAAMD,EAAE,OAAOC,CAAK,EACtC,MAAQE,GAAMH,EAAE,QAAQG,EAAGF,CAAK,CAChD,GAEQ,OAAQ,KAEJJ,EAAM,KAAI,EACHA,EAAM,OAEzB,EACI,OAAOG,CACX,CCjFO,SAASI,IAAO,CACnB,MAAM5D,EAAWK,KACjB,IAAIwD,EAAQ,GACZ,MAAO,CACH,KAAM,MAAO5F,GAAW,CACpB,GAAI4F,EACA,MAAM,IAAI,MAAM,eAAe,EAEnCA,EAAQ,GACR7D,EAAS,QAAQ/B,CAAM,CAC1B,EACD,OAAS,iBAAmB,CAExB,MADe,MAAM+B,EAAS,OAE1C,GACA,CACA,CChBO,SAAS8D,IAAa,CACzB,MAAMC,EAAIH,KACJI,EAAIJ,KACV,MAAO,CACH,CACI,OAAQG,EAAE,OACV,KAAMC,EAAE,IACX,EACD,CACI,OAAQA,EAAE,OACV,KAAMD,EAAE,IACX,CACT,CACA,CCVe,eAAgBE,MAASC,EAAS,CAC7C,MAAMC,EAASvF,GAAS,CACpB,WAAY,EACpB,CAAK,EACI,QAAQ,UAAU,KAAK,SAAY,CACpC,GAAI,CACA,MAAM,QAAQ,IAAIsF,EAAQ,IAAI,MAAOjG,GAAW,CAC5C,gBAAiBmG,KAAQnG,EACrBkG,EAAO,KAAKC,CAAI,CAEvB,CAAA,CAAC,EACFD,EAAO,IAAG,CACb,OACM3E,EAAP,CACI2E,EAAO,IAAI3E,CAAG,CACjB,CACT,CAAK,EACD,MAAO2E,CACX,CCvBO,MAAME,GAAU,IAAIC,IAAQ,CAC/B,IAAIrI,EACJ,KAAOqI,EAAI,OAAS,GAChBrI,EAAMqI,EAAI,MAAO,EAACrI,CAAG,EAEzB,OAAOA,CACX,EACasI,GAAc/F,GAChBA,GAAO,OAAS,OAAOA,EAAI,OAAO,aAAa,GAAM,YACxD,OAAOA,EAAI,OAAO,QAAQ,GAAM,YAChC,OAAOA,EAAI,MAAS,YAGfgG,GAAYhG,GACdA,GAAO,MAAQ,OAAOA,EAAI,MAAS,YAAc+F,GAAW/F,EAAI,MAAM,EAE3EiG,GAAoBtB,GACdlF,GAAW,CACf,MAAMyG,EAAIvB,EAAO,KAAKlF,CAAM,EAC5B,GAAIyG,EAAE,MAAQ,KAAM,CAChB,MAAMxE,EAAStB,GAAS,CACpB,WAAY,EAC5B,CAAa,EACD,OAAA8F,EAAE,KAAK,IAAM,CACTxE,EAAO,IAAG,CACb,EAAGV,GAAQ,CACRU,EAAO,IAAIV,CAAG,CAC9B,CAAa,EAKMyE,GAAM/D,EAJM,iBAAmB,CAClC,MAAOiD,EAAO,OACdjD,EAAO,IAAG,CAC1B,EAC2C,CAAE,CACpC,CACD,OAAOiD,EAAO,MACtB,EAEO,SAASwB,GAAKC,KAAUC,EAAM,CAEjC,GAAIL,GAASI,CAAK,EAAG,CACjB,MAAMzB,EAASyB,EACfA,EAAQ,IAAMzB,EAAO,MAExB,SACQoB,GAAWK,CAAK,EAAG,CACxB,MAAM3G,EAAS2G,EACfA,EAAQ,IAAM3G,CACjB,CACD,MAAMqG,EAAM,CAACM,EAAO,GAAGC,CAAI,EAO3B,GANIP,EAAI,OAAS,GAETE,GAASF,EAAIA,EAAI,OAAS,CAAC,CAAC,IAC5BA,EAAIA,EAAI,OAAS,CAAC,EAAIA,EAAIA,EAAI,OAAS,CAAC,EAAE,MAG9CA,EAAI,OAAS,EAEb,QAASpI,EAAI,EAAGA,EAAIoI,EAAI,OAAS,EAAGpI,IAC5BsI,GAASF,EAAIpI,CAAC,CAAC,IACfoI,EAAIpI,CAAC,EAAIuI,GAAiBH,EAAIpI,CAAC,CAAC,GAI5C,OAAOmI,GAAQ,GAAGC,CAAG,CACzB,CClEO,MAAMQ,EAA6B,MAC7BC,GAAyCD,EAA6B,GACtEE,GAAoB,QAAQ,WAAW,SAAS,KAAK,iBAAiB,uBCCnF,OAAO,eAAeC,GAAS,aAAc,CAAE,MAAO,EAAI,CAAE,EAC5D,SAASC,GAAmBC,EAAG,CAC3B,OAAQ,OAAOA,EAAE,UAAc,KAC3B,OAAOA,EAAE,aAAiB,KAC1B,OAAOA,EAAE,gBAAoB,GACrC,CAC0BF,GAAA,mBAAGC,GCN7B,OAAO,eAAeE,EAAS,aAAc,CAAE,MAAO,EAAI,CAAE,EAI5D,IAAIC,EAASC,GACTC,GAAkBC,GAClBC,GAASC,GAITC,GAAsB,UAAY,CAIlC,SAASA,EAAKV,EAAMW,EAAK,CACrB,KAAK,UAAY,GAEjB,KAAK,OAAS,IAAIX,EAClB,KAAK,OAAS,IAAIA,EAGlB,KAAK,UAAY,KAAK,OAAO,UAC7B,KAAK,aAAe,KAAK,OAAO,aAEhC,IAAIY,EAAM,IAAI,WAAW,KAAK,SAAS,EACnCD,EAAI,OAAS,KAAK,UAGlB,KAAK,OAAO,OAAOA,CAAG,EAAE,OAAOC,CAAG,EAAE,QAIpCA,EAAI,IAAID,CAAG,EAKf,QAAS1J,EAAI,EAAGA,EAAI2J,EAAI,OAAQ3J,IAC5B2J,EAAI3J,CAAC,GAAK,GAGd,KAAK,OAAO,OAAO2J,CAAG,EAItB,QAAS3J,EAAI,EAAGA,EAAI2J,EAAI,OAAQ3J,IAC5B2J,EAAI3J,CAAC,GAAK,IAGd,KAAK,OAAO,OAAO2J,CAAG,EAIlBR,EAAO,mBAAmB,KAAK,MAAM,GAAKA,EAAO,mBAAmB,KAAK,MAAM,IAC/E,KAAK,iBAAmB,KAAK,OAAO,UAAS,EAC7C,KAAK,iBAAmB,KAAK,OAAO,UAAS,GAGjDI,GAAO,KAAKI,CAAG,CAClB,CAMD,OAAAF,EAAK,UAAU,MAAQ,UAAY,CAC/B,GAAI,CAACN,EAAO,mBAAmB,KAAK,MAAM,GAAK,CAACA,EAAO,mBAAmB,KAAK,MAAM,EACjF,MAAM,IAAI,MAAM,mEAAmE,EAGvF,YAAK,OAAO,aAAa,KAAK,gBAAgB,EAC9C,KAAK,OAAO,aAAa,KAAK,gBAAgB,EAC9C,KAAK,UAAY,GACV,IACf,EAIIM,EAAK,UAAU,MAAQ,UAAY,CAC3BN,EAAO,mBAAmB,KAAK,MAAM,GACrC,KAAK,OAAO,gBAAgB,KAAK,gBAAgB,EAEjDA,EAAO,mBAAmB,KAAK,MAAM,GACrC,KAAK,OAAO,gBAAgB,KAAK,gBAAgB,EAErD,KAAK,OAAO,QACZ,KAAK,OAAO,OACpB,EAIIM,EAAK,UAAU,OAAS,SAAU5J,EAAM,CACpC,YAAK,OAAO,OAAOA,CAAI,EAChB,IACf,EAII4J,EAAK,UAAU,OAAS,SAAUG,EAAK,CACnC,OAAI,KAAK,WAIL,KAAK,OAAO,OAAOA,CAAG,EACf,OAGX,KAAK,OAAO,OAAOA,CAAG,EAEtB,KAAK,OAAO,OAAOA,EAAI,SAAS,EAAG,KAAK,YAAY,CAAC,EAAE,OAAOA,CAAG,EACjE,KAAK,UAAY,GACV,KACf,EAIIH,EAAK,UAAU,OAAS,UAAY,CAChC,IAAIG,EAAM,IAAI,WAAW,KAAK,YAAY,EAC1C,YAAK,OAAOA,CAAG,EACRA,CACf,EAKIH,EAAK,UAAU,UAAY,UAAY,CACnC,GAAI,CAACN,EAAO,mBAAmB,KAAK,MAAM,EACtC,MAAM,IAAI,MAAM,2DAA2D,EAE/E,OAAO,KAAK,OAAO,WAC3B,EACIM,EAAK,UAAU,aAAe,SAAUI,EAAY,CAChD,GAAI,CAACV,EAAO,mBAAmB,KAAK,MAAM,GAAK,CAACA,EAAO,mBAAmB,KAAK,MAAM,EACjF,MAAM,IAAI,MAAM,8DAA8D,EAElF,YAAK,OAAO,aAAaU,CAAU,EACnC,KAAK,OAAO,aAAa,KAAK,gBAAgB,EAC9C,KAAK,UAAY,GACV,IACf,EACIJ,EAAK,UAAU,gBAAkB,SAAUI,EAAY,CACnD,GAAI,CAACV,EAAO,mBAAmB,KAAK,MAAM,EACtC,MAAM,IAAI,MAAM,iEAAiE,EAErF,KAAK,OAAO,gBAAgBU,CAAU,CAC9C,EACWJ,CACX,EAAC,EACWP,EAAA,KAAGO,GAIf,SAASK,GAAKf,EAAMW,EAAK7J,EAAM,CAC3B,IAAIoJ,EAAI,IAAIQ,GAAKV,EAAMW,CAAG,EAC1BT,EAAE,OAAOpJ,CAAI,EACb,IAAIkK,EAASd,EAAE,SACf,OAAAA,EAAE,MAAK,EACAc,CACX,CACYb,EAAA,KAAGY,GAafZ,EAAA,MAAgBG,GAAgB,MC5KhC,OAAO,eAAeW,GAAS,aAAc,CAAE,MAAO,EAAI,CAAE,EAC5D,IAAId,GAASE,EACTG,GAASD,GASTW,GAAsB,UAAY,CASlC,SAASA,EAAKlB,EAAMW,EAAKQ,EAAMC,EAAM,CAC7BD,IAAS,SAAUA,EAAO,IAAI,WAAW,CAAC,GAC9C,KAAK,SAAW,IAAI,WAAW,CAAC,EAChC,KAAK,MAAQnB,EACb,KAAK,MAAQoB,EAEb,IAAIC,EAAMlB,GAAO,KAAK,KAAK,MAAOgB,EAAMR,CAAG,EAE3C,KAAK,MAAQ,IAAIR,GAAO,KAAKH,EAAMqB,CAAG,EAEtC,KAAK,QAAU,IAAI,WAAW,KAAK,MAAM,YAAY,EACrD,KAAK,QAAU,KAAK,QAAQ,MAC/B,CAED,OAAAH,EAAK,UAAU,YAAc,UAAY,CAErC,KAAK,SAAS,CAAC,IACf,IAAII,EAAM,KAAK,SAAS,CAAC,EAEzB,GAAIA,IAAQ,EACR,MAAM,IAAI,MAAM,0BAA0B,EAG9C,KAAK,MAAM,QAGPA,EAAM,GACN,KAAK,MAAM,OAAO,KAAK,OAAO,EAG9B,KAAK,OACL,KAAK,MAAM,OAAO,KAAK,KAAK,EAGhC,KAAK,MAAM,OAAO,KAAK,QAAQ,EAE/B,KAAK,MAAM,OAAO,KAAK,OAAO,EAE9B,KAAK,QAAU,CACvB,EAOIJ,EAAK,UAAU,OAAS,SAAUnK,EAAQ,CAEtC,QADI8J,EAAM,IAAI,WAAW9J,CAAM,EACtBE,EAAI,EAAGA,EAAI4J,EAAI,OAAQ5J,IACxB,KAAK,UAAY,KAAK,QAAQ,QAC9B,KAAK,YAAW,EAEpB4J,EAAI5J,CAAC,EAAI,KAAK,QAAQ,KAAK,SAAS,EAExC,OAAO4J,CACf,EACIK,EAAK,UAAU,MAAQ,UAAY,CAC/B,KAAK,MAAM,QACXV,GAAO,KAAK,KAAK,OAAO,EACxBA,GAAO,KAAK,KAAK,QAAQ,EACzB,KAAK,QAAU,CACvB,EACWU,CACX,EAAC,EACWK,GAAAN,GAAA,KAAGC,GCnFR,MAAMM,GAAY,CACrB,WAAW1K,EAAM,CACb,OAAOkJ,GAAAA,KAAKlJ,CAAI,CACnB,EACD,QAAQ2K,EAAIC,EAAK,CAGb,MAAML,EAFO,IAAIH,GAAKS,GAAM,OAAED,EAAKD,CAAE,EACb,OAAO,EAAE,EAE3BG,EAAKP,EAAI,SAAS,EAAG,EAAE,EACvBQ,EAAKR,EAAI,SAAS,GAAI,EAAE,EACxBS,EAAKT,EAAI,SAAS,GAAI,EAAE,EAC9B,MAAO,CAACO,EAAIC,EAAIC,CAAE,CACrB,EACD,uBAAwB,CACpB,MAAMC,EAAUC,GAAAA,kBAChB,MAAO,CACH,UAAWD,EAAQ,UACnB,WAAYA,EAAQ,SAChC,CACK,EACD,8BAA8BE,EAAM,CAChC,MAAMF,EAAUG,2BAA+BD,CAAI,EACnD,MAAO,CACH,UAAWF,EAAQ,UACnB,WAAYA,EAAQ,SAChC,CACK,EACD,wBAAwBI,EAAYC,EAAW,CAC3C,OAAOC,GAAgB,UAACF,EAAYC,CAAS,CAChD,EACD,wBAAwBE,EAAWC,EAAOC,EAAIC,EAAG,CAE7C,OADY,IAAIC,oBAAiBD,CAAC,EACvB,KAAKF,EAAOD,EAAWE,CAAE,CACvC,EACD,wBAAwBG,EAAYJ,EAAOC,EAAIC,EAAGG,EAAK,CAEnD,OADY,IAAIF,oBAAiBD,CAAC,EACvB,KAAKF,EAAOI,EAAYH,EAAII,CAAG,CAC7C,CACL,ECzCMpK,GAAemE,GACb,WAAW,OACJ,WAAW,OAAO,YAAYA,CAAG,EAErC,IAAI,WAAWA,CAAG,EAEhBkG,GAAkBjM,GAAU,CACrC,MAAMkM,EAAStK,GAAY,CAAC,EAC5B,WAAI,SAASsK,EAAO,OAAQA,EAAO,WAAYA,EAAO,UAAU,EAAE,UAAU,EAAGlM,EAAO,EAAK,EACpFkM,CACX,EACAD,GAAe,MAAQ,EAChB,MAAME,EAAkBjM,GAAS,CACpC,GAAIA,EAAK,OAAS,EACd,MAAM,WAAW,0BAA0B,EAC/C,OAAIA,aAAgB,WACT,IAAI,SAASA,EAAK,OAAQA,EAAK,WAAYA,EAAK,UAAU,EAAE,UAAU,EAAG,EAAK,EAElFA,EAAK,UAAU,CAAC,CAC3B,EACAiM,EAAe,MAAQ,EAEhB,SAASC,GAAQC,EAAS,CAC7B,OAAOC,EAAiB,CAACD,EAAQ,GAAIA,EAAQ,UAAU,EAAGA,EAAQ,GAAG,OAASA,EAAQ,WAAW,MAAM,CAC3G,CACO,SAASE,GAAQF,EAAS,CAC7B,OAAOC,EAAiB,CAACD,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,UAAU,EAAGA,EAAQ,GAAG,OAASA,EAAQ,GAAG,OAASA,EAAQ,WAAW,MAAM,CAC3I,CACO,SAASG,GAAQH,EAAS,CAC7B,OAAOC,EAAiB,CAACD,EAAQ,GAAIA,EAAQ,UAAU,EAAGA,EAAQ,GAAG,OAASA,EAAQ,WAAW,MAAM,CAC3G,CACO,SAASI,GAAQC,EAAO,CAC3B,GAAIA,EAAM,OAAS,GACf,MAAM,IAAI,MAAM,iEAAiE,EAErF,MAAO,CACH,GAAIA,EAAM,SAAS,EAAG,EAAE,EACxB,WAAYA,EAAM,SAAS,GAAIA,EAAM,MAAM,EAC3C,GAAI,IAAI,WAAW,CAAC,CAC5B,CACA,CACO,SAASC,GAAQD,EAAO,CAC3B,GAAIA,EAAM,OAAS,GACf,MAAM,IAAI,MAAM,iEAAiE,EAErF,MAAO,CACH,GAAIA,EAAM,SAAS,EAAG,EAAE,EACxB,GAAIA,EAAM,SAAS,GAAI,EAAE,EACzB,WAAYA,EAAM,SAAS,GAAIA,EAAM,MAAM,CACnD,CACA,CACO,SAASE,GAAQF,EAAO,CAC3B,GAAIA,EAAM,OAAS,GACf,MAAM,IAAI,MAAM,iEAAiE,EAErF,MAAO,CACH,GAAI,IAAI,WAAW,CAAC,EACpB,GAAIA,EAAM,SAAS,EAAG,EAAE,EACxB,WAAYA,EAAM,SAAS,GAAIA,EAAM,MAAM,CACnD,CACA,CCzDO,SAASG,GAAczI,EAAW0I,EAAS,CAC9C,OAAO,gBAAiB1K,EAAQ,CAC5B,gBAAiBE,KAASF,EACtB,QAAS/B,EAAI,EAAGA,EAAIiC,EAAM,OAAQjC,GAAK6I,GAAwC,CAC3E,IAAInF,EAAM1D,EAAI6I,GACVnF,EAAMzB,EAAM,SACZyB,EAAMzB,EAAM,QAEhB,MAAMpC,EAAOkE,EAAU,QAAQ9B,EAAM,SAASjC,EAAG0D,CAAG,EAAGK,EAAU,OAAO,EACxE0I,GAAS,iBAAiB,YAC1B,MAAMb,GAAe/L,EAAK,UAAU,EACpC,MAAMA,CACT,CAEb,CACA,CAEO,SAAS6M,GAAc3I,EAAW0I,EAAS,CAC9C,OAAO,gBAAiB1K,EAAQ,CAC5B,gBAAiBE,KAASF,EACtB,QAAS/B,EAAI,EAAGA,EAAIiC,EAAM,OAAQjC,GAAK4I,EAA4B,CAC/D,IAAIlF,EAAM1D,EAAI4I,EAId,GAHIlF,EAAMzB,EAAM,SACZyB,EAAMzB,EAAM,QAEZyB,EAAMiJ,GAAU,WAAG3M,EACnB,MAAM,IAAI,MAAM,eAAe,EAEnC,MAAM4M,EAAY3K,EAAM,SAASjC,EAAG0D,CAAG,EAKjCiI,EAAM1J,EAAM,SAASjC,EAAG0D,EAAMiJ,GAAAA,UAAU,EACxC,CAAE,UAAWE,EAAW,MAAAC,GAAU/I,EAAU,QAAQ6I,EAAW7I,EAAU,QAAS4H,CAAG,EAC3F,GAAI,CAACmB,EACD,MAAAL,GAAS,cAAc,YACjB,IAAI,MAAM,oCAAoC,EAExDA,GAAS,iBAAiB,YAC1B,MAAMI,CACT,CAEb,CACA,CChDO,MAAME,WAA4B,KAAM,CAC3C,YAAYf,EAAU,kBAAmB,CACrC,MAAMA,CAAO,EACb,KAAK,KAAOe,GAAoB,IACnC,CACD,WAAW,MAAO,CACd,MAAO,qBACV,CACL,CACO,MAAMC,UAAmC,KAAM,CAClD,YAAYhB,EAAU,0BAA2B,CAC7C,MAAMA,CAAO,EACb,KAAK,KAAOgB,EAA2B,IAC1C,CACD,WAAW,MAAO,CACd,MAAO,6BACV,CACL,CCjBA,IAAIC,GAAWnH,GAEXoH,GAAM,IACNC,GAAO,IACPC,GAAS,CAACD,GACVE,GAAM,KAAK,IAAI,EAAG,EAAE,EAExB,SAASvH,GAAOwH,EAAK1D,EAAKrK,EAAQ,CAChCqK,EAAMA,GAAO,GACbrK,EAASA,GAAU,EAGnB,QAFIgO,EAAYhO,EAEV+N,GAAOD,IACXzD,EAAIrK,GAAQ,EAAK+N,EAAM,IAAQJ,GAC/BI,GAAO,IAET,KAAMA,EAAMF,IACVxD,EAAIrK,GAAQ,EAAK+N,EAAM,IAAQJ,GAC/BI,KAAS,EAEX,OAAA1D,EAAIrK,CAAM,EAAI+N,EAAM,EAEpBxH,GAAO,MAAQvG,EAASgO,EAAY,EAE7B3D,CACT,CAEA,IAAIxD,GAASoH,GAETC,GAAQ,IACRC,GAAS,IAEb,SAASF,GAAKhO,EAAKD,EAAQ,CACzB,IAAIQ,EAAS,EACTR,EAASA,GAAU,EACnBoO,EAAS,EACTC,EAAUrO,EACVuI,EACAf,EAAIvH,EAAI,OAEZ,EAAG,CACD,GAAIoO,GAAW7G,EACb,MAAAyG,GAAK,MAAQ,EACP,IAAI,WAAW,yBAAyB,EAEhD1F,EAAItI,EAAIoO,GAAS,EACjB7N,GAAO4N,EAAQ,IACV7F,EAAI4F,KAAWC,GACf7F,EAAI4F,IAAU,KAAK,IAAI,EAAGC,CAAK,EACpCA,GAAS,CACb,OAAW7F,GAAK2F,IAEd,OAAAD,GAAK,MAAQI,EAAUrO,EAEhBQ,CACT,CAEA,IAAIkF,GAAK,KAAK,IAAI,EAAI,CAAC,EACnBC,GAAK,KAAK,IAAI,EAAG,EAAE,EACnBC,GAAK,KAAK,IAAI,EAAG,EAAE,EACnBC,GAAK,KAAK,IAAI,EAAG,EAAE,EACnBC,GAAK,KAAK,IAAI,EAAG,EAAE,EACnBC,GAAK,KAAK,IAAI,EAAG,EAAE,EACnBC,GAAK,KAAK,IAAI,EAAG,EAAE,EACnBC,GAAK,KAAK,IAAI,EAAG,EAAE,EACnBC,GAAK,KAAK,IAAI,EAAG,EAAE,EAEnB3F,GAAS,SAAUH,EAAO,CAC5B,OACEA,EAAQsF,GAAK,EACbtF,EAAQuF,GAAK,EACbvF,EAAQwF,GAAK,EACbxF,EAAQyF,GAAK,EACbzF,EAAQ0F,GAAK,EACb1F,EAAQ2F,GAAK,EACb3F,EAAQ4F,GAAK,EACb5F,EAAQ6F,GAAK,EACb7F,EAAQ8F,GAAK,EACA,EAEjB,EAEIoI,GAAS,CACT,OAAQZ,GACR,OAAQ7G,GACR,eAAgBtG,EACpB,EAEIgO,GAAeD,GCjFZ,MAAMzH,GAAS,CAACvG,EAAMN,EAAS,IAE7B,CADMsO,GAAO,OAAOhO,EAAMN,CAAM,EACzBsO,GAAO,OAAO,KAAK,EAQtBE,GAAW,CAACC,EAAKnC,EAAQtM,EAAS,KAC7CsO,GAAO,OAAOG,EAAKnC,EAAQtM,CAAM,EAC1BsM,GAOIoC,GAAkBD,GACtBH,GAAO,eAAeG,CAAG,ECR5BrM,GAAS,CAACuM,EAAIC,IAAO,CACzB,GAAID,IAAOC,EAAI,MAAO,GACtB,GAAID,EAAG,aAAeC,EAAG,WACvB,MAAO,GAGT,QAASC,EAAK,EAAGA,EAAKF,EAAG,WAAYE,IACnC,GAAIF,EAAGE,CAAE,IAAMD,EAAGC,CAAE,EAClB,MAAO,GAIX,MAAO,EACT,EAMMC,GAASC,GAAK,CAClB,GAAIA,aAAa,YAAcA,EAAE,YAAY,OAAS,aAAc,OAAOA,EAC3E,GAAIA,aAAa,YAAa,OAAO,IAAI,WAAWA,CAAC,EACrD,GAAI,YAAY,OAAOA,CAAC,EACtB,OAAO,IAAI,WAAWA,EAAE,OAAQA,EAAE,WAAYA,EAAE,UAAU,EAE5D,MAAM,IAAI,MAAM,mCAAmC,CACrD,EAaMC,GAAaC,GAAQ,IAAI,YAAW,EAAI,OAAOA,CAAG,EAMlDC,GAAW3G,GAAM,IAAI,YAAa,EAAE,OAAOA,CAAC,ECtDrC4G,EAAS,CAACC,EAAM5E,IAAW,CACtC,MAAM6E,EAAO7E,EAAO,WACd8E,EAAaC,GAAsBH,CAAI,EACvCI,EAAeF,EAAaC,GAAsBF,CAAI,EAEtD3O,EAAQ,IAAI,WAAW8O,EAAeH,CAAI,EAChDI,OAAAA,GAAgBL,EAAM1O,EAAO,CAAC,EAC9B+O,GAAgBJ,EAAM3O,EAAO4O,CAAU,EACvC5O,EAAM,IAAI8J,EAAQgF,CAAY,EAEvB,IAAIE,GAAON,EAAMC,EAAM7E,EAAQ9J,CAAK,CAC7C,EAQamG,GAAU8I,GAAc,CACnC,MAAMjP,EAAQoO,GAAOa,CAAS,EACxB,CAACP,EAAME,CAAU,EAAIM,GAAclP,CAAK,EACxC,CAAC2O,EAAMG,CAAY,EAAII,GAAclP,EAAM,SAAS4O,CAAU,CAAC,EAC/D9E,EAAS9J,EAAM,SAAS4O,EAAaE,CAAY,EAEvD,GAAIhF,EAAO,aAAe6E,EACxB,MAAM,IAAI,MAAM,kBAAkB,EAGpC,OAAO,IAAIK,GAAON,EAAMC,EAAM7E,EAAQ9J,CAAK,CAC7C,EAOa0B,GAAS,CAACkG,EAAGC,IAAM,CAC9B,GAAID,IAAMC,EACR,MAAO,GACF,CACL,MAAMjI,EAAqEiI,EAE3E,OACED,EAAE,OAAShI,EAAK,MAChBgI,EAAE,OAAShI,EAAK,MAChBA,EAAK,iBAAiB,YACtBuP,GAAWvH,EAAE,MAAOhI,EAAK,KAAK,CAEjC,CACH,EAeO,MAAMoP,EAAO,CASlB,YAAaN,EAAMC,EAAM7E,EAAQ9J,EAAO,CACtC,KAAK,KAAO0O,EACZ,KAAK,KAAOC,EACZ,KAAK,OAAS7E,EACd,KAAK,MAAQ9J,CACd,CACH,CCrFA,SAASoP,GAAMC,EAAUC,EAAM,CAC7B,GAAID,EAAS,QAAU,IAAO,MAAM,IAAI,UAAU,mBAAmB,EAErE,QADIE,EAAW,IAAI,WAAW,GAAG,EACxBxO,EAAI,EAAGA,EAAIwO,EAAS,OAAQxO,IACnCwO,EAASxO,CAAC,EAAI,IAEhB,QAAShB,EAAI,EAAGA,EAAIsP,EAAS,OAAQtP,IAAK,CACxC,IAAIyP,EAAIH,EAAS,OAAOtP,CAAC,EACrB0P,EAAKD,EAAE,WAAW,CAAC,EACvB,GAAID,EAASE,CAAE,IAAM,IAAO,MAAM,IAAI,UAAUD,EAAI,eAAe,EACnED,EAASE,CAAE,EAAI1P,CAChB,CACD,IAAI2P,EAAOL,EAAS,OAChBM,EAASN,EAAS,OAAO,CAAC,EAC1BO,EAAS,KAAK,IAAIF,CAAI,EAAI,KAAK,IAAI,GAAG,EACtCG,EAAU,KAAK,IAAI,GAAG,EAAI,KAAK,IAAIH,CAAI,EAC3C,SAAS7J,EAAQ/D,EAAQ,CAMvB,GALIA,aAAkB,aAAuB,YAAY,OAAOA,CAAM,EACpEA,EAAS,IAAI,WAAWA,EAAO,OAAQA,EAAO,WAAYA,EAAO,UAAU,EAClE,MAAM,QAAQA,CAAM,IAC7BA,EAAS,WAAW,KAAKA,CAAM,IAE7B,EAAEA,aAAkB,YAAe,MAAM,IAAI,UAAU,qBAAqB,EAChF,GAAIA,EAAO,SAAW,EAAK,MAAO,GAMlC,QAJIgO,EAAS,EACTjQ,EAAS,EACTkQ,EAAS,EACTC,EAAOlO,EAAO,OACXiO,IAAWC,GAAQlO,EAAOiO,CAAM,IAAM,GAC3CA,IACAD,IAMF,QAHInB,GAASqB,EAAOD,GAAUF,EAAU,IAAO,EAC3CI,EAAM,IAAI,WAAWtB,CAAI,EAEtBoB,IAAWC,GAAM,CAItB,QAHIE,EAAQpO,EAAOiO,CAAM,EAErBhQ,EAAI,EACCoQ,EAAMxB,EAAO,GAAIuB,IAAU,GAAKnQ,EAAIF,IAAYsQ,IAAQ,GAAKA,IAAOpQ,IAC3EmQ,GAAU,IAAMD,EAAIE,CAAG,IAAO,EAC9BF,EAAIE,CAAG,EAAKD,EAAQR,IAAU,EAC9BQ,EAASA,EAAQR,IAAU,EAE7B,GAAIQ,IAAU,EAAK,MAAM,IAAI,MAAM,gBAAgB,EACnDrQ,EAASE,EACTgQ,GACD,CAGD,QADIK,EAAMzB,EAAO9O,EACVuQ,IAAQzB,GAAQsB,EAAIG,CAAG,IAAM,GAClCA,IAIF,QADI7B,EAAMoB,EAAO,OAAOG,CAAM,EACvBM,EAAMzB,EAAM,EAAEyB,EAAO7B,GAAOc,EAAS,OAAOY,EAAIG,CAAG,CAAC,EAC3D,OAAO7B,CACR,CACD,SAAS8B,EAAcvO,EAAQ,CAC7B,GAAI,OAAOA,GAAW,SAAY,MAAM,IAAI,UAAU,iBAAiB,EACvE,GAAIA,EAAO,SAAW,EAAK,OAAO,IAAI,WACtC,IAAIwO,EAAM,EAEV,GAAIxO,EAAOwO,CAAG,IAAM,IAIpB,SAFIR,EAAS,EACTjQ,EAAS,EACNiC,EAAOwO,CAAG,IAAMX,GACrBG,IACAQ,IAMF,QAHI3B,GAAU7M,EAAO,OAASwO,GAAOV,EAAU,IAAO,EAClDW,EAAO,IAAI,WAAW5B,CAAI,EAEvB7M,EAAOwO,CAAG,GAAG,CAElB,IAAIJ,EAAQX,EAASzN,EAAO,WAAWwO,CAAG,CAAC,EAE3C,GAAIJ,IAAU,IAAO,OAErB,QADInQ,EAAI,EACCyQ,EAAM7B,EAAO,GAAIuB,IAAU,GAAKnQ,EAAIF,IAAY2Q,IAAQ,GAAKA,IAAOzQ,IAC3EmQ,GAAUR,EAAOa,EAAKC,CAAG,IAAO,EAChCD,EAAKC,CAAG,EAAKN,EAAQ,MAAS,EAC9BA,EAASA,EAAQ,MAAS,EAE5B,GAAIA,IAAU,EAAK,MAAM,IAAI,MAAM,gBAAgB,EACnDrQ,EAASE,EACTuQ,GACD,CAED,GAAIxO,EAAOwO,CAAG,IAAM,IAGpB,SADIG,EAAM9B,EAAO9O,EACV4Q,IAAQ9B,GAAQ4B,EAAKE,CAAG,IAAM,GACnCA,IAIF,QAFIC,EAAM,IAAI,WAAWZ,GAAUnB,EAAO8B,EAAI,EAC1C1P,EAAI+O,EACDW,IAAQ9B,GACb+B,EAAI3P,GAAG,EAAIwP,EAAKE,GAAK,EAEvB,OAAOC,GACR,CACD,SAASvK,EAAQwK,EAAQ,CACvB,IAAIhO,EAAS0N,EAAaM,CAAM,EAChC,GAAIhO,EAAU,OAAOA,EACrB,MAAM,IAAI,MAAM,OAAO2M,aAAgB,CACxC,CACD,MAAO,CACL,OAAQzJ,EACR,aAAcwK,EACd,OAAQlK,CACT,CACH,CACA,IAAIyK,GAAMxB,GAENyB,GAAkCD,GC3GtC,MAAME,EAAQ,CAMZ,YAAaxB,EAAMyB,EAAQC,EAAY,CACrC,KAAK,KAAO1B,EACZ,KAAK,OAASyB,EACd,KAAK,WAAaC,CACnB,CAMD,OAAQhR,EAAO,CACb,GAAIA,aAAiB,WACnB,MAAO,GAAG,KAAK,SAAS,KAAK,WAAWA,CAAK,IAE7C,MAAM,MAAM,mCAAmC,CAElD,CACH,CAiBA,MAAMiR,EAAQ,CAMZ,YAAa3B,EAAMyB,EAAQG,EAAY,CAIrC,GAHA,KAAK,KAAO5B,EACZ,KAAK,OAASyB,EAEVA,EAAO,YAAY,CAAC,IAAM,OAC5B,MAAM,IAAI,MAAM,0BAA0B,EAG5C,KAAK,gBAAyCA,EAAO,YAAY,CAAC,EAClE,KAAK,WAAaG,CACnB,CAKD,OAAQC,EAAM,CACZ,GAAI,OAAOA,GAAS,SAAU,CAC5B,GAAIA,EAAK,YAAY,CAAC,IAAM,KAAK,gBAC/B,MAAM,MAAM,qCAAqC,KAAK,UAAUA,CAAI,MAAM,KAAK,mDAAmD,KAAK,QAAQ,EAEjJ,OAAO,KAAK,WAAWA,EAAK,MAAM,KAAK,OAAO,MAAM,CAAC,CAC3D,KACM,OAAM,MAAM,mCAAmC,CAElD,CAOD,GAAIC,EAAS,CACX,OAAOC,GAAG,KAAMD,CAAO,CACxB,CACH,CAYA,MAAME,EAAgB,CAIpB,YAAaC,EAAU,CACrB,KAAK,SAAWA,CACjB,CAOD,GAAIH,EAAS,CACX,OAAOC,GAAG,KAAMD,CAAO,CACxB,CAMD,OAAQhF,EAAO,CACb,MAAM2E,EAAgC3E,EAAM,CAAC,EACvCgF,EAAU,KAAK,SAASL,CAAM,EACpC,GAAIK,EACF,OAAOA,EAAQ,OAAOhF,CAAK,EAE3B,MAAM,WAAW,qCAAqC,KAAK,UAAUA,CAAK,gCAAgC,OAAO,KAAK,KAAK,QAAQ,iBAAiB,CAEvJ,CACH,CASO,MAAMiF,GAAK,CAACG,EAAMxQ,IAAU,IAAIsQ,GAA6C,CAClF,GAAIE,EAAK,UAAY,CAAE,CAAoCA,EAAM,MAAM,EAAGA,GAC1E,GAAIxQ,EAAM,UAAY,CAAE,CAAoCA,EAAO,MAAM,EAAGA,EAC9E,CAAG,EAaI,MAAMyQ,EAAM,CAOjB,YAAanC,EAAMyB,EAAQC,EAAYE,EAAY,CACjD,KAAK,KAAO5B,EACZ,KAAK,OAASyB,EACd,KAAK,WAAaC,EAClB,KAAK,WAAaE,EAClB,KAAK,QAAU,IAAIJ,GAAQxB,EAAMyB,EAAQC,CAAU,EACnD,KAAK,QAAU,IAAIC,GAAQ3B,EAAMyB,EAAQG,CAAU,CACpD,CAKD,OAAQ9E,EAAO,CACb,OAAO,KAAK,QAAQ,OAAOA,CAAK,CACjC,CAKD,OAAQA,EAAO,CACb,OAAO,KAAK,QAAQ,OAAOA,CAAK,CACjC,CACH,CAYO,MAAMsF,GAAO,CAAC,CAAE,KAAApC,EAAM,OAAAyB,EAAQ,OAAAlL,EAAQ,OAAAM,CAAQ,IACnD,IAAIsL,GAAMnC,EAAMyB,EAAQlL,EAAQM,CAAM,EAW3BwL,EAAQ,CAAC,CAAE,OAAAZ,EAAQ,KAAAzB,EAAM,SAAAsC,CAAQ,IAAO,CACnD,KAAM,CAAE,OAAA/L,EAAQ,OAAAM,CAAM,EAAK0L,GAAMD,EAAUtC,CAAI,EAC/C,OAAOoC,GAAK,CACV,OAAAX,EACA,KAAAzB,EACA,OAAAzJ,EAIA,OAAQsL,GAAQ/C,GAAOjI,EAAOgL,CAAI,CAAC,CACvC,CAAG,CACH,EASMhL,GAAS,CAACwK,EAAQiB,EAAUE,EAAaxC,IAAS,CAGtD,MAAMyC,EAAQ,CAAE,EAChB,QAAShS,EAAI,EAAGA,EAAI6R,EAAS,OAAQ,EAAE7R,EACrCgS,EAAMH,EAAS7R,CAAC,CAAC,EAAIA,EAIvB,IAAI0D,EAAMkN,EAAO,OACjB,KAAOA,EAAOlN,EAAM,CAAC,IAAM,KACzB,EAAEA,EAIJ,MAAMkG,EAAM,IAAI,WAAYlG,EAAMqO,EAAc,EAAK,CAAC,EAGtD,IAAI/M,EAAO,EACPpC,EAAS,EACTqP,EAAU,EACd,QAASjS,EAAI,EAAGA,EAAI0D,EAAK,EAAE1D,EAAG,CAE5B,MAAML,EAAQqS,EAAMpB,EAAO5Q,CAAC,CAAC,EAC7B,GAAIL,IAAU,OACZ,MAAM,IAAI,YAAY,OAAO4P,aAAgB,EAI/C3M,EAAUA,GAAUmP,EAAepS,EACnCqF,GAAQ+M,EAGJ/M,GAAQ,IACVA,GAAQ,EACR4E,EAAIqI,GAAS,EAAI,IAAQrP,GAAUoC,EAEtC,CAGD,GAAIA,GAAQ+M,GAAe,IAAQnP,GAAW,EAAIoC,EAChD,MAAM,IAAI,YAAY,wBAAwB,EAGhD,OAAO4E,CACT,EAQM9D,GAAS,CAACjG,EAAMgS,EAAUE,IAAgB,CAC9C,MAAMpI,EAAMkI,EAASA,EAAS,OAAS,CAAC,IAAM,IACxCjN,GAAQ,GAAKmN,GAAe,EAClC,IAAInI,EAAM,GAEN5E,EAAO,EACPpC,EAAS,EACb,QAAS5C,EAAI,EAAGA,EAAIH,EAAK,OAAQ,EAAEG,EAMjC,IAJA4C,EAAUA,GAAU,EAAK/C,EAAKG,CAAC,EAC/BgF,GAAQ,EAGDA,EAAO+M,GACZ/M,GAAQ+M,EACRnI,GAAOiI,EAASjN,EAAQhC,GAAUoC,CAAK,EAU3C,GALIA,IACF4E,GAAOiI,EAASjN,EAAQhC,GAAWmP,EAAc/M,CAAM,GAIrD2E,EACF,KAAQC,EAAI,OAASmI,EAAe,GAClCnI,GAAO,IAIX,OAAOA,CACT,EAaasI,EAAU,CAAC,CAAE,KAAA3C,EAAM,OAAAyB,EAAQ,YAAAe,EAAa,SAAAF,CAAQ,IACpDF,GAAK,CACV,OAAAX,EACA,KAAAzB,EACA,OAAQlD,EAAO,CACb,OAAOvG,GAAOuG,EAAOwF,EAAUE,CAAW,CAC3C,EACD,OAAQ1F,EAAO,CACb,OAAOjG,GAAOiG,EAAOwF,EAAUE,EAAaxC,CAAI,CACjD,CACL,CAAG,ECvVU4C,EAAYP,EAAM,CAC7B,KAAM,YACN,OAAQ,IACR,SAAU,4DACZ,CAAC,EAEYQ,GAAeR,EAAM,CAChC,KAAM,eACN,OAAQ,IACR,SAAU,4DACZ,CAAC,4HCVYS,EAASH,EAAQ,CAC5B,OAAQ,IACR,KAAM,SACN,SAAU,mCACV,YAAa,CACf,CAAC,EAEYI,GAAcJ,EAAQ,CACjC,OAAQ,IACR,KAAM,cACN,SAAU,mCACV,YAAa,CACf,CAAC,EAEYK,GAAYL,EAAQ,CAC/B,OAAQ,IACR,KAAM,YACN,SAAU,oCACV,YAAa,CACf,CAAC,EAEYM,GAAiBN,EAAQ,CACpC,OAAQ,IACR,KAAM,iBACN,SAAU,oCACV,YAAa,CACf,CAAC,EAEYO,GAAYP,EAAQ,CAC/B,OAAQ,IACR,KAAM,YACN,SAAU,mCACV,YAAa,CACf,CAAC,EAEYQ,GAAiBR,EAAQ,CACpC,OAAQ,IACR,KAAM,iBACN,SAAU,mCACV,YAAa,CACf,CAAC,EAEYS,GAAeT,EAAQ,CAClC,OAAQ,IACR,KAAM,eACN,SAAU,oCACV,YAAa,CACf,CAAC,EAEYU,GAAoBV,EAAQ,CACvC,OAAQ,IACR,KAAM,oBACN,SAAU,oCACV,YAAa,CACf,CAAC,EAEYW,GAAUX,EAAQ,CAC7B,OAAQ,IACR,KAAM,UACN,SAAU,mCACV,YAAa,CACf,CAAC,sOC5CYY,GAAS,CAACC,EAAM1D,IAAS,CACpC,KAAM,CAAE,MAAApP,EAAO,QAAA+S,CAAO,EAAKD,EAC3B,OAAQC,EAAO,CACb,IAAK,GACH,OAAOC,GACLhT,EACAiT,GAAUH,CAAI,EAC4B1D,GAAS8C,EAAU,OAC9D,EACH,QACE,OAAOgB,GACLlT,EACAiT,GAAUH,CAAI,EAC+B1D,GAAQgD,EAAO,OAC7D,CACJ,CACH,EAGMe,GAAQ,IAAI,QAMZF,GAAYG,GAAO,CACvB,MAAMH,EAAYE,GAAM,IAAIC,CAAG,EAC/B,GAAIH,GAAa,KAAM,CACrB,MAAMA,EAAY,IAAI,IACtB,OAAAE,GAAM,IAAIC,EAAKH,CAAS,EACjBA,CACR,CACD,OAAOA,CACT,EAUO,MAAMI,CAAI,CAQf,YAAaN,EAASrE,EAAMO,EAAWjP,EAAO,CAE5C,KAAK,KAAO0O,EAEZ,KAAK,QAAUqE,EAEf,KAAK,UAAY9D,EAEjB,KAAK,MAAQjP,EAKb,KAAK,GAAG,EAAIA,CACb,CAQD,IAAI,OAAS,CACX,OAAO,IACR,CAGD,IAAI,YAAc,CAChB,OAAO,KAAK,MAAM,UACnB,CAGD,IAAI,YAAc,CAChB,OAAO,KAAK,MAAM,UACnB,CAKD,MAAQ,CACN,OAAQ,KAAK,QAAO,CAClB,IAAK,GACH,OAA6D,KAE/D,IAAK,GAAG,CACN,KAAM,CAAE,KAAA0O,EAAM,UAAAO,CAAS,EAAK,KAE5B,GAAIP,IAAS4E,EACX,MAAM,IAAI,MAAM,0CAA0C,EAI5D,GAAIrE,EAAU,OAASsE,GACrB,MAAM,IAAI,MAAM,oDAAoD,EAGtE,OACEF,EAAI,SAC+CpE,CAClD,CAEJ,CACD,QACE,MAAM,MACJ,+BAA+B,KAAK,mDACrC,CAEJ,CACF,CAKD,MAAQ,CACN,OAAQ,KAAK,QAAO,CAClB,IAAK,GAAG,CACN,KAAM,CAAE,KAAAP,EAAM,OAAA5E,CAAQ,EAAG,KAAK,UACxBmF,EAAYuE,EAAc9E,EAAM5E,CAAM,EAC5C,OACEuJ,EAAI,SAAS,KAAK,KAAMpE,CAAS,CAEpC,CACD,IAAK,GACH,OAAiD,KAEnD,QACE,MAAM,MACJ,+BAA+B,KAAK,mDACrC,CAEJ,CACF,CAMD,OAAQxN,EAAO,CACb,OAAO4R,EAAI,OAAO,KAAM5R,CAAK,CAC9B,CAWD,OAAO,OAAQgS,EAAMhS,EAAO,CAC1B,MAAMiS,EAEFjS,EAEJ,OACEiS,GACAD,EAAK,OAASC,EAAQ,MACtBD,EAAK,UAAYC,EAAQ,SACzBC,GAAcF,EAAK,UAAWC,EAAQ,SAAS,CAElD,CAMD,SAAUtE,EAAM,CACd,OAAOyD,GAAO,KAAMzD,CAAI,CACzB,CAED,QAAU,CACR,MAAO,CACL,KAAM,KAAK,KACX,QAAS,KAAK,QACd,KAAM,KAAK,UAAU,KACtB,CACF,CAED,MAAQ,CACN,OAAO,IACR,CAED,IAAK,OAAO,WAAW,GAAK,CAC1B,MAAO,KACR,CAID,CAAC,OAAO,IAAI,4BAA4B,CAAC,GAAK,CAC5C,MAAO,OAAO,KAAK,SAAQ,IAC5B,CAoBD,OAAO,MAAOhD,EAAO,CACnB,GAAIA,GAAS,KACX,OAAO,KAGT,MAAM1M,EAA4B0M,EAClC,GAAI1M,aAAiB2T,EAEnB,OAAO3T,EACF,GAAKA,EAAM,GAAG,GAAK,MAAQA,EAAM,GAAG,IAAMA,EAAM,OAAUA,EAAM,QAAUA,EAAO,CAMtF,KAAM,CAAE,QAAAqT,EAAS,KAAArE,EAAM,UAAAO,EAAW,MAAAjP,CAAO,EAAGN,EAC5C,OAAO,IAAI2T,EACTN,EACArE,EACyCO,EACzCjP,GAAS4T,GAAUb,EAASrE,EAAMO,EAAU,KAAK,CAClD,CACF,SAAUvP,EAAMmU,EAAS,IAAM,GAAM,CAIpC,KAAM,CAAE,QAAAd,EAAS,UAAA9D,EAAW,KAAAP,CAAM,EAAGhP,EAC/BoK,EAEHgK,GAAc7E,CAAS,EAC1B,OAAOoE,EAAI,OAAON,EAASrE,EAAM5E,CAAM,CAC7C,KAGM,QAAO,IAEV,CAaD,OAAO,OAAQiJ,EAASrE,EAAM5E,EAAQ,CACpC,GAAI,OAAO4E,GAAS,SAClB,MAAM,IAAI,MAAM,uCAAuC,EAGzD,GAAI,EAAE5E,EAAO,iBAAiB,YAC5B,MAAM,IAAI,MAAM,gBAAgB,EAGlC,OAAQiJ,EAAO,CACb,IAAK,GAAG,CACN,GAAIrE,IAAS4E,EACX,MAAM,IAAI,MACR,wCAAwCA,mBACzC,EAED,OAAO,IAAID,EAAIN,EAASrE,EAAM5E,EAAQA,EAAO,KAAK,CAErD,CACD,IAAK,GAAG,CACN,MAAM9J,EAAQ4T,GAAUb,EAASrE,EAAM5E,EAAO,KAAK,EACnD,OAAO,IAAIuJ,EAAIN,EAASrE,EAAM5E,EAAQ9J,CAAK,CAC5C,CACD,QACE,MAAM,IAAI,MAAM,iBAAiB,CAEpC,CACF,CASD,OAAO,SAAU8J,EAAQ,CACvB,OAAOuJ,EAAI,OAAO,EAAGC,EAAaxJ,CAAM,CACzC,CAYD,OAAO,SAAU4E,EAAM5E,EAAQ,CAC7B,OAAOuJ,EAAI,OAAO,EAAG3E,EAAM5E,CAAM,CAClC,CAgBD,OAAO,OAAQ9J,EAAO,CACpB,KAAM,CAACoT,EAAKW,CAAS,EAAIV,EAAI,YAAYrT,CAAK,EAC9C,GAAI+T,EAAU,OACZ,MAAM,IAAI,MAAM,kBAAkB,EAEpC,OAAOX,CACR,CAkBD,OAAO,YAAapT,EAAO,CACzB,MAAMgU,EAAQX,EAAI,aAAarT,CAAK,EAC9BiU,EAAaD,EAAM,KAAOA,EAAM,cAChCE,EAAiB9F,GACrBpO,EAAM,SAASiU,EAAYA,EAAaD,EAAM,aAAa,CAC5D,EACD,GAAIE,EAAe,aAAeF,EAAM,cACtC,MAAM,IAAI,MAAM,kBAAkB,EAEpC,MAAMG,EAAcD,EAAe,SACjCF,EAAM,cAAgBA,EAAM,UAC7B,EACKlK,EAAS,IAAIsK,GACjBJ,EAAM,cACNA,EAAM,WACNG,EACAD,CACD,EAKD,MAAO,CAHLF,EAAM,UAAY,EACdX,EAAI,SAA0DvJ,CAAQ,EACtEuJ,EAAI,SAASW,EAAM,MAAOlK,CAAM,EACO9J,EAAM,SAASgU,EAAM,IAAI,CAAC,CACxE,CAkBD,OAAO,aAAcK,EAAc,CACjC,IAAI/U,EAAS,EACb,MAAMkD,EAAO,IAAM,CACjB,KAAM,CAACzC,EAAGF,CAAM,EAAIqP,GAAcmF,EAAa,SAAS/U,CAAM,CAAC,EAC/D,OAAAA,GAAUO,EACHE,CACR,EAED,IAAIgT,EAA4BvQ,IAC5B8R,EAA0BhB,EAS9B,GAR0BP,IAAa,IAErCA,EAA4B,EAC5BzT,EAAS,GAETgV,EAA0B9R,EAAI,EAG5BuQ,IAAY,GAAKA,IAAY,EAC/B,MAAM,IAAI,WAAW,uBAAuBA,GAAS,EAGvD,MAAMkB,EAAa3U,EACbiV,EAAkC/R,IAClCgS,EAAahS,EAAM,EACnBmM,EAAOrP,EAASkV,EAChBC,EAAgB9F,EAAOsF,EAE7B,MAAO,CAAE,QAAAlB,EAAS,MAAAuB,EAAO,cAAAC,EAAe,WAAAC,EAAY,cAAAC,EAAe,KAAA9F,CAAM,CAC1E,CAiBD,OAAO,MAAO7M,EAAQsN,EAAM,CAC1B,KAAM,CAAC2B,EAAQ/Q,CAAK,EAAI0U,GAAgB5S,EAAQsN,CAAI,EAE9CgE,EAAMC,EAAI,OAAOrT,CAAK,EAG5B,OAAAiT,GAAUG,CAAG,EAAE,IAAIrC,EAAQjP,CAAM,EAE1BsR,CACR,CACH,CAYA,MAAMsB,GAAkB,CAAC5S,EAAQsN,IAAS,CACxC,OAAQtN,EAAO,CAAC,EAAC,CAEf,IAAK,IAAK,CACR,MAAMsP,EAAUhC,GAAQ8C,EACxB,MAAO,CACkBA,EAAU,OACjCd,EAAQ,OAAO,GAAGc,EAAU,SAASpQ,GAAQ,CAC9C,CACF,CACD,KAAKoQ,EAAU,OAAQ,CACrB,MAAMd,EAAUhC,GAAQ8C,EACxB,MAAO,CAAuBA,EAAU,OAASd,EAAQ,OAAOtP,CAAM,CAAC,CACxE,CACD,KAAKsQ,EAAO,OAAQ,CAClB,MAAMhB,EAAUhC,GAAQgD,EACxB,MAAO,CAAuBA,EAAO,OAAShB,EAAQ,OAAOtP,CAAM,CAAC,CACrE,CACD,QAAS,CACP,GAAIsN,GAAQ,KACV,MAAM,MACJ,iFACD,EAEH,MAAO,CAAuBtN,EAAO,CAAC,EAAIsN,EAAK,OAAOtN,CAAM,CAAC,CAC9D,CACF,CACH,EAQMkR,GAAa,CAAChT,EAAOmT,EAAO/D,IAAS,CACzC,KAAM,CAAE,OAAA2B,CAAM,EAAK3B,EACnB,GAAI2B,IAAWmB,EAAU,OACvB,MAAM,MAAM,8BAA8B9C,EAAK,eAAe,EAGhE,MAAMgE,EAAMD,EAAM,IAAIpC,CAAM,EAC5B,GAAIqC,GAAO,KAAM,CACf,MAAMA,EAAMhE,EAAK,OAAOpP,CAAK,EAAE,MAAM,CAAC,EACtC,OAAAmT,EAAM,IAAIpC,EAAQqC,CAAG,EACdA,CACX,KACI,QAAOA,CAEX,EAQMF,GAAa,CAAClT,EAAOmT,EAAO/D,IAAS,CACzC,KAAM,CAAE,OAAA2B,CAAM,EAAK3B,EACbgE,EAAMD,EAAM,IAAIpC,CAAM,EAC5B,GAAIqC,GAAO,KAAM,CACf,MAAMA,EAAMhE,EAAK,OAAOpP,CAAK,EAC7B,OAAAmT,EAAM,IAAIpC,EAAQqC,CAAG,EACdA,CACX,KACI,QAAOA,CAEX,EAEME,EAAc,IACdC,GAAe,GAQfK,GAAY,CAACb,EAASrE,EAAMO,IAAc,CAC9C,MAAM0F,EAAa9F,GAAsBkE,CAAO,EAC1C6B,EAAaD,EAAa9F,GAAsBH,CAAI,EACpD1O,EAAQ,IAAI,WAAW4U,EAAa3F,EAAU,UAAU,EAC9DF,OAAAA,GAAgBgE,EAAS/S,EAAO,CAAC,EACjC+O,GAAgBL,EAAM1O,EAAO2U,CAAU,EACvC3U,EAAM,IAAIiP,EAAW2F,CAAU,EACxB5U,CACT,EAEM6T,GAAY,OAAO,IAAI,kBAAkB,EC9jBlCgB,GAAWnD,GAAK,CAC3B,OAAQ,KACR,KAAM,WACN,OAASnS,GAAQiP,GAASjP,CAAG,EAC7B,OAASgP,GAAQD,GAAWC,CAAG,CACjC,CAAC,4GCNYuG,GAAQ7C,EAAQ,CAC3B,OAAQ,IACR,KAAM,QACN,SAAU,KACV,YAAa,CACf,CAAC,yGCLY8C,GAAQ9C,EAAQ,CAC3B,OAAQ,IACR,KAAM,QACN,SAAU,WACV,YAAa,CACf,CAAC,yGCPY+C,GAASrD,EAAM,CAC1B,OAAQ,IACR,KAAM,SACN,SAAU,YACZ,CAAC,0GCFYsD,GAAShD,EAAQ,CAC5B,OAAQ,IACR,KAAM,SACN,SAAU,mBACV,YAAa,CACf,CAAC,EAEYiD,GAAcjD,EAAQ,CACjC,OAAQ,IACR,KAAM,cACN,SAAU,mBACV,YAAa,CACf,CAAC,yHCdYkD,GAASxD,EAAM,CAC1B,OAAQ,IACR,KAAM,SACN,SAAU,sCACZ,CAAC,EAEYyD,GAAczD,EAAM,CAC/B,OAAQ,IACR,KAAM,cACN,SAAU,sCACZ,CAAC,yHCRY0D,GAASpD,EAAQ,CAC5B,OAAQ,IACR,KAAM,SACN,SAAU,mEACV,YAAa,CACf,CAAC,EAEYqD,GAAYrD,EAAQ,CAC/B,OAAQ,IACR,KAAM,YACN,SAAU,oEACV,YAAa,CACf,CAAC,EAEYsD,GAAYtD,EAAQ,CAC/B,OAAQ,IACR,KAAM,YACN,SAAU,mEACV,YAAa,CACf,CAAC,EAEYuD,GAAevD,EAAQ,CAClC,OAAQ,IACR,KAAM,eACN,SAAU,oEACV,YAAa,CACf,CAAC,oJC5BKL,GAAW,MAAM,KAAK,weAAwe,EAC9f6D,GAAgD7D,GAAS,OAAO,CAACrJ,EAAGzH,EAAGf,KAAQwI,EAAExI,CAAC,EAAIe,EAAUyH,GAA6B,CAAE,CAAA,EAC/HmN,GAAgD9D,GAAS,OAAO,CAACrJ,EAAGzH,EAAGf,KAAQwI,EAAyBzH,EAAE,YAAY,CAAC,GAAMf,EAAUwI,GAA6B,CAAA,GAM1K,SAAS1C,GAAQjG,EAAM,CACrB,OAAOA,EAAK,OAAO,CAAC2I,EAAGzH,KACrByH,GAAKkN,GAAqB3U,CAAC,EACpByH,GACN,EAAE,CACP,CAMA,SAASpC,GAAQoI,EAAK,CACpB,MAAMoH,EAAO,CAAE,EACf,UAAWvU,KAAQmN,EAAK,CACtB,MAAMqH,EAAMF,GAA4CtU,EAAK,YAAY,CAAC,CAAG,EAC7E,GAAIwU,IAAQ,OACV,MAAM,IAAI,MAAM,+BAA+BxU,GAAM,EAEvDuU,EAAK,KAAKC,CAAG,CACd,CACD,OAAO,IAAI,WAAWD,CAAI,CAC5B,CAEO,MAAME,GAAenE,GAAK,CAC/B,OAAQ,KACR,KAAM,eACR,OAAE7L,GACA,OAAAM,EACF,CAAC,gHC5BYuL,GAAO,CAAC,CAAE,KAAApC,EAAM,KAAAZ,EAAM,OAAA7I,KAAa,IAAIiQ,GAAOxG,EAAMZ,EAAM7I,CAAM,EAWtE,MAAMiQ,EAAO,CAOlB,YAAaxG,EAAMZ,EAAM7I,EAAQ,CAC/B,KAAK,KAAOyJ,EACZ,KAAK,KAAOZ,EACZ,KAAK,OAAS7I,CACf,CAMD,OAAQuG,EAAO,CACb,GAAIA,aAAiB,WAAY,CAC/B,MAAM2J,EAAS,KAAK,OAAO3J,CAAK,EAChC,OAAO2J,aAAkB,WACrBvC,EAAc,KAAK,KAAMuC,CAAM,EAE/BA,EAAO,KAAKjM,GAAU0J,EAAc,KAAK,KAAM1J,CAAM,CAAC,CAChE,KACM,OAAM,MAAM,mCAAmC,CAGlD,CACH,CC3CA,MAAMkM,GAAM1G,GAIV,MAAM1P,GAAQ,IAAI,WAAW,MAAM,OAAO,OAAO,OAAO0P,EAAM1P,CAAI,CAAC,EAExDqW,GAASvE,GAAK,CACzB,KAAM,WACN,KAAM,GACN,OAAQsE,GAAI,SAAS,CACvB,CAAC,EAEqBtE,GAAK,CACzB,KAAM,WACN,KAAM,GACN,OAAQsE,GAAI,SAAS,CACvB,CAAC,ECpBD,MAAMtH,GAAO,EACPY,GAAO,WAGPzJ,GAASuI,GAMTtE,GAAUsC,GAAUoH,EAAc9E,GAAM7I,GAAOuG,CAAK,CAAC,EAE9CyI,GAAW,CAAE,KAAAnG,GAAM,KAAAY,GAAM,OAAAzJ,GAAQ,OAAAiE,EAAM,ECRhC,IAAI,YACJ,IAAI,YCYxB,MAAMoM,GAAQ,CAAE,GAAGC,GAAc,GAAGrB,GAAO,GAAGC,GAAO,GAAGC,GAAQ,GAAGC,GAAQ,GAAG7C,GAAQ,GAAG+C,GAAQ,GAAGiB,GAAQ,GAAGf,GAAQ,GAAGQ,EAAY,ECpBzH3W,GAAS,OAAO,IAAI,iBAAiB,EAC3C,SAASmX,GAAS5U,EAAO,CAC5B,OAAOA,GAAS,MAAQ,QAAQA,EAAMvC,EAAM,CAAC,CACjD,CCMA,MAAMoX,GAAU,OAAO,IAAI,4BAA4B,EACjDC,GAAc,OACf,OAAOL,EAAK,EACZ,IAAI5B,GAASA,EAAM,OAAO,EAE1B,OAAO,CAAC3S,EAAKC,IAASD,EAAI,GAAGC,CAAI,EAAGsU,GAAM,SAAS,OAAO,EAEzDM,GAAkB,IAClBC,GAAwC,GACxCC,GAAyC,GAC/C,MAAMC,EAAW,CACb,YAAYC,EAAM,CACd,KAAK,KAAOA,EAAK,KACjB,KAAK,UAAYA,EAAK,UACtB,KAAK,WAAaA,EAAK,WAEvB,OAAO,eAAe,KAAM,SAAU,CAClC,WAAY,GACZ,SAAU,EACtB,CAAS,CACJ,CACD,IAAK,OAAO,WAAW,GAAI,CACvB,MAAO,UAAU,KAAK,SAAU,IACnC,CACD,IAAK1X,EAAM,GAAI,CACX,MAAO,EACV,CACD,UAAW,CACP,OAAI,KAAK,QAAU,OACf,KAAK,OAASgT,EAAU,OAAO,KAAK,UAAU,KAAK,EAAE,MAAM,CAAC,GAEzD,KAAK,MACf,CAGD,OAAQ,CACJ,OAAOmB,EAAI,SAASmD,GAAiB,KAAK,SAAS,CACtD,CACD,SAAU,CACN,OAAO,KAAK,UAAU,KACzB,CAID,QAAS,CACL,OAAO,KAAK,UACf,CAID,OAAOK,EAAI,CACP,GAAIA,aAAc,WACd,OAAOC,GAAiB,KAAK,UAAU,MAAOD,CAAE,EAE/C,GAAI,OAAOA,GAAO,SACnB,OAAOE,GAAiBF,CAAE,EAAE,OAAO,IAAI,EAEtC,GAAIA,GAAI,WAAW,OAAS,KAC7B,OAAOC,GAAiB,KAAK,UAAU,MAAOD,EAAG,UAAU,KAAK,EAGhE,MAAM,IAAI,MAAM,cAAc,CAErC,CAaD,CAACP,EAAO,GAAI,CACR,MAAO,UAAU,KAAK,SAAU,IACnC,CACL,CACA,MAAMU,UAAsBL,EAAW,CACnC,YAAYC,EAAM,CACd,MAAM,CAAE,GAAGA,EAAM,KAAM,KAAO,CAAA,EAC9B,KAAK,KAAO,MACZ,KAAK,UAAYA,EAAK,SACzB,CACL,CACA,MAAMK,UAA0BN,EAAW,CACvC,YAAYC,EAAM,CACd,MAAM,CAAE,GAAGA,EAAM,KAAM,SAAW,CAAA,EAClC,KAAK,KAAO,UACZ,KAAK,UAAYA,EAAK,UAAU,MACnC,CACL,CACA,MAAMM,UAA4BP,EAAW,CACzC,YAAYC,EAAM,CACd,MAAM,CAAE,GAAGA,EAAM,KAAM,WAAa,CAAA,EACpC,KAAK,KAAO,YACZ,KAAK,UAAYA,EAAK,UAAU,MACnC,CACL,CAaO,SAASO,GAAiB1V,EAAO,CACpC,GAAIA,EAAM,OAAS,MACf,OAAO,IAAIuV,EAAcvV,CAAK,EAElC,GAAIA,EAAM,OAAS,UACf,OAAO,IAAIwV,EAAkBxV,CAAK,EAEtC,GAAIA,EAAM,OAAS,YACf,OAAO,IAAIyV,EAAoBzV,CAAK,EAExC,MAAM2V,EAAQ,IAAI,MAAM,cAAc,EAAG,wBAAwB,CACrE,CACO,SAASL,GAAiBxI,EAAK6C,EAAS,CAE3C,GAAI7C,EAAI,OAAO,CAAC,IAAM,KAAOA,EAAI,OAAO,CAAC,IAAM,IAAK,CAGhD,MAAMU,EAAY6E,GAAc5B,EAAU,OAAO,IAAI3D,GAAK,CAAC,EAC3D,OAAIA,EAAI,WAAW,KAAK,EACb,IAAI0I,EAAkB,CAAE,UAAAhI,CAAS,CAAE,EAErCV,EAAI,WAAW,KAAK,EAClB,IAAI2I,EAAoB,CAAE,UAAAjI,CAAS,CAAE,EAGrC,IAAI+H,EAAc,CAAE,UAAA/H,CAAS,CAAE,CAE7C,CACD,OAAOoI,GAAgBd,GAAY,OAAOhI,CAAG,CAAC,CAClD,CACO,SAAS8I,GAAgB9X,EAAK,CACjC,GAAI,CACA,MAAM0P,EAAY6E,GAAcvU,CAAG,EACnC,GAAI0P,EAAU,OAAS4F,GAAS,KAAM,CAClC,GAAI5F,EAAU,OAAO,SAAWwH,GAC5B,OAAO,IAAIQ,EAAkB,CAAE,UAAAhI,CAAS,CAAE,EAEzC,GAAIA,EAAU,OAAO,SAAWyH,GACjC,OAAO,IAAIQ,EAAoB,CAAE,UAAAjI,CAAS,CAAE,CAEnD,CACD,GAAIA,EAAU,OAASgH,GAAO,KAC1B,OAAO,IAAIe,EAAc,CAAE,UAAA/H,CAAS,CAAE,CAE7C,MACD,CACI,OAAOqI,GAAcjE,EAAI,OAAO9T,CAAG,CAAC,CACvC,CACD,MAAM,IAAI,MAAM,gCAAgC,CACpD,CACO,SAAS+X,GAAclE,EAAK,CAC/B,GAAIA,GAAO,MAAQA,EAAI,WAAa,MAAQA,EAAI,SAAW,MAASA,EAAI,UAAY,GAAKA,EAAI,OAASoD,GAClG,MAAM,IAAI,MAAM,gCAAgC,EAEpD,MAAMvH,EAAYmE,EAAI,UACtB,GAAInE,EAAU,OAASgH,GAAO,KAC1B,OAAO,IAAIe,EAAc,CAAE,UAAW5D,EAAI,SAAW,CAAA,EAEpD,GAAInE,EAAU,OAAS4F,GAAS,KAAM,CACvC,GAAI5F,EAAU,OAAO,SAAWwH,GAC5B,OAAO,IAAIQ,EAAkB,CAAE,UAAW7D,EAAI,SAAW,CAAA,EAExD,GAAInE,EAAU,OAAO,SAAWyH,GACjC,OAAO,IAAIQ,EAAoB,CAAE,UAAW9D,EAAI,SAAW,CAAA,CAElE,CACD,MAAM,IAAI,MAAM,gCAAgC,CACpD,CAKO,eAAemE,GAAerM,EAAWD,EAAY,CACxD,OAAIC,EAAU,SAAWuL,GACd,IAAIQ,EAAkB,CAAE,UAAWzD,EAAcqB,GAAS,KAAM3J,CAAS,EAAG,WAAAD,CAAU,CAAE,EAE/FC,EAAU,SAAWwL,GACd,IAAIQ,EAAoB,CAAE,UAAW1D,EAAcqB,GAAS,KAAM3J,CAAS,EAAG,WAAAD,CAAU,CAAE,EAE9F,IAAI+L,EAAc,CAAE,UAAW,MAAMf,GAAO,OAAO/K,CAAS,EAAG,UAAAA,EAAW,WAAAD,CAAU,CAAE,CACjG,CCrMO,IAAIuM,IACV,SAAUA,EAAiB,CACxB,IAAIC,EACJD,EAAgB,MAAQ,KAChBC,GAAU,OACVA,EAAS1L,GAAQ,CAAC1J,EAAKqV,EAAGzQ,EAAO,CAAA,IAAO,CAIpC,GAHIA,EAAK,kBAAoB,IACzByQ,EAAE,KAAI,EAENrV,EAAI,wBAA0B,KAC9B,UAAW3C,KAAS2C,EAAI,uBACpBqV,EAAE,OAAO,EAAE,EACXA,EAAE,MAAMhY,CAAK,EAGjBuH,EAAK,kBAAoB,IACzByQ,EAAE,OAAM,CAE5B,EAAe,CAAC7V,EAAQhC,IAAW,CACnB,MAAMwC,EAAM,CACR,uBAAwB,CAAE,CAC9C,EACsBoB,EAAM5D,GAAU,KAAOgC,EAAO,IAAMA,EAAO,IAAMhC,EACvD,KAAOgC,EAAO,IAAM4B,GAAK,CACrB,MAAMkU,EAAM9V,EAAO,SACnB,OAAQ8V,IAAQ,EAAC,CACb,IAAK,GACDtV,EAAI,uBAAuB,KAAKR,EAAO,MAAO,CAAA,EAC9C,MACJ,QACIA,EAAO,SAAS8V,EAAM,CAAC,EACvB,KACP,CACJ,CACD,OAAOtV,CACvB,CAAa,GAEEoV,GAEXD,EAAgB,OAAUnV,GACfuV,GAAcvV,EAAKmV,EAAgB,MAAO,CAAA,EAErDA,EAAgB,OAAUjY,GACfsY,GAActY,EAAKiY,EAAgB,MAAO,CAAA,CAEzD,GAAGA,KAAoBA,GAAkB,CAAE,EAAC,EACrC,IAAIM,IACV,SAAUA,EAAuB,CAC9B,IAAIL,EACJK,EAAsB,MAAQ,KACtBL,GAAU,OACVA,EAAS1L,GAAQ,CAAC1J,EAAKqV,EAAGzQ,EAAO,CAAA,IAAO,CAChCA,EAAK,kBAAoB,IACzByQ,EAAE,KAAI,GAENzQ,EAAK,gBAAkB,IAAS5E,EAAI,aAAe,MAAQA,EAAI,YAAY,WAAa,KACxFqV,EAAE,OAAO,EAAE,EACXA,EAAE,MAAMrV,EAAI,WAAW,IAEvB4E,EAAK,gBAAkB,IAAS5E,EAAI,aAAe,MAAQA,EAAI,YAAY,WAAa,KACxFqV,EAAE,OAAO,EAAE,EACXA,EAAE,MAAMrV,EAAI,WAAW,GAEvBA,EAAI,YAAc,OAClBqV,EAAE,OAAO,EAAE,EACXF,GAAgB,MAAK,EAAG,OAAOnV,EAAI,WAAYqV,EAAG,CAC9C,cAAe,EACvC,CAAqB,GAEDzQ,EAAK,kBAAoB,IACzByQ,EAAE,OAAM,CAE5B,EAAe,CAAC7V,EAAQhC,IAAW,CACnB,MAAMwC,EAAM,CACR,YAAa,IAAI,WAAW,CAAC,EAC7B,YAAa,IAAI,WAAW,CAAC,CACjD,EACsBoB,EAAM5D,GAAU,KAAOgC,EAAO,IAAMA,EAAO,IAAMhC,EACvD,KAAOgC,EAAO,IAAM4B,GAAK,CACrB,MAAMkU,EAAM9V,EAAO,SACnB,OAAQ8V,IAAQ,EAAC,CACb,IAAK,GACDtV,EAAI,YAAcR,EAAO,QACzB,MACJ,IAAK,GACDQ,EAAI,YAAcR,EAAO,QACzB,MACJ,IAAK,GACDQ,EAAI,WAAamV,GAAgB,MAAO,EAAC,OAAO3V,EAAQA,EAAO,OAAM,CAAE,EACvE,MACJ,QACIA,EAAO,SAAS8V,EAAM,CAAC,EACvB,KACP,CACJ,CACD,OAAOtV,CACvB,CAAa,GAEEoV,GAEXK,EAAsB,OAAUzV,GACrBuV,GAAcvV,EAAKyV,EAAsB,MAAO,CAAA,EAE3DA,EAAsB,OAAUvY,GACrBsY,GAActY,EAAKuY,EAAsB,MAAO,CAAA,CAE/D,GAAGA,KAA0BA,GAAwB,CAAA,EAAG,EC1GjD,eAAeC,GAAWC,EAAWC,EAAiBC,EAAY,CACrE,MAAMC,EAAgB,MAAMC,GAAYJ,EAAWK,GAAoBJ,CAAe,CAAC,EACvF,GAAID,EAAU,WAAa,KACvB,MAAM,IAAI,MAAM,yCAAyC,EAE7D,OAAOM,GAAuBN,EAAU,UAAWG,EAAeD,CAAU,CAChF,CACO,SAASI,GAAuBC,EAAiBJ,EAAeD,EAAY,CAC/E,OAAOJ,GAAsB,OAAO,CAChC,YAAaS,EACb,YAAaJ,EACb,WAAYD,GAAc,CAAE,uBAAwB,EAAI,CAChE,CAAK,EAAE,SAAQ,CACf,CACO,eAAeE,GAAYI,EAAQC,EAAS,CAC/C,GAAID,EAAO,YAAc,KACrB,MAAM,IAAI,MAAM,oCAAoC,EAGxD,OAAO,MADY,MAAME,GAAoBF,EAAO,UAAU,GACtC,KAAKC,CAAO,CACxC,CACO,eAAeE,GAAqBF,EAAS,CAChD,OAAO,MAAMlB,GAAekB,EAAQ,WAAW,CACnD,CACO,SAASG,GAAcH,EAAS,CACnC,OAAOX,GAAsB,OAAOW,CAAO,CAC/C,CACO,SAASJ,GAAoBnN,EAAW,CAC3C,MAAM6F,EAAS8H,GAAqB,0BAA0B,EAC9D,OAAO7M,EAAiB,CAAC+E,EAAQ7F,CAAS,EAAG6F,EAAO,OAAS7F,EAAU,MAAM,CACjF,CASO,eAAe4N,GAAoBC,EAAgBN,EAASO,EAAY,CAE3E,MAAMC,EAAgB,MAAM1B,GAAekB,EAAQ,WAAW,EAC9D,GAAI,CAACQ,EAAc,OAAOD,CAAU,EAChC,MAAM,IAAI,MAAM,0CAA0C,EAE9D,MAAME,EAAmBb,GAAoBU,CAAc,EAC3D,GAAIE,EAAc,WAAa,KAC3B,MAAM,IAAI,MAAM,mCAAmC,EAEvD,GAAIR,EAAQ,aAAe,KACvB,MAAM,IAAI,MAAM,oCAAoC,EAIxD,GAAI,CADU,MADIU,GAAmBF,EAAc,SAAS,EAC9B,OAAOC,EAAkBT,EAAQ,WAAW,EAEtE,MAAM,IAAI,MAAM,uDAAuD,EAE3E,OAAOQ,CACX,CACO,SAASG,EAAiBC,EAAI,CAIjC,MAHI,IAAEA,aAAc,aAGhBA,EAAG,SAAW,GAItB,CCrEA,MAAMC,EAAMC,GAAO,cAAc,EAEjC,IAAIC,EACA3Q,GACA2Q,EAAYF,EAGZE,EAAY,OAAO,OAAO,IAAM,GAAK,CACjC,QAAS,GACT,MAAO,IAAM,CAAG,EAChB,MAAO,IAAM,CAAG,CACxB,CAAK,EAEE,SAASC,GAAmBC,EAAG,CAClCF,EAAU,2BAA2BG,EAAmBD,EAAE,UAAW,KAAK,GAAG,EAC7EF,EAAU,4BAA4BG,EAAmBD,EAAE,WAAY,KAAK,GAAG,CACnF,CACO,SAASE,GAAsBC,EAAG,CACjCA,GACAL,EAAU,8BAA8BG,EAAmBE,EAAE,UAAW,KAAK,GAAG,EAChFL,EAAU,+BAA+BG,EAAmBE,EAAE,WAAY,KAAK,GAAG,GAGlFL,EAAU,+BAA+B,CAEjD,CACO,SAASM,GAAmBC,EAAI,CACnCP,EAAU,4BAA4BG,EAAmBI,EAAI,KAAK,GAAG,CACzE,CACO,SAASC,GAAsBC,EAAI,CACtCT,EAAU,+BAA+BG,EAAmBM,EAAI,KAAK,GAAG,CAC5E,CACO,SAASC,GAAeC,EAAS,CAChCA,EAAQ,KAAOA,EAAQ,KACvBX,EAAU,kBAAkBW,EAAQ,IAAI,EAAE,UAAW,KAAIR,EAAmBQ,EAAQ,IAAI,EAAG,KAAK,GAAG,EACnGX,EAAU,kBAAkBW,EAAQ,IAAI,EAAE,UAAW,KAAIR,EAAmBQ,EAAQ,IAAI,EAAG,KAAK,GAAG,GAGnGX,EAAU,uBAAuB,CAEzC,CC3CO,MAAMY,GAAY,EAOZC,GAAY,WACnBC,GAAgB,uEAKf,MAAMC,EAAM,CACf,YAAYC,EAAIJ,GAAW,CACvB,KAAK,EAAII,EACT,KAAK,MAAQ,IAAI,WAAW,EAAE,EAC9B,KAAK,KAAO,IAAI,SAAS,KAAK,MAAM,OAAQ,KAAK,MAAM,WAAY,KAAK,MAAM,UAAU,EACxF,KAAK,KAAK,UAAU,EAAGA,EAAG,EAAI,CACjC,CACD,WAAY,CACR,KAAK,IAEL,KAAK,KAAK,UAAU,EAAG,KAAK,EAAG,EAAI,CACtC,CACD,UAAW,CACP,OAAO,KAAK,KACf,CACD,WAAY,CACR,OAAO,KAAK,CACf,CACD,aAAc,CACV,GAAI,KAAK,EAAIH,GACT,MAAM,IAAI,MAAMC,EAAa,CAEpC,CACL,CC/BO,MAAMG,EAAkB,CAC3B,YAAYC,EAAQ,CAChB,KAAK,OAASA,CACjB,CACD,cAAcC,EAAIrP,EAAIF,EAAW,CAC7B,MAAMyO,EAAI,KAAK,QAAQc,EAAG,EAAGA,EAAG,EAAGrP,EAAIF,CAAS,EAChD,OAAAuP,EAAG,EAAE,YACEd,CACV,CACD,cAAcc,EAAIrP,EAAIG,EAAYC,EAAK,CACnC,KAAM,CAAE,UAAAN,EAAW,MAAAyB,GAAU,KAAK,QAAQ8N,EAAG,EAAGA,EAAG,EAAGrP,EAAIG,EAAYC,CAAG,EACzE,OAAImB,GACA8N,EAAG,EAAE,YACF,CAAE,UAAAvP,EAAW,MAAAyB,EACvB,CAED,OAAO8N,EAAI,CACP,MAAO,CAAC,KAAK,WAAWA,EAAG,CAAC,CAC/B,CACD,gBAAiB,CACb,OAAO,IAAI,WAAW,EAAE,CAC3B,CACD,WAAWpP,EAAG,CACV,MAAMqP,EAAW,KAAK,iBACtB,OAAO9D,GAAiB8D,EAAUrP,CAAC,CACtC,CACD,QAAQA,EAAGiP,EAAGlP,EAAIF,EAAW,CACzB,OAAAoP,EAAE,YAAW,EACN,KAAK,OAAO,wBAAwBpP,EAAWoP,EAAE,SAAU,EAAElP,EAAIC,CAAC,CAC5E,CACD,eAAesP,EAAIzP,EAAW,CAC1B,IAAIK,EACJ,OAAI,KAAK,OAAOoP,EAAG,EAAE,EACjBpP,EAAa,KAAK,cAAcoP,EAAG,GAAIA,EAAG,EAAGzP,CAAS,EAGtDK,EAAaL,EAEjB,KAAK,QAAQyP,EAAIpP,CAAU,EACpBA,CACV,CACD,QAAQF,EAAGiP,EAAGlP,EAAIG,EAAYC,EAAK,CAC/B8O,EAAE,YAAW,EACb,MAAMM,EAAmB,KAAK,OAAO,wBAAwBrP,EAAY+O,EAAE,WAAYlP,EAAIC,EAAGG,CAAG,EACjG,OAAIoP,EACO,CACH,UAAWA,EACX,MAAO,EACvB,EAGmB,CACH,UAAW,IAAI,WAAW,CAAC,EAC3B,MAAO,EACvB,CAEK,CACD,eAAeD,EAAIpP,EAAY,CAC3B,IAAIL,EACAyB,EAAQ,GACZ,OAAI,KAAK,OAAOgO,EAAG,EAAE,EAChB,CAAE,UAAAzP,EAAW,MAAAyB,CAAO,EAAG,KAAK,cAAcgO,EAAG,GAAIA,EAAG,EAAGpP,CAAU,EAGlEL,EAAYK,EAEhB,KAAK,QAAQoP,EAAIpP,CAAU,EACpB,CAAE,UAAAL,EAAW,MAAAyB,EACvB,CACD,GAAG5B,EAAYC,EAAW,CACtB,GAAI,CACA,MAAM6P,EAAY,KAAK,OAAO,wBAAwB9P,EAAYC,CAAS,EAC3E,OAAI6P,EAAU,SAAW,GACdA,EAEJA,EAAU,SAAS,EAAG,EAAE,CAClC,OACMlB,EAAP,CAEIN,OAAAA,EADYM,EACD,OAAO,EACX,IAAI,WAAW,EAAE,CAC3B,CACJ,CACD,QAAQgB,EAAIjb,EAAM,CACdib,EAAG,EAAI,KAAK,QAAQA,EAAG,EAAGjb,CAAI,CACjC,CACD,QAAQgI,EAAGC,EAAG,CAEV,OADU,KAAK,OAAO,WAAWmE,EAAiB,CAACpE,EAAGC,CAAC,EAAGD,EAAE,OAASC,EAAE,MAAM,CAAC,CAEjF,CACD,OAAOgT,EAAIrQ,EAAK,CACZ,KAAM,CAACD,EAAIyQ,CAAK,EAAI,KAAK,OAAO,QAAQH,EAAG,GAAIrQ,CAAG,EAClDqQ,EAAG,GAAK,KAAK,cAAcG,CAAK,EAChCH,EAAG,GAAKtQ,CACX,CACD,cAAcgB,EAAG,CACb,MAAO,CAAE,EAAAA,EAAG,EAAG,IAAIgP,EAAO,CAC7B,CAED,oBAAoBU,EAAc,CAC9B,MAAMC,EAAoBrC,GAAqBoC,EAAc,OAAO,EAC9DjS,EAAI,KAAK,iBAAiBkS,CAAiB,EAC3C3Q,EAAKvB,EACLS,EAAM,KAAK,iBAEjB,MAAO,CAAE,GADE,KAAK,cAAcA,CAAG,EACpB,GAAAc,EAAI,EAAAvB,EACpB,CACD,iBAAiBiS,EAAc,CAC3B,GAAIA,EAAa,QAAU,GAAI,CAC3B,MAAMjS,EAAI,IAAI,WAAW,EAAE,EAC3B,OAAAA,EAAE,IAAIiS,CAAY,EACXjS,CACV,KAEG,QAAO,KAAK,QAAQiS,EAAc,IAAI,WAAW,CAAC,CAAC,CAE1D,CACD,MAAMJ,EAAI,CACN,KAAM,CAACM,EAAQC,CAAM,EAAI,KAAK,OAAO,QAAQP,EAAG,GAAI,IAAI,WAAW,CAAC,CAAC,EAC/DQ,EAAM,KAAK,cAAcF,CAAM,EAC/BG,EAAM,KAAK,cAAcF,CAAM,EACrC,MAAO,CAAE,IAAAC,EAAK,IAAAC,EACjB,CACD,oBAAoBX,EAAIlC,EAAS,CAC7B,MAAMhN,EAAa,KAAK,cAAckP,EAAI,IAAI,WAAW,CAAC,EAAGlC,CAAO,EAC9D8C,EAAK,KAAK,iBACVC,EAAK,IAAI,WAAW,CAAC,EAC3B,MAAO,CAAE,GAAAD,EAAI,GAAAC,EAAI,WAAA/P,EACpB,CACD,mBAAmBkP,EAAI5O,EAAS,CAC5B,OAAO,KAAK,cAAc4O,EAAI,IAAI,WAAW,CAAC,EAAG5O,EAAQ,UAAU,CACtE,CACL,CCvIO,MAAM0P,WAAWhB,EAAkB,CACtC,oBAAoBiB,EAAUhC,EAAGK,EAAI4B,EAAK,CACtC,MAAMrM,EAAO,mCACPuL,EAAK,KAAK,oBAAoBvL,CAAI,EACxC,KAAK,QAAQuL,EAAIa,CAAQ,EACzB,MAAMzB,EAAK,IAAI,WAAW,EAAE,EAC5B,MAAO,CAAE,GAAAY,EAAI,EAAAnB,EAAG,GAAAK,EAAI,IAAA4B,EAAK,GAAA1B,CAAE,CAC9B,CACD,oBAAoByB,EAAUhC,EAAGK,EAAI4B,EAAK,CACtC,MAAMrM,EAAO,mCACPuL,EAAK,KAAK,oBAAoBvL,CAAI,EACxC,KAAK,QAAQuL,EAAIa,CAAQ,EACzB,MAAMzB,EAAK,IAAI,WAAW,EAAE,EAC5B,MAAO,CAAE,GAAAY,EAAI,EAAAnB,EAAG,GAAAK,EAAI,IAAA4B,EAAK,GAAA1B,CAAE,CAC9B,CACD,cAAc2B,EAAInD,EAASoB,EAAG,CAC1B,MAAM2B,EAAK,IAAI,WAAW,CAAC,EACvB3B,IAAM,OACN+B,EAAG,EAAI/B,EAGP+B,EAAG,EAAI,KAAK,OAAO,sBAAqB,EAE5C,MAAML,EAAKK,EAAG,EAAE,UAChB,KAAK,QAAQA,EAAG,GAAIL,CAAE,EACtB,MAAM9P,EAAa,KAAK,eAAemQ,EAAG,GAAInD,CAAO,EACrD,MAAO,CAAE,GAAA8C,EAAI,GAAAC,EAAI,WAAA/P,EACpB,CACD,cAAcmQ,EAAInD,EAAS,CACvBmD,EAAG,EAAI,KAAK,OAAO,sBAAqB,EACxC,MAAML,EAAKK,EAAG,EAAE,UAChB,KAAK,QAAQA,EAAG,GAAIL,CAAE,EACtB,KAAK,OAAOK,EAAG,GAAI,KAAK,GAAGA,EAAG,EAAE,WAAYA,EAAG,EAAE,CAAC,EAClD,MAAMC,EAAMD,EAAG,EAAE,UACXJ,EAAK,KAAK,eAAeI,EAAG,GAAIC,CAAG,EACzC,KAAK,OAAOD,EAAG,GAAI,KAAK,GAAGA,EAAG,EAAE,WAAYA,EAAG,EAAE,CAAC,EAClD,MAAMnQ,EAAa,KAAK,eAAemQ,EAAG,GAAInD,CAAO,EACrD,MAAO,CAAE,GAAA8C,EAAI,GAAAC,EAAI,WAAA/P,EACpB,CACD,cAAcmQ,EAAInD,EAAS,CACvB,MAAMoD,EAAMD,EAAG,EAAE,UACXJ,EAAK,KAAK,eAAeI,EAAG,GAAIC,CAAG,EACzC,KAAK,OAAOD,EAAG,GAAI,KAAK,GAAGA,EAAG,EAAE,WAAYA,EAAG,EAAE,CAAC,EAClD,MAAMnQ,EAAa,KAAK,eAAemQ,EAAG,GAAInD,CAAO,EAE/CqD,EAAgB,CAAE,GADb,KAAK,iBACY,GAAAN,EAAI,WAAA/P,CAAU,EACpC,CAAE,IAAA4P,EAAK,IAAAC,CAAK,EAAG,KAAK,MAAMM,EAAG,EAAE,EACrC,MAAO,CAAE,EAAGA,EAAG,GAAG,EAAG,cAAAE,EAAe,IAAAT,EAAK,IAAAC,EAC5C,CACD,aAAaM,EAAI7P,EAAS,CACtB,OAAIqN,EAAiBrN,EAAQ,EAAE,IAC3B6P,EAAG,GAAK7P,EAAQ,IAEpB,KAAK,QAAQ6P,EAAG,GAAIA,EAAG,EAAE,EAClB,KAAK,eAAeA,EAAG,GAAI7P,EAAQ,UAAU,CACvD,CACD,aAAa6P,EAAI7P,EAAS,CAKtB,GAJIqN,EAAiBrN,EAAQ,EAAE,IAC3B6P,EAAG,GAAK7P,EAAQ,IAEpB,KAAK,QAAQ6P,EAAG,GAAIA,EAAG,EAAE,EACrB,CAACA,EAAG,EACJ,MAAM,IAAI,MAAM,uCAAuC,EAE3D,KAAK,OAAOA,EAAG,GAAI,KAAK,GAAGA,EAAG,EAAE,WAAYA,EAAG,EAAE,CAAC,EAClD,KAAM,CAAE,UAAWJ,EAAI,MAAOO,CAAQ,EAAG,KAAK,eAAeH,EAAG,GAAI7P,EAAQ,EAAE,EAC1EgQ,GAAU3C,EAAiBoC,CAAE,IAC7BI,EAAG,GAAKJ,GAEZ,KAAK,OAAOI,EAAG,GAAI,KAAK,GAAGA,EAAG,EAAE,WAAYA,EAAG,EAAE,CAAC,EAClD,KAAM,CAAE,UAAAxQ,EAAW,MAAO4Q,GAAW,KAAK,eAAeJ,EAAG,GAAI7P,EAAQ,UAAU,EAClF,MAAO,CAAE,UAAAX,EAAW,MAAQ2Q,GAAUC,CAAO,CAChD,CACD,aAAaJ,EAAI7P,EAAS,CACtB,KAAM,CAAE,UAAWyP,EAAI,MAAOO,CAAQ,EAAG,KAAK,eAAeH,EAAG,GAAI7P,EAAQ,EAAE,EAI9E,GAHIgQ,GAAU3C,EAAiBoC,CAAE,IAC7BI,EAAG,GAAKJ,GAER,CAACI,EAAG,EACJ,MAAM,IAAI,MAAM,uCAAuC,EAE3D,KAAK,OAAOA,EAAG,GAAI,KAAK,GAAGA,EAAG,EAAE,WAAYA,EAAG,EAAE,CAAC,EAClD,KAAM,CAAE,UAAAxQ,EAAW,MAAO4Q,GAAW,KAAK,eAAeJ,EAAG,GAAI7P,EAAQ,UAAU,EAC5E,CAAE,IAAAsP,EAAK,IAAAC,CAAK,EAAG,KAAK,MAAMM,EAAG,EAAE,EACrC,MAAO,CAAE,EAAGA,EAAG,GAAG,EAAG,UAAAxQ,EAAW,MAAQ2Q,GAAUC,EAAS,IAAAX,EAAK,IAAAC,CAAG,CACtE,CACD,YAAYW,EAAWP,EAAUhC,EAAG,CAChC,MAAMiC,EAAM,KAAK,iBACX5B,EAAK,IAAI,WAAW,EAAE,EAC5B,IAAI6B,EACJ,OAAIK,EACAL,EAAK,KAAK,oBAAoBF,EAAUhC,EAAGK,EAAI4B,CAAG,EAGlDC,EAAK,KAAK,oBAAoBF,EAAUhC,EAAGK,EAAI4B,CAAG,EAE/C,CACH,GAAAC,EACA,EAAGK,EACH,GAAI,CAChB,CACK,CACD,YAAY9B,EAASpO,EAASmQ,EAAW,CACrC,IAAIJ,EACJ,GAAI3B,EAAQ,KAAO,EACf2B,EAAgB,KAAK,cAAc3B,EAAQ,GAAIpO,EAASmQ,CAAS,UAE5D/B,EAAQ,KAAO,EACpB2B,EAAgB,KAAK,cAAc3B,EAAQ,GAAIpO,CAAO,UAEjDoO,EAAQ,KAAO,EAAG,CACvB,KAAM,CAAE,EAAAnR,EAAG,cAAemT,EAAiB,IAAAd,EAAK,IAAAC,GAAQ,KAAK,cAAcnB,EAAQ,GAAIpO,CAAO,EAC9F+P,EAAgBK,EAChBhC,EAAQ,EAAInR,EACZmR,EAAQ,IAAMkB,EACdlB,EAAQ,IAAMmB,CACjB,SACQnB,EAAQ,GAAK,EAClB,GAAIA,EAAQ,EAAG,CACX,GAAI,CAACA,EAAQ,IACT,MAAM,IAAI,MAAM,mCAAmC,EAEvD2B,EAAgB,KAAK,oBAAoB3B,EAAQ,IAAKpO,CAAO,CAChE,KACI,CACD,GAAI,CAACoO,EAAQ,IACT,MAAM,IAAI,MAAM,mCAAmC,EAEvD2B,EAAgB,KAAK,oBAAoB3B,EAAQ,IAAKpO,CAAO,CAChE,KAGD,OAAM,IAAI,MAAM,kBAAkB,EAEtC,OAAAoO,EAAQ,KACD2B,CACV,CACD,YAAY3B,EAASpO,EAAS,CAC1B,IAAIX,EAAY,IAAI,WAAW,CAAC,EAC5ByB,EAAQ,GACZ,GAAIsN,EAAQ,KAAO,GACd,CAAE,UAAA/O,EAAW,MAAAyB,GAAU,KAAK,aAAasN,EAAQ,GAAIpO,CAAO,WAExDoO,EAAQ,KAAO,GACnB,CAAE,UAAA/O,EAAW,MAAAyB,GAAU,KAAK,aAAasN,EAAQ,GAAIpO,CAAO,WAExDoO,EAAQ,KAAO,EAAG,CACvB,KAAM,CAAE,EAAAnR,EAAG,UAAWoT,EAAoB,MAAOC,EAAgB,IAAAhB,EAAK,IAAAC,CAAK,EAAG,KAAK,aAAanB,EAAQ,GAAIpO,CAAO,EACnHX,EAAYgR,EACZvP,EAAQwP,EACRlC,EAAQ,EAAInR,EACZmR,EAAQ,IAAMkB,EACdlB,EAAQ,IAAMmB,CACjB,CACD,OAAAnB,EAAQ,KACD,CAAE,UAAA/O,EAAW,MAAAyB,EACvB,CACL,CC1JO,MAAMyP,EAAY,CACrB,YAAYC,EAAa9D,EAASiD,EAAUhB,EAAQ8B,EAAeC,EAAYzD,EAAYlV,EAAW,CAClG,KAAK,iBAAmB,CAAE,uBAAwB,CAAE,CAAA,EACpD,KAAK,YAAcyY,EACnB,KAAK,QAAU9D,EACf,KAAK,SAAWiD,EAChB,KAAK,cAAgBc,EACrB,KAAK,WAAaC,EACdzD,IACA,KAAK,WAAaA,GAEtB,KAAK,GAAKlV,GAAa,IAAI2X,GAAGf,CAAM,EACpC,KAAK,QAAU,KAAK,GAAG,YAAY,KAAK,YAAa,KAAK,SAAU,KAAK,aAAa,CACzF,CAED,MAAM,SAAU,CAEZ,GADAjB,GAAmB,KAAK,QAAQ,GAAG,CAAC,EAChC,KAAK,YAAa,CAClBF,EAAO,qDAAqD,EAC5D,MAAMuC,EAAgB,KAAK,GAAG,YAAY,KAAK,QAAS,IAAI,WAAW,CAAC,CAAC,EACzE,KAAK,WAAW,QAAQhQ,GAAQgQ,CAAa,CAAC,EAC9CvC,EAAO,qDAAqD,EAC5DK,GAAsB,KAAK,QAAQ,GAAG,CAAC,CAC1C,KACI,CACDL,EAAO,yDAAyD,EAChE,MAAMmD,EAAwBvQ,IAAS,MAAM,KAAK,WAAW,OAAM,GAAI,SAAQ,CAAE,EAC3E,CAAE,MAAAU,CAAO,EAAG,KAAK,GAAG,YAAY,KAAK,QAAS6P,CAAqB,EACzE,GAAI,CAAC7P,EACD,MAAM,IAAIE,EAA2B,sCAAsC,EAE/EwM,EAAO,6CAA6C,EACpDS,GAAsB,KAAK,QAAQ,GAAG,EAAE,CAC3C,CACJ,CAED,MAAM,UAAW,CACb,GAAI,KAAK,YAAa,CAClBT,EAAO,wEAAwE,EAC/E,MAAMmD,EAAwBrQ,IAAS,MAAM,KAAK,WAAW,OAAM,GAAI,SAAQ,CAAE,EAC3E,CAAE,UAAAjB,EAAW,MAAAyB,CAAK,EAAK,KAAK,GAAG,YAAY,KAAK,QAAS6P,CAAqB,EACpF,GAAI,CAAC7P,EACD,MAAM,IAAIE,EAA2B,sCAAsC,EAE/EwM,EAAO,2CAA2C,EAClDS,GAAsB,KAAK,QAAQ,GAAG,EAAE,EACxCF,GAAmB,KAAK,QAAQ,GAAG,EAAE,EACrCP,EAAO,gDAAgD,EACvD,GAAI,CACA,MAAMoD,EAAiB/D,GAAcxN,CAAS,EAC9C,KAAK,WAAa,KAAK,YAAc,MAAMuN,GAAqBgE,CAAc,EAC9E,MAAM7D,GAAoB,KAAK,QAAQ,GAAG,GAAI6D,EAAgB,KAAK,UAAU,EAC7E,KAAK,wBAAwBA,EAAe,UAAU,CACzD,OACM9C,EAAP,CACI,MAAMxW,EAAMwW,EACZ,MAAM,IAAI/M,GAAoB,kDAAkDzJ,EAAI,SAAS,CAChG,CACDkW,EAAO,8BAA8B,CACxC,KACI,CACDA,EAAO,mFAAmF,EAC1F,MAAMuC,EAAgB,KAAK,GAAG,YAAY,KAAK,QAAS,KAAK,OAAO,EACpE,KAAK,WAAW,QAAQ7P,GAAQ6P,CAAa,CAAC,EAC9CvC,EAAO,4EAA4E,EACnFK,GAAsB,KAAK,QAAQ,GAAG,CAAC,CAC1C,CACJ,CAED,MAAM,QAAS,CACX,GAAI,KAAK,YAAa,CAClBL,EAAO,sDAAsD,EAC7D,MAAMuC,EAAgB,KAAK,GAAG,YAAY,KAAK,QAAS,KAAK,OAAO,EACpE,KAAK,WAAW,QAAQ5P,GAAQ4P,CAAa,CAAC,EAC9CvC,EAAO,uDAAuD,CACjE,KACI,CACDA,EAAO,4DAA4D,EACnE,MAAMmD,EAAwBpQ,IAAS,MAAM,KAAK,WAAW,OAAM,GAAI,SAAQ,CAAE,EAC3E,CAAE,UAAAlB,EAAW,MAAAyB,CAAK,EAAK,KAAK,GAAG,YAAY,KAAK,QAAS6P,CAAqB,EACpF,GAAI,CAAC7P,EACD,MAAM,IAAIE,EAA2B,sCAAsC,EAE/EwM,EAAO,+DAA+D,EACtE,GAAI,CACA,MAAMoD,EAAiB/D,GAAcxN,CAAS,EAC9C,KAAK,WAAa,KAAK,YAAc,MAAMuN,GAAqBgE,CAAc,EAC9E,MAAM7D,GAAoB,KAAK,QAAQ,GAAG,GAAI6D,EAAgB,KAAK,UAAU,EAC7E,KAAK,wBAAwBA,EAAe,UAAU,CACzD,OACM9C,EAAP,CACI,MAAMxW,EAAMwW,EACZ,MAAM,IAAI/M,GAAoB,kDAAkDzJ,EAAI,SAAS,CAChG,CACJ,CACD6W,GAAe,KAAK,OAAO,CAC9B,CACD,QAAQ9O,EAAW+O,EAAS,CACxB,MAAMQ,EAAK,KAAK,MAAMR,CAAO,EAC7B,OAAO,KAAK,GAAG,cAAcQ,EAAI,IAAI,WAAW,CAAC,EAAGvP,CAAS,CAChE,CACD,QAAQK,EAAY0O,EAASzO,EAAK,CAC9B,MAAMiP,EAAK,KAAK,MAAMR,EAAS,EAAK,EACpC,OAAO,KAAK,GAAG,cAAcQ,EAAI,IAAI,WAAW,CAAC,EAAGlP,EAAYC,CAAG,CACtE,CACD,oBAAqB,CACjB,OAAO,KAAK,QAAQ,GAAG,EAC1B,CACD,MAAMyO,EAASyC,EAAa,GAAM,CAC9B,GAAI,CAACzC,EAAQ,KAAO,CAACA,EAAQ,IACzB,MAAM,IAAIpN,EAA2B,gEAAgE,EAEzG,OAAI,KAAK,YACE6P,EAAazC,EAAQ,IAAMA,EAAQ,IAGnCyC,EAAazC,EAAQ,IAAMA,EAAQ,GAEjD,CACD,wBAAwB,EAAG,CACnB,IACA,KAAK,iBAAmB,EAE/B,CACL,CCjIO,SAAS0C,GAAgBrQ,EAAS,CACrC,MAAO,CACH,qBAAsBA,EAAQ,gBAAgB,2CAA4C,CACtF,KAAM,8CAClB,CAAS,EACD,kBAAmBA,EAAQ,gBAAgB,uCAAwC,CAC/E,KAAM,0CAClB,CAAS,EACD,iBAAkBA,EAAQ,gBAAgB,uCAAwC,CAC9E,KAAM,qDAClB,CAAS,EACD,iBAAkBA,EAAQ,gBAAgB,uCAAwC,CAC9E,KAAM,wCAClB,CAAS,EACD,cAAeA,EAAQ,gBAAgB,oCAAqC,CACxE,KAAM,qCAClB,CAAS,CACT,CACA,CCPO,MAAMsQ,EAAM,CACf,YAAYlG,EAAO,GAAI,CACnB,KAAK,SAAW,SAChB,KAAM,CAAE,eAAAmG,EAAgB,WAAA7E,EAAY,OAAAwC,EAAQ,cAAAsC,EAAe,QAAAxQ,CAAS,EAAGoK,EACvE,KAAK,OAAS8D,GAAUpQ,GACxB,KAAK,WAAa4N,EAClB,KAAK,QAAU1L,EAAUqQ,GAAgBrQ,CAAO,EAAI,OAChDuQ,EAEA,KAAK,WAAa,KAAK,OAAO,8BAA8BA,CAAc,EAG1E,KAAK,WAAa,KAAK,OAAO,sBAAqB,EAEvD,KAAK,SAAWC,GAAiB,IAAI,WAAW,CAAC,CACpD,CASD,MAAM,eAAehF,EAAWyE,EAAYzD,EAAY,CACpD,MAAMiE,EAAoBlW,GAAS0V,EAAY,CAC3C,cAAe9Q,GACf,cAAeE,EACf,cAAelD,CAC3B,CAAS,EACK7E,EAAY,MAAM,KAAK,iBAAiB,CAC1C,WAAYmZ,EACZ,YAAa,GACb,UAAAjF,EACA,WAAAgB,CACZ,CAAS,EAED,MAAO,CACH,KAFS,MAAM,KAAK,uBAAuBiE,EAAmBnZ,CAAS,EAGvE,iBAAkBA,EAAU,iBAC5B,WAAYA,EAAU,UAClC,CACK,CASD,MAAM,cAAckU,EAAWyE,EAAYzD,EAAY,CACnD,MAAMiE,EAAoBlW,GAAS0V,EAAY,CAC3C,cAAe9Q,GACf,cAAeE,EACf,cAAelD,CAC3B,CAAS,EACK7E,EAAY,MAAM,KAAK,iBAAiB,CAC1C,WAAYmZ,EACZ,YAAa,GACb,UAAAjF,EACA,WAAAgB,CACZ,CAAS,EAED,MAAO,CACH,KAFS,MAAM,KAAK,uBAAuBiE,EAAmBnZ,CAAS,EAGvE,WAAYA,EAAU,WACtB,iBAAkBA,EAAU,gBACxC,CACK,CAOD,MAAM,iBAAiBoZ,EAAQ,CAC3B,MAAMzE,EAAU,MAAMV,GAAWmF,EAAO,UAAW,KAAK,WAAW,UAAW,KAAK,UAAU,EAE7F,OAAO,MAAM,KAAK,mBAAmBA,EAAQzE,CAAO,CACvD,CACD,MAAM,mBAAmByE,EAAQzE,EAAS,CACtC,KAAM,CAAE,YAAA8D,EAAa,WAAAvD,EAAY,WAAAyD,CAAU,EAAKS,EAC1CpZ,EAAY,IAAIwY,GAAYC,EAAa9D,EAAS,KAAK,SAAU,KAAK,OAAQ,KAAK,WAAYgE,EAAYzD,CAAU,EAC3H,GAAI,CACA,MAAMlV,EAAU,UAChB,MAAMA,EAAU,WAChB,MAAMA,EAAU,SAChB,KAAK,SAAS,qBAAqB,WACtC,OACM+V,EAAP,CAEI,GADA,KAAK,SAAS,kBAAkB,YAC5BA,aAAa,MACb,MAAAA,EAAE,QAAU,uCAAuCA,EAAE,UAC/CA,CAEb,CACD,OAAO/V,CACV,CACD,MAAM,uBAAuB2Y,EAAY3Y,EAAW,CAEhD,KAAM,CAACqZ,EAAQC,CAAI,EAAIzV,GAAU,EAC3B0V,EAAUZ,EAAW,SAC3B,aAAMjU,GAAK2U,EACX5Q,GAAczI,EAAW,KAAK,OAAO,EACrCuZ,EACAlX,GAAO,CAAE,cAAe0F,EAAgB,EACxCY,GAAc3I,EAAW,KAAK,OAAO,EACrCqZ,CACR,EACeC,CACV,CACL,CCxHO,SAASE,GAAM1G,EAAO,GAAI,CAC7B,MAAO,IAAM,IAAIkG,GAAMlG,CAAI,CAC/B,CCDA,MAAM2G,GAAmBC,GAAA,IAAA,OAAO,gCAAuB,EAAA,kBAAA,EAEjDC,GAAYD,GAAA,IAAC,OAAO,0BAAiB,sBACrCE,GAAsB,SAAY,CACpC,GAAIC,IAAaC,GACb,OAAQ,MAAML,IAAkB,QAE/B,GAAIM,GACL,MAAO,GAEN,GAAIC,GACL,OAAQ,MAAML,IAAY,UAG1B,MAAM,IAAI,MAAM,4BAA4B,CAEpD,EAEMM,GAAkB,KACb,CACH,OAAQ,CACJ,QAAS,CAAE,EACX,kBAAmB,CACf,SAAU,EACb,EACD,OAAQ,CACJ,cAAe,CACX,WAAY,CAER,QAAS,EACZ,CACJ,EACD,UAAW,CACP,WAAY,CAEhC,KAAwBC,EACA,eAAgB,CAACV,EAAK,CACzB,CACJ,CACJ,EACD,iBAAkB,CAAE,eAAgB,CAAG,CAC1C,EACD,MAAO,CAAE,QAAS,GAAM,IAAK,CAAE,QAAS,GAAM,OAAQ,GAAQ,EAC9D,OAAQ,CACJ,UAAW,CACP,MAAO,CAEH,wEAEA,8GACH,CACJ,CACJ,CACT,GAEe,eAAeW,GAASC,EAAM,gBAAiB,CAC1D,MAAMC,EAAmB,CACrB,KAAM,OACN,WAAY,GACZ,KAAM,GACN,WAAY,aAAM,OAAO,qBAAM,qBACvC,EACUC,EAASL,KACTM,EAAmB,MAAMX,KAC/BU,EAAO,OAAO,QAAUC,EACxBD,EAAO,KAAOF,EACdC,EAAiB,YAAcC,EAE/B,MAAME,EAAQ,MAAMxf,GAAiBqf,CAAgB,EACrD,aAAMG,EAAM,OACZ,MAAMA,EAAM,QACLA,EAAM,GACjB"}