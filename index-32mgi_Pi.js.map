{"version":3,"file":"index-32mgi_Pi.js","sources":["../../../../node_modules/@libp2p/tcp/dist/src/constants.js","../../../../node_modules/@libp2p/utils/dist/src/ip-port-to-multiaddr.js","../../../../node_modules/stream-to-it/source.js","../../../../node_modules/stream-to-it/node_modules/get-iterator/index.js","../../../../node_modules/stream-to-it/sink.js","../../../../node_modules/stream-to-it/duplex.js","../../../../node_modules/stream-to-it/transform.js","../../../../node_modules/stream-to-it/index.js","../../../../node_modules/@libp2p/tcp/dist/src/utils.js","../../../../node_modules/@libp2p/tcp/dist/src/socket-to-conn.js","../../../../node_modules/@libp2p/tcp/dist/src/listener.js","../../../../node_modules/@libp2p/tcp/dist/src/index.js"],"sourcesContent":["// p2p multi-address code\nexport const CODE_P2P = 421;\nexport const CODE_CIRCUIT = 290;\nexport const CODE_UNIX = 400;\n// Time to wait for a connection to close gracefully before destroying it manually\nexport const CLOSE_TIMEOUT = 500;\n// Close the socket if there is no activity after this long in ms\nexport const SOCKET_TIMEOUT = 5 * 60000; // 5 mins\n//# sourceMappingURL=constants.js.map","import { isIPv4, isIPv6 } from '@chainsafe/is-ip';\nimport { CodeError } from '@libp2p/interface';\nimport { multiaddr } from '@multiformats/multiaddr';\nexport const Errors = {\n    ERR_INVALID_IP_PARAMETER: 'ERR_INVALID_IP_PARAMETER',\n    ERR_INVALID_PORT_PARAMETER: 'ERR_INVALID_PORT_PARAMETER',\n    ERR_INVALID_IP: 'ERR_INVALID_IP'\n};\n/**\n * Transform an IP, Port pair into a multiaddr\n */\nexport function ipPortToMultiaddr(ip, port) {\n    if (typeof ip !== 'string') {\n        throw new CodeError(`invalid ip provided: ${ip}`, Errors.ERR_INVALID_IP_PARAMETER); // eslint-disable-line @typescript-eslint/restrict-template-expressions\n    }\n    if (typeof port === 'string') {\n        port = parseInt(port);\n    }\n    if (isNaN(port)) {\n        throw new CodeError(`invalid port provided: ${port}`, Errors.ERR_INVALID_PORT_PARAMETER);\n    }\n    if (isIPv4(ip)) {\n        return multiaddr(`/ip4/${ip}/tcp/${port}`);\n    }\n    if (isIPv6(ip)) {\n        return multiaddr(`/ip6/${ip}/tcp/${port}`);\n    }\n    throw new CodeError(`invalid ip:port for creating a multiaddr: ${ip}:${port}`, Errors.ERR_INVALID_IP);\n}\n//# sourceMappingURL=ip-port-to-multiaddr.js.map","module.exports = readable => {\n  // Node.js stream\n  if (readable[Symbol.asyncIterator]) return readable\n\n  // Browser ReadableStream\n  if (readable.getReader) {\n    return (async function * () {\n      const reader = readable.getReader()\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read()\n          if (done) return\n          yield value\n        }\n      } finally {\n        reader.releaseLock()\n      }\n    })()\n  }\n\n  throw new Error('unknown stream')\n}\n","// If the passed object is an (async) iterable, then get the iterator\n// If it's probably an iterator already (i.e. has next function) return it\n// else throw\nmodule.exports = function getIterator (obj) {\n  if (obj) {\n    if (typeof obj[Symbol.iterator] === 'function') {\n      return obj[Symbol.iterator]()\n    }\n    if (typeof obj[Symbol.asyncIterator] === 'function') {\n      return obj[Symbol.asyncIterator]()\n    }\n    if (typeof obj.next === 'function') {\n      return obj // probably an iterator\n    }\n  }\n  throw new Error('argument is not an iterator or iterable')\n}\n","const getIterator = require('get-iterator')\n\nmodule.exports = writable => async source => {\n  source = getIterator(source)\n\n  const maybeEndSource = (source) => {\n    if (typeof source.return === 'function') source.return()\n  }\n\n  let error = null\n  let errCb = null\n  const errorHandler = (err) => {\n    error = err\n    if (errCb) errCb(err)\n    // When the writable errors, try to end the source to exit iteration early\n    maybeEndSource(source)\n  }\n\n  let closeCb = null\n  let closed = false\n  const closeHandler = () => {\n    closed = true\n    if (closeCb) closeCb()\n  }\n\n  let finishCb = null\n  let finished = false\n  const finishHandler = () => {\n    finished = true\n    if (finishCb) finishCb()\n  }\n\n  let drainCb = null\n  const drainHandler = () => {\n    if (drainCb) drainCb()\n  }\n\n  const waitForDrainOrClose = () => {\n    return new Promise((resolve, reject) => {\n      closeCb = drainCb = resolve\n      errCb = reject\n      writable.once('drain', drainHandler)\n    })\n  }\n\n  const waitForDone = () => {\n    // Immediately try to end the source\n    maybeEndSource(source)\n    return new Promise((resolve, reject) => {\n      if (closed || finished || error) return resolve()\n      finishCb = closeCb = resolve\n      errCb = reject\n    })\n  }\n\n  const cleanup = () => {\n    writable.removeListener('error', errorHandler)\n    writable.removeListener('close', closeHandler)\n    writable.removeListener('finish', finishHandler)\n    writable.removeListener('drain', drainHandler)\n  }\n\n  writable.once('error', errorHandler)\n  writable.once('close', closeHandler)\n  writable.once('finish', finishHandler)\n\n  try {\n    for await (const value of source) {\n      if (!writable.writable || writable.destroyed || error) break\n\n      if (writable.write(value) === false) {\n        await waitForDrainOrClose()\n      }\n    }\n  } catch (err) {\n    // error is set by stream error handler so only destroy stream if source threw\n    if (!error) {\n      writable.destroy()\n    }\n\n    // could we be obscuring an error here?\n    error = err\n  }\n\n  try {\n    // We're done writing, end everything (n.b. stream may be destroyed at this point but then this is a no-op)\n    if (writable.writable) {\n      writable.end()\n    }\n\n    // Wait until we close or finish. This supports halfClosed streams\n    await waitForDone()\n\n    // Notify the user an error occurred\n    if (error) throw error\n  } finally {\n    // Clean up listeners\n    cleanup()\n  }\n}\n","const toSink = require('./sink')\nconst toSource = require('./source')\n\nmodule.exports = duplex => ({ sink: toSink(duplex), source: toSource(duplex) })\n","const toDuplex = require('./duplex')\n\nmodule.exports = transform => async function * (source) {\n  const duplex = toDuplex(transform)\n  // In a transform the sink and source are connected, an error in the sink\n  // will be thrown in the source also. Catch the sink error to avoid unhandled\n  // rejections and yield from the source.\n  let sinkError\n  duplex.sink(source).catch(err => { sinkError = err })\n\n  yield * duplex.source\n  if (sinkError) throw sinkError\n}\n","module.exports = require('./source')\nmodule.exports.source = require('./source')\nmodule.exports.sink = require('./sink')\nmodule.exports.transform = require('./transform')\nmodule.exports.duplex = require('./duplex')\n","import os from 'os';\nimport path from 'path';\nimport { multiaddr } from '@multiformats/multiaddr';\nconst ProtoFamily = { ip4: 'IPv4', ip6: 'IPv6' };\nexport function multiaddrToNetConfig(addr, config = {}) {\n    const listenPath = addr.getPath();\n    // unix socket listening\n    if (listenPath != null) {\n        if (os.platform() === 'win32') {\n            // Use named pipes on Windows systems.\n            return { path: path.join('\\\\\\\\.\\\\pipe\\\\', listenPath) };\n        }\n        else {\n            return { path: listenPath };\n        }\n    }\n    // tcp listening\n    return { ...config, ...addr.toOptions() };\n}\nexport function getMultiaddrs(proto, ip, port) {\n    const toMa = (ip) => multiaddr(`/${proto}/${ip}/tcp/${port}`);\n    return (isAnyAddr(ip) ? getNetworkAddrs(ProtoFamily[proto]) : [ip]).map(toMa);\n}\nexport function isAnyAddr(ip) {\n    return ['0.0.0.0', '::'].includes(ip);\n}\nconst networks = os.networkInterfaces();\nfunction getNetworkAddrs(family) {\n    const addresses = [];\n    for (const [, netAddrs] of Object.entries(networks)) {\n        if (netAddrs != null) {\n            for (const netAddr of netAddrs) {\n                if (netAddr.family === family) {\n                    addresses.push(netAddr.address);\n                }\n            }\n        }\n    }\n    return addresses;\n}\n//# sourceMappingURL=utils.js.map","import { CodeError } from '@libp2p/interface';\nimport { ipPortToMultiaddr as toMultiaddr } from '@libp2p/utils/ip-port-to-multiaddr';\n// @ts-expect-error no types\nimport toIterable from 'stream-to-it';\nimport { CLOSE_TIMEOUT, SOCKET_TIMEOUT } from './constants.js';\nimport { multiaddrToNetConfig } from './utils.js';\n/**\n * Convert a socket into a MultiaddrConnection\n * https://github.com/libp2p/interface-transport#multiaddrconnection\n */\nexport const toMultiaddrConnection = (socket, options) => {\n    const log = options.logger.forComponent('libp2p:tcp:socket');\n    const metrics = options.metrics;\n    const metricPrefix = options.metricPrefix ?? '';\n    const inactivityTimeout = options.socketInactivityTimeout ?? SOCKET_TIMEOUT;\n    const closeTimeout = options.socketCloseTimeout ?? CLOSE_TIMEOUT;\n    // Check if we are connected on a unix path\n    if (options.listeningAddr?.getPath() != null) {\n        options.remoteAddr = options.listeningAddr;\n    }\n    if (options.remoteAddr?.getPath() != null) {\n        options.localAddr = options.remoteAddr;\n    }\n    let remoteAddr;\n    if (options.remoteAddr != null) {\n        remoteAddr = options.remoteAddr;\n    }\n    else {\n        if (socket.remoteAddress == null || socket.remotePort == null) {\n            // this can be undefined if the socket is destroyed (for example, if the client disconnected)\n            // https://nodejs.org/dist/latest-v16.x/docs/api/net.html#socketremoteaddress\n            throw new CodeError('Could not determine remote address or port', 'ERR_NO_REMOTE_ADDRESS');\n        }\n        remoteAddr = toMultiaddr(socket.remoteAddress, socket.remotePort);\n    }\n    const lOpts = multiaddrToNetConfig(remoteAddr);\n    const lOptsStr = lOpts.path ?? `${lOpts.host ?? ''}:${lOpts.port ?? ''}`;\n    const { sink, source } = toIterable.duplex(socket);\n    // by default there is no timeout\n    // https://nodejs.org/dist/latest-v16.x/docs/api/net.html#socketsettimeouttimeout-callback\n    socket.setTimeout(inactivityTimeout, () => {\n        log('%s socket read timeout', lOptsStr);\n        metrics?.increment({ [`${metricPrefix}timeout`]: true });\n        // only destroy with an error if the remote has not sent the FIN message\n        let err;\n        if (socket.readable) {\n            err = new CodeError('Socket read timeout', 'ERR_SOCKET_READ_TIMEOUT');\n        }\n        // if the socket times out due to inactivity we must manually close the connection\n        // https://nodejs.org/dist/latest-v16.x/docs/api/net.html#event-timeout\n        socket.destroy(err);\n    });\n    socket.once('close', () => {\n        log('%s socket close', lOptsStr);\n        metrics?.increment({ [`${metricPrefix}close`]: true });\n        // In instances where `close` was not explicitly called,\n        // such as an iterable stream ending, ensure we have set the close\n        // timeline\n        if (maConn.timeline.close == null) {\n            maConn.timeline.close = Date.now();\n        }\n    });\n    socket.once('end', () => {\n        // the remote sent a FIN packet which means no more data will be sent\n        // https://nodejs.org/dist/latest-v16.x/docs/api/net.html#event-end\n        log('%s socket end', lOptsStr);\n        metrics?.increment({ [`${metricPrefix}end`]: true });\n    });\n    const maConn = {\n        async sink(source) {\n            try {\n                await sink((async function* () {\n                    for await (const buf of source) {\n                        if (buf instanceof Uint8Array) {\n                            yield buf;\n                        }\n                        else {\n                            yield buf.subarray();\n                        }\n                    }\n                })());\n            }\n            catch (err) {\n                // If aborted we can safely ignore\n                if (err.type !== 'aborted') {\n                    // If the source errored the socket will already have been destroyed by\n                    // toIterable.duplex(). If the socket errored it will already be\n                    // destroyed. There's nothing to do here except log the error & return.\n                    log.error('%s error in sink', lOptsStr, err);\n                }\n            }\n            // we have finished writing, send the FIN message\n            socket.end();\n        },\n        source,\n        // If the remote address was passed, use it - it may have the peer ID encapsulated\n        remoteAddr,\n        timeline: { open: Date.now() },\n        async close(options = {}) {\n            if (socket.destroyed) {\n                log('%s socket was already destroyed when trying to close', lOptsStr);\n                return;\n            }\n            if (options.signal == null) {\n                const signal = AbortSignal.timeout(closeTimeout);\n                options = {\n                    ...options,\n                    signal\n                };\n            }\n            try {\n                log('%s closing socket', lOptsStr);\n                await new Promise((resolve, reject) => {\n                    socket.once('close', () => {\n                        // socket completely closed\n                        log('%s socket closed', lOptsStr);\n                        resolve();\n                    });\n                    socket.once('error', (err) => {\n                        log('%s socket error', lOptsStr, err);\n                        // error closing socket\n                        if (maConn.timeline.close == null) {\n                            maConn.timeline.close = Date.now();\n                        }\n                        reject(err);\n                    });\n                    // shorten inactivity timeout\n                    socket.setTimeout(closeTimeout);\n                    // close writable end of the socket\n                    socket.end();\n                    if (socket.writableLength > 0) {\n                        // there are outgoing bytes waiting to be sent\n                        socket.once('drain', () => {\n                            log('%s socket drained', lOptsStr);\n                            // all bytes have been sent we can destroy the socket (maybe) before the timeout\n                            socket.destroy();\n                        });\n                    }\n                    else {\n                        // nothing to send, destroy immediately, no need for the timeout\n                        socket.destroy();\n                    }\n                });\n            }\n            catch (err) {\n                this.abort(err);\n            }\n        },\n        abort: (err) => {\n            log('%s socket abort due to error', lOptsStr, err);\n            socket.destroy(err);\n        },\n        log\n    };\n    return maConn;\n};\n//# sourceMappingURL=socket-to-conn.js.map","import net from 'net';\nimport { CodeError, TypedEventEmitter, CustomEvent } from '@libp2p/interface';\nimport { CODE_P2P } from './constants.js';\nimport { toMultiaddrConnection } from './socket-to-conn.js';\nimport { getMultiaddrs, multiaddrToNetConfig } from './utils.js';\n/**\n * Attempts to close the given maConn. If a failure occurs, it will be logged\n */\nasync function attemptClose(maConn, options) {\n    try {\n        await maConn.close();\n    }\n    catch (err) {\n        options.log.error('an error occurred closing the connection', err);\n    }\n}\nvar TCPListenerStatusCode;\n(function (TCPListenerStatusCode) {\n    /**\n     * When server object is initialized but we don't know the listening address yet or\n     * the server object is stopped manually, can be resumed only by calling listen()\n     **/\n    TCPListenerStatusCode[TCPListenerStatusCode[\"INACTIVE\"] = 0] = \"INACTIVE\";\n    TCPListenerStatusCode[TCPListenerStatusCode[\"ACTIVE\"] = 1] = \"ACTIVE\";\n    /* During the connection limits */\n    TCPListenerStatusCode[TCPListenerStatusCode[\"PAUSED\"] = 2] = \"PAUSED\";\n})(TCPListenerStatusCode || (TCPListenerStatusCode = {}));\nexport class TCPListener extends TypedEventEmitter {\n    context;\n    server;\n    /** Keep track of open connections to destroy in case of timeout */\n    connections = new Set();\n    status = { code: TCPListenerStatusCode.INACTIVE };\n    metrics;\n    addr;\n    log;\n    constructor(context) {\n        super();\n        this.context = context;\n        context.keepAlive = context.keepAlive ?? true;\n        context.noDelay = context.noDelay ?? true;\n        this.log = context.logger.forComponent('libp2p:tcp:listener');\n        this.addr = 'unknown';\n        this.server = net.createServer(context, this.onSocket.bind(this));\n        // https://nodejs.org/api/net.html#servermaxconnections\n        // If set reject connections when the server's connection count gets high\n        // Useful to prevent too resource exhaustion via many open connections on high bursts of activity\n        if (context.maxConnections !== undefined) {\n            this.server.maxConnections = context.maxConnections;\n        }\n        if (context.closeServerOnMaxConnections != null) {\n            // Sanity check options\n            if (context.closeServerOnMaxConnections.closeAbove < context.closeServerOnMaxConnections.listenBelow) {\n                throw new CodeError('closeAbove must be >= listenBelow', 'ERROR_CONNECTION_LIMITS');\n            }\n        }\n        this.server\n            .on('listening', () => {\n            if (context.metrics != null) {\n                // we are listening, register metrics for our port\n                const address = this.server.address();\n                if (address == null) {\n                    this.addr = 'unknown';\n                }\n                else if (typeof address === 'string') {\n                    // unix socket\n                    this.addr = address;\n                }\n                else {\n                    this.addr = `${address.address}:${address.port}`;\n                }\n                context.metrics?.registerMetricGroup('libp2p_tcp_inbound_connections_total', {\n                    label: 'address',\n                    help: 'Current active connections in TCP listener',\n                    calculate: () => {\n                        return {\n                            [this.addr]: this.connections.size\n                        };\n                    }\n                });\n                this.metrics = {\n                    status: context.metrics.registerMetricGroup('libp2p_tcp_listener_status_info', {\n                        label: 'address',\n                        help: 'Current status of the TCP listener socket'\n                    }),\n                    errors: context.metrics.registerMetricGroup('libp2p_tcp_listener_errors_total', {\n                        label: 'address',\n                        help: 'Total count of TCP listener errors by type'\n                    }),\n                    events: context.metrics.registerMetricGroup('libp2p_tcp_listener_events_total', {\n                        label: 'address',\n                        help: 'Total count of TCP listener events by type'\n                    })\n                };\n                this.metrics?.status.update({\n                    [this.addr]: TCPListenerStatusCode.ACTIVE\n                });\n            }\n            this.dispatchEvent(new CustomEvent('listening'));\n        })\n            .on('error', err => {\n            this.metrics?.errors.increment({ [`${this.addr} listen_error`]: true });\n            this.dispatchEvent(new CustomEvent('error', { detail: err }));\n        })\n            .on('close', () => {\n            this.metrics?.status.update({\n                [this.addr]: this.status.code\n            });\n            // If this event is emitted, the transport manager will remove the listener from it's cache\n            // in the meanwhile if the connections are dropped then listener will start listening again\n            // and the transport manager will not be able to close the server\n            if (this.status.code !== TCPListenerStatusCode.PAUSED) {\n                this.dispatchEvent(new CustomEvent('close'));\n            }\n        });\n    }\n    onSocket(socket) {\n        if (this.status.code !== TCPListenerStatusCode.ACTIVE) {\n            throw new CodeError('Server is is not listening yet', 'ERR_SERVER_NOT_RUNNING');\n        }\n        // Avoid uncaught errors caused by unstable connections\n        socket.on('error', err => {\n            this.log('socket error', err);\n            this.metrics?.events.increment({ [`${this.addr} error`]: true });\n        });\n        let maConn;\n        try {\n            maConn = toMultiaddrConnection(socket, {\n                listeningAddr: this.status.listeningAddr,\n                socketInactivityTimeout: this.context.socketInactivityTimeout,\n                socketCloseTimeout: this.context.socketCloseTimeout,\n                metrics: this.metrics?.events,\n                metricPrefix: `${this.addr} `,\n                logger: this.context.logger\n            });\n        }\n        catch (err) {\n            this.log.error('inbound connection failed', err);\n            this.metrics?.errors.increment({ [`${this.addr} inbound_to_connection`]: true });\n            return;\n        }\n        this.log('new inbound connection %s', maConn.remoteAddr);\n        try {\n            this.context.upgrader.upgradeInbound(maConn)\n                .then((conn) => {\n                this.log('inbound connection upgraded %s', maConn.remoteAddr);\n                this.connections.add(maConn);\n                socket.once('close', () => {\n                    this.connections.delete(maConn);\n                    if (this.context.closeServerOnMaxConnections != null &&\n                        this.connections.size < this.context.closeServerOnMaxConnections.listenBelow) {\n                        // The most likely case of error is if the port taken by this application is binded by\n                        // another process during the time the server if closed. In that case there's not much\n                        // we can do. resume() will be called again every time a connection is dropped, which\n                        // acts as an eventual retry mechanism. onListenError allows the consumer act on this.\n                        this.resume().catch(e => {\n                            this.log.error('error attempting to listen server once connection count under limit', e);\n                            this.context.closeServerOnMaxConnections?.onListenError?.(e);\n                        });\n                    }\n                });\n                if (this.context.handler != null) {\n                    this.context.handler(conn);\n                }\n                if (this.context.closeServerOnMaxConnections != null &&\n                    this.connections.size >= this.context.closeServerOnMaxConnections.closeAbove) {\n                    this.pause(false).catch(e => {\n                        this.log.error('error attempting to close server once connection count over limit', e);\n                    });\n                }\n                this.dispatchEvent(new CustomEvent('connection', { detail: conn }));\n            })\n                .catch(async (err) => {\n                this.log.error('inbound connection failed', err);\n                this.metrics?.errors.increment({ [`${this.addr} inbound_upgrade`]: true });\n                await attemptClose(maConn, {\n                    log: this.log\n                });\n            })\n                .catch(err => {\n                this.log.error('closing inbound connection failed', err);\n            });\n        }\n        catch (err) {\n            this.log.error('inbound connection failed', err);\n            attemptClose(maConn, {\n                log: this.log\n            })\n                .catch(err => {\n                this.log.error('closing inbound connection failed', err);\n                this.metrics?.errors.increment({ [`${this.addr} inbound_closing_failed`]: true });\n            });\n        }\n    }\n    getAddrs() {\n        if (this.status.code === TCPListenerStatusCode.INACTIVE) {\n            return [];\n        }\n        let addrs = [];\n        const address = this.server.address();\n        const { listeningAddr, peerId } = this.status;\n        if (address == null) {\n            return [];\n        }\n        if (typeof address === 'string') {\n            addrs = [listeningAddr];\n        }\n        else {\n            try {\n                // Because TCP will only return the IPv6 version\n                // we need to capture from the passed multiaddr\n                if (listeningAddr.toString().startsWith('/ip4')) {\n                    addrs = addrs.concat(getMultiaddrs('ip4', address.address, address.port));\n                }\n                else if (address.family === 'IPv6') {\n                    addrs = addrs.concat(getMultiaddrs('ip6', address.address, address.port));\n                }\n            }\n            catch (err) {\n                this.log.error('could not turn %s:%s into multiaddr', address.address, address.port, err);\n            }\n        }\n        return addrs.map(ma => peerId != null ? ma.encapsulate(`/p2p/${peerId}`) : ma);\n    }\n    async listen(ma) {\n        if (this.status.code === TCPListenerStatusCode.ACTIVE || this.status.code === TCPListenerStatusCode.PAUSED) {\n            throw new CodeError('server is already listening', 'ERR_SERVER_ALREADY_LISTENING');\n        }\n        const peerId = ma.getPeerId();\n        const listeningAddr = peerId == null ? ma.decapsulateCode(CODE_P2P) : ma;\n        const { backlog } = this.context;\n        try {\n            this.status = {\n                code: TCPListenerStatusCode.ACTIVE,\n                listeningAddr,\n                peerId,\n                netConfig: multiaddrToNetConfig(listeningAddr, { backlog })\n            };\n            await this.resume();\n        }\n        catch (err) {\n            this.status = { code: TCPListenerStatusCode.INACTIVE };\n            throw err;\n        }\n    }\n    async close() {\n        // Close connections and server the same time to avoid any race condition\n        await Promise.all([\n            Promise.all(Array.from(this.connections.values()).map(async (maConn) => attemptClose(maConn, {\n                log: this.log\n            }))),\n            this.pause(true).catch(e => {\n                this.log.error('error attempting to close server once connection count over limit', e);\n            })\n        ]);\n    }\n    /**\n     * Can resume a stopped or start an inert server\n     */\n    async resume() {\n        if (this.server.listening || this.status.code === TCPListenerStatusCode.INACTIVE) {\n            return;\n        }\n        const netConfig = this.status.netConfig;\n        await new Promise((resolve, reject) => {\n            // NOTE: 'listening' event is only fired on success. Any error such as port already binded, is emitted via 'error'\n            this.server.once('error', reject);\n            this.server.listen(netConfig, resolve);\n        });\n        this.status = { ...this.status, code: TCPListenerStatusCode.ACTIVE };\n        this.log('Listening on %s', this.server.address());\n    }\n    async pause(permanent) {\n        if (!this.server.listening && this.status.code === TCPListenerStatusCode.PAUSED && permanent) {\n            this.status = { code: TCPListenerStatusCode.INACTIVE };\n            return;\n        }\n        if (!this.server.listening || this.status.code !== TCPListenerStatusCode.ACTIVE) {\n            return;\n        }\n        this.log('Closing server on %s', this.server.address());\n        // NodeJS implementation tracks listening status with `this._handle` property.\n        // - Server.close() sets this._handle to null immediately. If this._handle is null, ERR_SERVER_NOT_RUNNING is thrown\n        // - Server.listening returns `this._handle !== null` https://github.com/nodejs/node/blob/386d761943bb1b217fba27d6b80b658c23009e60/lib/net.js#L1675\n        // - Server.listen() if `this._handle !== null` throws ERR_SERVER_ALREADY_LISTEN\n        //\n        // NOTE: Both listen and close are technically not async actions, so it's not necessary to track\n        // states 'pending-close' or 'pending-listen'\n        // From docs https://nodejs.org/api/net.html#serverclosecallback\n        // Stops the server from accepting new connections and keeps existing connections.\n        // 'close' event is emitted only emitted when all connections are ended.\n        // The optional callback will be called once the 'close' event occurs.\n        // We need to set this status before closing server, so other procedures are aware\n        // during the time the server is closing\n        this.status = permanent ? { code: TCPListenerStatusCode.INACTIVE } : { ...this.status, code: TCPListenerStatusCode.PAUSED };\n        await new Promise((resolve, reject) => {\n            this.server.close(err => { (err != null) ? reject(err) : resolve(); });\n        });\n    }\n}\n//# sourceMappingURL=listener.js.map","/**\n * @packageDocumentation\n *\n * A [libp2p transport](https://docs.libp2p.io/concepts/transports/overview/) based on the TCP networking stack.\n *\n * @example\n *\n * ```TypeScript\n * import { tcp } from '@libp2p/tcp'\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { pipe } from 'it-pipe'\n * import all from 'it-all'\n *\n * // A simple upgrader that just returns the MultiaddrConnection\n * const upgrader = {\n *   upgradeInbound: async maConn => maConn,\n *   upgradeOutbound: async maConn => maConn\n * }\n *\n * const transport = tcp()()\n *\n * const listener = transport.createListener({\n *   upgrader,\n *   handler: (socket) => {\n *     console.log('new connection opened')\n *     pipe(\n *       ['hello', ' ', 'World!'],\n *       socket\n *     )\n *   }\n * })\n *\n * const addr = multiaddr('/ip4/127.0.0.1/tcp/9090')\n * await listener.listen(addr)\n * console.log('listening')\n *\n * const socket = await transport.dial(addr, { upgrader })\n * const values = await pipe(\n *   socket,\n *   all\n * )\n * console.log(`Value: ${values.toString()}`)\n *\n * // Close connection after reading\n * await listener.close()\n * ```\n *\n * Outputs:\n *\n * ```sh\n * listening\n * new connection opened\n * Value: hello World!\n * ```\n */\nimport net from 'net';\nimport { AbortError, CodeError, transportSymbol } from '@libp2p/interface';\nimport * as mafmt from '@multiformats/mafmt';\nimport { CODE_CIRCUIT, CODE_P2P, CODE_UNIX } from './constants.js';\nimport { TCPListener } from './listener.js';\nimport { toMultiaddrConnection } from './socket-to-conn.js';\nimport { multiaddrToNetConfig } from './utils.js';\nclass TCP {\n    opts;\n    metrics;\n    components;\n    log;\n    constructor(components, options = {}) {\n        this.log = components.logger.forComponent('libp2p:tcp');\n        this.opts = options;\n        this.components = components;\n        if (components.metrics != null) {\n            this.metrics = {\n                dialerEvents: components.metrics.registerCounterGroup('libp2p_tcp_dialer_events_total', {\n                    label: 'event',\n                    help: 'Total count of TCP dialer events by type'\n                })\n            };\n        }\n    }\n    [transportSymbol] = true;\n    [Symbol.toStringTag] = '@libp2p/tcp';\n    async dial(ma, options) {\n        options.keepAlive = options.keepAlive ?? true;\n        options.noDelay = options.noDelay ?? true;\n        // options.signal destroys the socket before 'connect' event\n        const socket = await this._connect(ma, options);\n        // Avoid uncaught errors caused by unstable connections\n        socket.on('error', err => {\n            this.log('socket error', err);\n        });\n        const maConn = toMultiaddrConnection(socket, {\n            remoteAddr: ma,\n            socketInactivityTimeout: this.opts.outboundSocketInactivityTimeout,\n            socketCloseTimeout: this.opts.socketCloseTimeout,\n            metrics: this.metrics?.dialerEvents,\n            logger: this.components.logger\n        });\n        const onAbort = () => {\n            maConn.close().catch(err => {\n                this.log.error('Error closing maConn after abort', err);\n            });\n        };\n        options.signal?.addEventListener('abort', onAbort, { once: true });\n        this.log('new outbound connection %s', maConn.remoteAddr);\n        const conn = await options.upgrader.upgradeOutbound(maConn);\n        this.log('outbound connection %s upgraded', maConn.remoteAddr);\n        options.signal?.removeEventListener('abort', onAbort);\n        if (options.signal?.aborted === true) {\n            conn.close().catch(err => {\n                this.log.error('Error closing conn after abort', err);\n            });\n            throw new AbortError();\n        }\n        return conn;\n    }\n    async _connect(ma, options) {\n        if (options.signal?.aborted === true) {\n            throw new AbortError();\n        }\n        return new Promise((resolve, reject) => {\n            const start = Date.now();\n            const cOpts = multiaddrToNetConfig(ma, {\n                ...(this.opts.dialOpts ?? {}),\n                ...options\n            });\n            this.log('dialing %a', ma);\n            const rawSocket = net.connect(cOpts);\n            const onError = (err) => {\n                const cOptsStr = cOpts.path ?? `${cOpts.host ?? ''}:${cOpts.port}`;\n                err.message = `connection error ${cOptsStr}: ${err.message}`;\n                this.metrics?.dialerEvents.increment({ error: true });\n                done(err);\n            };\n            const onTimeout = () => {\n                this.log('connection timeout %a', ma);\n                this.metrics?.dialerEvents.increment({ timeout: true });\n                const err = new CodeError(`connection timeout after ${Date.now() - start}ms`, 'ERR_CONNECT_TIMEOUT');\n                // Note: this will result in onError() being called\n                rawSocket.emit('error', err);\n            };\n            const onConnect = () => {\n                this.log('connection opened %a', ma);\n                this.metrics?.dialerEvents.increment({ connect: true });\n                done();\n            };\n            const onAbort = () => {\n                this.log('connection aborted %a', ma);\n                this.metrics?.dialerEvents.increment({ abort: true });\n                rawSocket.destroy();\n                done(new AbortError());\n            };\n            const done = (err) => {\n                rawSocket.removeListener('error', onError);\n                rawSocket.removeListener('timeout', onTimeout);\n                rawSocket.removeListener('connect', onConnect);\n                if (options.signal != null) {\n                    options.signal.removeEventListener('abort', onAbort);\n                }\n                if (err != null) {\n                    reject(err);\n                    return;\n                }\n                resolve(rawSocket);\n            };\n            rawSocket.on('error', onError);\n            rawSocket.on('timeout', onTimeout);\n            rawSocket.on('connect', onConnect);\n            if (options.signal != null) {\n                options.signal.addEventListener('abort', onAbort);\n            }\n        });\n    }\n    /**\n     * Creates a TCP listener. The provided `handler` function will be called\n     * anytime a new incoming Connection has been successfully upgraded via\n     * `upgrader.upgradeInbound`.\n     */\n    createListener(options) {\n        return new TCPListener({\n            ...(this.opts.listenOpts ?? {}),\n            ...options,\n            maxConnections: this.opts.maxConnections,\n            backlog: this.opts.backlog,\n            closeServerOnMaxConnections: this.opts.closeServerOnMaxConnections,\n            socketInactivityTimeout: this.opts.inboundSocketInactivityTimeout,\n            socketCloseTimeout: this.opts.socketCloseTimeout,\n            metrics: this.components.metrics,\n            logger: this.components.logger\n        });\n    }\n    /**\n     * Takes a list of `Multiaddr`s and returns only valid TCP addresses\n     */\n    filter(multiaddrs) {\n        multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n        return multiaddrs.filter(ma => {\n            if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n                return false;\n            }\n            if (ma.protoCodes().includes(CODE_UNIX)) {\n                return true;\n            }\n            return mafmt.TCP.matches(ma.decapsulateCode(CODE_P2P));\n        });\n    }\n}\nexport function tcp(init = {}) {\n    return (components) => {\n        return new TCP(components, init);\n    };\n}\n//# sourceMappingURL=index.js.map"],"names":["CODE_P2P","CODE_CIRCUIT","CODE_UNIX","CLOSE_TIMEOUT","SOCKET_TIMEOUT","Errors","ipPortToMultiaddr","ip","port","CodeError","isIPv4","multiaddr","isIPv6","source","readable","reader","done","value","getIterator","obj","require$$0","sink","writable","maybeEndSource","error","errCb","errorHandler","err","closeCb","closed","closeHandler","finishCb","finished","finishHandler","drainCb","drainHandler","waitForDrainOrClose","resolve","reject","waitForDone","cleanup","toSink","toSource","require$$1","duplex","toDuplex","transform","sinkError","streamToItModule","require$$2","require$$3","ProtoFamily","multiaddrToNetConfig","addr","config","listenPath","os","path","getMultiaddrs","proto","toMa","isAnyAddr","getNetworkAddrs","networks","family","addresses","netAddrs","netAddr","toMultiaddrConnection","socket","options","log","metrics","metricPrefix","inactivityTimeout","closeTimeout","remoteAddr","toMultiaddr","lOpts","lOptsStr","toIterable","maConn","buf","signal","attemptClose","TCPListenerStatusCode","TCPListener","TypedEventEmitter","context","net","address","CustomEvent","conn","e","addrs","listeningAddr","peerId","ma","backlog","netConfig","permanent","TCP","components","transportSymbol","onAbort","AbortError","start","cOpts","rawSocket","onError","cOptsStr","onTimeout","onConnect","multiaddrs","mafmt.TCP","tcp","init"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}