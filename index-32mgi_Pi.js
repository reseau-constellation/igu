import{C as g,i as M,m as b,j as V,f as L,k as U,T as G,p as O,l as A,t as F,A as T,n as H}from"./index-JqcA_ETk.js";import k from"./os-cDfjIm6s.js";const D=421,z=290,B=400,K=500,W=5*6e4,_={ERR_INVALID_IP_PARAMETER:"ERR_INVALID_IP_PARAMETER",ERR_INVALID_PORT_PARAMETER:"ERR_INVALID_PORT_PARAMETER",ERR_INVALID_IP:"ERR_INVALID_IP"};function X(r,e){if(typeof r!="string")throw new g(`invalid ip provided: ${r}`,_.ERR_INVALID_IP_PARAMETER);if(typeof e=="string"&&(e=parseInt(e)),isNaN(e))throw new g(`invalid port provided: ${e}`,_.ERR_INVALID_PORT_PARAMETER);if(M(r))return b(`/ip4/${r}/tcp/${e}`);if(V(r))return b(`/ip6/${r}/tcp/${e}`);throw new g(`invalid ip:port for creating a multiaddr: ${r}:${e}`,_.ERR_INVALID_IP)}var E={exports:{}},R=r=>{if(r[Symbol.asyncIterator])return r;if(r.getReader)return async function*(){const e=r.getReader();try{for(;;){const{done:t,value:n}=await e.read();if(t)return;yield n}}finally{e.releaseLock()}}();throw new Error("unknown stream")},Y=function(e){if(e){if(typeof e[Symbol.iterator]=="function")return e[Symbol.iterator]();if(typeof e[Symbol.asyncIterator]=="function")return e[Symbol.asyncIterator]();if(typeof e.next=="function")return e}throw new Error("argument is not an iterator or iterable")};const q=Y;var N=r=>async e=>{e=q(e);const t=h=>{typeof h.return=="function"&&h.return()};let n=null,s=null;const l=h=>{n=h,s&&s(h),t(e)};let u=null,o=!1;const f=()=>{o=!0,u&&u()};let a=null,p=!1;const v=()=>{p=!0,a&&a()};let m=null;const i=()=>{m&&m()},d=()=>new Promise((h,C)=>{u=m=h,s=C,r.once("drain",i)}),I=()=>(t(e),new Promise((h,C)=>{if(o||p||n)return h();a=u=h,s=C})),y=()=>{r.removeListener("error",l),r.removeListener("close",f),r.removeListener("finish",v),r.removeListener("drain",i)};r.once("error",l),r.once("close",f),r.once("finish",v);try{for await(const h of e){if(!r.writable||r.destroyed||n)break;r.write(h)===!1&&await d()}}catch(h){n||r.destroy(),n=h}try{if(r.writable&&r.end(),await I(),n)throw n}finally{y()}};const J=N,Q=R;var x=r=>({sink:J(r),source:Q(r)});const Z=x;var j=r=>async function*(e){const t=Z(r);let n;if(t.sink(e).catch(s=>{n=s}),yield*t.source,n)throw n};E.exports=R;E.exports.source=R;E.exports.sink=N;E.exports.transform=j;E.exports.duplex=x;var ee=E.exports;const te=L(ee),re={ip4:"IPv4",ip6:"IPv6"};function P(r,e={}){const t=r.getPath();return t!=null?k.platform()==="win32"?{path:U.join("\\\\.\\pipe\\",t)}:{path:t}:{...e,...r.toOptions()}}function S(r,e,t){const n=s=>b(`/${r}/${s}/tcp/${t}`);return(ne(e)?oe(re[r]):[e]).map(n)}function ne(r){return["0.0.0.0","::"].includes(r)}const se=k.networkInterfaces();function oe(r){const e=[];for(const[,t]of Object.entries(se))if(t!=null)for(const n of t)n.family===r&&e.push(n.address);return e}const $=(r,e)=>{const t=e.logger.forComponent("libp2p:tcp:socket"),n=e.metrics,s=e.metricPrefix??"",l=e.socketInactivityTimeout??W,u=e.socketCloseTimeout??K;e.listeningAddr?.getPath()!=null&&(e.remoteAddr=e.listeningAddr),e.remoteAddr?.getPath()!=null&&(e.localAddr=e.remoteAddr);let o;if(e.remoteAddr!=null)o=e.remoteAddr;else{if(r.remoteAddress==null||r.remotePort==null)throw new g("Could not determine remote address or port","ERR_NO_REMOTE_ADDRESS");o=X(r.remoteAddress,r.remotePort)}const f=P(o),a=f.path??`${f.host??""}:${f.port??""}`,{sink:p,source:v}=te.duplex(r);r.setTimeout(l,()=>{t("%s socket read timeout",a),n?.increment({[`${s}timeout`]:!0});let i;r.readable&&(i=new g("Socket read timeout","ERR_SOCKET_READ_TIMEOUT")),r.destroy(i)}),r.once("close",()=>{t("%s socket close",a),n?.increment({[`${s}close`]:!0}),m.timeline.close==null&&(m.timeline.close=Date.now())}),r.once("end",()=>{t("%s socket end",a),n?.increment({[`${s}end`]:!0})});const m={async sink(i){try{await p(async function*(){for await(const d of i)d instanceof Uint8Array?yield d:yield d.subarray()}())}catch(d){d.type!=="aborted"&&t.error("%s error in sink",a,d)}r.end()},source:v,remoteAddr:o,timeline:{open:Date.now()},async close(i={}){if(r.destroyed){t("%s socket was already destroyed when trying to close",a);return}if(i.signal==null){const d=AbortSignal.timeout(u);i={...i,signal:d}}try{t("%s closing socket",a),await new Promise((d,I)=>{r.once("close",()=>{t("%s socket closed",a),d()}),r.once("error",y=>{t("%s socket error",a,y),m.timeline.close==null&&(m.timeline.close=Date.now()),I(y)}),r.setTimeout(u),r.end(),r.writableLength>0?r.once("drain",()=>{t("%s socket drained",a),r.destroy()}):r.destroy()})}catch(d){this.abort(d)}},abort:i=>{t("%s socket abort due to error",a,i),r.destroy(i)},log:t};return m};async function w(r,e){try{await r.close()}catch(t){e.log.error("an error occurred closing the connection",t)}}var c;(function(r){r[r.INACTIVE=0]="INACTIVE",r[r.ACTIVE=1]="ACTIVE",r[r.PAUSED=2]="PAUSED"})(c||(c={}));class ie extends G{context;server;connections=new Set;status={code:c.INACTIVE};metrics;addr;log;constructor(e){if(super(),this.context=e,e.keepAlive=e.keepAlive??!0,e.noDelay=e.noDelay??!0,this.log=e.logger.forComponent("libp2p:tcp:listener"),this.addr="unknown",this.server=O.createServer(e,this.onSocket.bind(this)),e.maxConnections!==void 0&&(this.server.maxConnections=e.maxConnections),e.closeServerOnMaxConnections!=null&&e.closeServerOnMaxConnections.closeAbove<e.closeServerOnMaxConnections.listenBelow)throw new g("closeAbove must be >= listenBelow","ERROR_CONNECTION_LIMITS");this.server.on("listening",()=>{if(e.metrics!=null){const t=this.server.address();t==null?this.addr="unknown":typeof t=="string"?this.addr=t:this.addr=`${t.address}:${t.port}`,e.metrics?.registerMetricGroup("libp2p_tcp_inbound_connections_total",{label:"address",help:"Current active connections in TCP listener",calculate:()=>({[this.addr]:this.connections.size})}),this.metrics={status:e.metrics.registerMetricGroup("libp2p_tcp_listener_status_info",{label:"address",help:"Current status of the TCP listener socket"}),errors:e.metrics.registerMetricGroup("libp2p_tcp_listener_errors_total",{label:"address",help:"Total count of TCP listener errors by type"}),events:e.metrics.registerMetricGroup("libp2p_tcp_listener_events_total",{label:"address",help:"Total count of TCP listener events by type"})},this.metrics?.status.update({[this.addr]:c.ACTIVE})}this.dispatchEvent(new A("listening"))}).on("error",t=>{this.metrics?.errors.increment({[`${this.addr} listen_error`]:!0}),this.dispatchEvent(new A("error",{detail:t}))}).on("close",()=>{this.metrics?.status.update({[this.addr]:this.status.code}),this.status.code!==c.PAUSED&&this.dispatchEvent(new A("close"))})}onSocket(e){if(this.status.code!==c.ACTIVE)throw new g("Server is is not listening yet","ERR_SERVER_NOT_RUNNING");e.on("error",n=>{this.log("socket error",n),this.metrics?.events.increment({[`${this.addr} error`]:!0})});let t;try{t=$(e,{listeningAddr:this.status.listeningAddr,socketInactivityTimeout:this.context.socketInactivityTimeout,socketCloseTimeout:this.context.socketCloseTimeout,metrics:this.metrics?.events,metricPrefix:`${this.addr} `,logger:this.context.logger})}catch(n){this.log.error("inbound connection failed",n),this.metrics?.errors.increment({[`${this.addr} inbound_to_connection`]:!0});return}this.log("new inbound connection %s",t.remoteAddr);try{this.context.upgrader.upgradeInbound(t).then(n=>{this.log("inbound connection upgraded %s",t.remoteAddr),this.connections.add(t),e.once("close",()=>{this.connections.delete(t),this.context.closeServerOnMaxConnections!=null&&this.connections.size<this.context.closeServerOnMaxConnections.listenBelow&&this.resume().catch(s=>{this.log.error("error attempting to listen server once connection count under limit",s),this.context.closeServerOnMaxConnections?.onListenError?.(s)})}),this.context.handler!=null&&this.context.handler(n),this.context.closeServerOnMaxConnections!=null&&this.connections.size>=this.context.closeServerOnMaxConnections.closeAbove&&this.pause(!1).catch(s=>{this.log.error("error attempting to close server once connection count over limit",s)}),this.dispatchEvent(new A("connection",{detail:n}))}).catch(async n=>{this.log.error("inbound connection failed",n),this.metrics?.errors.increment({[`${this.addr} inbound_upgrade`]:!0}),await w(t,{log:this.log})}).catch(n=>{this.log.error("closing inbound connection failed",n)})}catch(n){this.log.error("inbound connection failed",n),w(t,{log:this.log}).catch(s=>{this.log.error("closing inbound connection failed",s),this.metrics?.errors.increment({[`${this.addr} inbound_closing_failed`]:!0})})}}getAddrs(){if(this.status.code===c.INACTIVE)return[];let e=[];const t=this.server.address(),{listeningAddr:n,peerId:s}=this.status;if(t==null)return[];if(typeof t=="string")e=[n];else try{n.toString().startsWith("/ip4")?e=e.concat(S("ip4",t.address,t.port)):t.family==="IPv6"&&(e=e.concat(S("ip6",t.address,t.port)))}catch(l){this.log.error("could not turn %s:%s into multiaddr",t.address,t.port,l)}return e.map(l=>s!=null?l.encapsulate(`/p2p/${s}`):l)}async listen(e){if(this.status.code===c.ACTIVE||this.status.code===c.PAUSED)throw new g("server is already listening","ERR_SERVER_ALREADY_LISTENING");const t=e.getPeerId(),n=t==null?e.decapsulateCode(D):e,{backlog:s}=this.context;try{this.status={code:c.ACTIVE,listeningAddr:n,peerId:t,netConfig:P(n,{backlog:s})},await this.resume()}catch(l){throw this.status={code:c.INACTIVE},l}}async close(){await Promise.all([Promise.all(Array.from(this.connections.values()).map(async e=>w(e,{log:this.log}))),this.pause(!0).catch(e=>{this.log.error("error attempting to close server once connection count over limit",e)})])}async resume(){if(this.server.listening||this.status.code===c.INACTIVE)return;const e=this.status.netConfig;await new Promise((t,n)=>{this.server.once("error",n),this.server.listen(e,t)}),this.status={...this.status,code:c.ACTIVE},this.log("Listening on %s",this.server.address())}async pause(e){if(!this.server.listening&&this.status.code===c.PAUSED&&e){this.status={code:c.INACTIVE};return}!this.server.listening||this.status.code!==c.ACTIVE||(this.log("Closing server on %s",this.server.address()),this.status=e?{code:c.INACTIVE}:{...this.status,code:c.PAUSED},await new Promise((t,n)=>{this.server.close(s=>{s!=null?n(s):t()})}))}}class ce{opts;metrics;components;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:tcp"),this.opts=t,this.components=e,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_tcp_dialer_events_total",{label:"event",help:"Total count of TCP dialer events by type"})})}[F]=!0;[Symbol.toStringTag]="@libp2p/tcp";async dial(e,t){t.keepAlive=t.keepAlive??!0,t.noDelay=t.noDelay??!0;const n=await this._connect(e,t);n.on("error",o=>{this.log("socket error",o)});const s=$(n,{remoteAddr:e,socketInactivityTimeout:this.opts.outboundSocketInactivityTimeout,socketCloseTimeout:this.opts.socketCloseTimeout,metrics:this.metrics?.dialerEvents,logger:this.components.logger}),l=()=>{s.close().catch(o=>{this.log.error("Error closing maConn after abort",o)})};t.signal?.addEventListener("abort",l,{once:!0}),this.log("new outbound connection %s",s.remoteAddr);const u=await t.upgrader.upgradeOutbound(s);if(this.log("outbound connection %s upgraded",s.remoteAddr),t.signal?.removeEventListener("abort",l),t.signal?.aborted===!0)throw u.close().catch(o=>{this.log.error("Error closing conn after abort",o)}),new T;return u}async _connect(e,t){if(t.signal?.aborted===!0)throw new T;return new Promise((n,s)=>{const l=Date.now(),u=P(e,{...this.opts.dialOpts??{},...t});this.log("dialing %a",e);const o=O.connect(u),f=i=>{const d=u.path??`${u.host??""}:${u.port}`;i.message=`connection error ${d}: ${i.message}`,this.metrics?.dialerEvents.increment({error:!0}),m(i)},a=()=>{this.log("connection timeout %a",e),this.metrics?.dialerEvents.increment({timeout:!0});const i=new g(`connection timeout after ${Date.now()-l}ms`,"ERR_CONNECT_TIMEOUT");o.emit("error",i)},p=()=>{this.log("connection opened %a",e),this.metrics?.dialerEvents.increment({connect:!0}),m()},v=()=>{this.log("connection aborted %a",e),this.metrics?.dialerEvents.increment({abort:!0}),o.destroy(),m(new T)},m=i=>{if(o.removeListener("error",f),o.removeListener("timeout",a),o.removeListener("connect",p),t.signal!=null&&t.signal.removeEventListener("abort",v),i!=null){s(i);return}n(o)};o.on("error",f),o.on("timeout",a),o.on("connect",p),t.signal!=null&&t.signal.addEventListener("abort",v)})}createListener(e){return new ie({...this.opts.listenOpts??{},...e,maxConnections:this.opts.maxConnections,backlog:this.opts.backlog,closeServerOnMaxConnections:this.opts.closeServerOnMaxConnections,socketInactivityTimeout:this.opts.inboundSocketInactivityTimeout,socketCloseTimeout:this.opts.socketCloseTimeout,metrics:this.components.metrics,logger:this.components.logger})}filter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>t.protoCodes().includes(z)?!1:t.protoCodes().includes(B)?!0:H.matches(t.decapsulateCode(D)))}}function de(r={}){return e=>new ce(e,r)}export{de as tcp};
//# sourceMappingURL=index-32mgi_Pi.js.map
